CG_EigenVector.c:  i_max=X->Check.idim_max;
CG_EigenVector.c:  Eig=X->Phys.Target_CG_energy;
CG_EigenVector.c:  iv = X->Def.initial_iv;
CalcByFullDiag.c:  if(X->Bind.Def.iInputHam==FALSE){
CalcByFullDiag.c:    makeHam(&(X->Bind));
CalcByFullDiag.c:  else if(X->Bind.Def.iInputHam==TRUE){
CalcByFullDiag.c:    inputHam(&(X->Bind));
CalcByFullDiag.c:  if(X->Bind.Def.iOutputHam == TRUE){
CalcByFullDiag.c:    iret=outputHam(&(X->Bind));
CalcByFullDiag.c:  iret=lapack_diag(&(X->Bind));
CalcByFullDiag.c:  X->Bind.Def.St=0;
CalcByFullDiag.c:  phys(&(X->Bind), X->Bind.Check.idim_max);
CalcByFullDiag.c:  iret=output(&(X->Bind));
CalcByLOBPCG.c:  if (X->Def.iReStart == RESTART_INOUT || X->Def.iReStart == RESTART_IN) {
CalcByLOBPCG.c:    //TimeKeeperWithRandAndStep(&(X->Bind), cFileNameTPQStep, cOutputVecStart, "a", rand_i, step_i);
CalcByLOBPCG.c:    for (ie = 0; ie < X->Def.k_exct; ie++) {
CalcByLOBPCG.c:        if (i_max != X->Check.idim_max) {
CalcByLOBPCG.c:        byte_size = fread(wave[ie], sizeof(complex double), X->Check.idim_max + 1, fp);
CalcByLOBPCG.c:    }/*for (ie = 0; ie < X->Def.k_exct; ie++)*/
CalcByLOBPCG.c:  }/*X->Def.iReStart == RESTART_INOUT || X->Def.iReStart == RESTART_IN*/
CalcByLOBPCG.c:  i_max = X->Check.idim_max;
CalcByLOBPCG.c:    for (ie = 0; ie < X->Def.k_exct; ie++) {
CalcByLOBPCG.c:      sum_i_max = SumMPI_li(X->Check.idim_max);
CalcByLOBPCG.c:      X->Large.iv = (sum_i_max / 2 + X->Def.initial_iv + ie) % sum_i_max + 1;
CalcByLOBPCG.c:      iv = X->Large.iv;
CalcByLOBPCG.c:        initial_mode, iv, i_max, X->Def.k_exct);
CalcByLOBPCG.c:            if (X->Def.iInitialVecType == 0) {
CalcByLOBPCG.c:    }/*for (ie = 0; ie < X->Def.k_exct; ie++)*/
CalcByLOBPCG.c:    iv = X->Def.initial_iv;
CalcByLOBPCG.c:      initial_mode, iv, i_max, X->Def.k_exct);
CalcByLOBPCG.c:      for (ie = 0; ie < X->Def.k_exct; ie++) {
CalcByLOBPCG.c:        if (X->Def.iInitialVecType == 0) {
CalcByLOBPCG.c:      }/*for (ie = 0; ie < X->Def.k_exct; ie++)*/
CalcByLOBPCG.c:    for (ie = 0; ie < X->Def.k_exct; ie++) {
CalcByLOBPCG.c:  //TimeKeeperWithRandAndStep(&(X->Bind), cFileNameTPQStep, cOutputVecStart, "a", rand_i, step_i);
CalcByLOBPCG.c:  for (ie = 0; ie < X->Def.k_exct; ie++) {
CalcByLOBPCG.c:    byte_size = fwrite(&X->Large.itr, sizeof(X->Large.itr), 1, fp);
CalcByLOBPCG.c:    byte_size = fwrite(&X->Check.idim_max, sizeof(X->Check.idim_max), 1, fp);
CalcByLOBPCG.c:    byte_size = fwrite(wave[ie], sizeof(complex double), X->Check.idim_max + 1, fp);
CalcByLOBPCG.c:  }/*for (ie = 0; ie < X->Def.k_exct; ie++)*/
CalcByLOBPCG.c:  //TimeKeeperWithRandAndStep(&(X->Bind), cFileNameTPQStep, cOutputVecFinish, "a", rand_i, step_i);
CalcByLOBPCG.c:  nsub = 3 * X->Def.k_exct;
CalcByLOBPCG.c:  d_malloc1(eig, X->Def.k_exct);
CalcByLOBPCG.c:  i_max = X->Check.idim_max;
CalcByLOBPCG.c:  c_malloc3(wxp, 3, X->Def.k_exct, X->Check.idim_max + 1);
CalcByLOBPCG.c:  c_malloc3(hwxp, 3, X->Def.k_exct, X->Check.idim_max + 1);
CalcByLOBPCG.c:  for (ie = 0; ie < X->Def.k_exct; ie++)
CalcByLOBPCG.c:  for (ie = 0; ie < X->Def.k_exct; ie++) 
CalcByLOBPCG.c:  for (ie = 0; ie < X->Def.k_exct; ie++){
CalcByLOBPCG.c:  }/*for (ie = 0; ie < X->Def.k_exct; ie++)*/
CalcByLOBPCG.c:  sprintf(sdt_2, cFileNameLanczosStep, X->Def.CDataFileHead);
CalcByLOBPCG.c:  for (stp = 1; stp <= X->Def.Lanczos_max; stp++) {
CalcByLOBPCG.c:    for (ie = 0; ie < X->Def.k_exct; ie++)
CalcByLOBPCG.c:    eps_LOBPCG = pow(10, -0.5 *X->Def.LanczosEps);
CalcByLOBPCG.c:    for (ie = 0; ie < X->Def.k_exct; ie++) {
CalcByLOBPCG.c:    }/*for (ie = 0; ie < X->Def.k_exct; ie++)*/
CalcByLOBPCG.c:    for (ie = 0; ie < X->Def.k_exct; ie++) {
CalcByLOBPCG.c:      for (ie = 0; ie < X->Def.k_exct; ie++)
CalcByLOBPCG.c:    for (ie = 0; ie < X->Def.k_exct; ie++)
CalcByLOBPCG.c:      for (ie = 0; ie < X->Def.k_exct; ie++){
CalcByLOBPCG.c:          for (je = 0; je < X->Def.k_exct; je++){
CalcByLOBPCG.c:            hsub[je + jj*X->Def.k_exct + ie * nsub + ii * nsub*X->Def.k_exct]
CalcByLOBPCG.c:            ovlp[je + jj*X->Def.k_exct + ie * nsub + ii * nsub*X->Def.k_exct]
CalcByLOBPCG.c:          }/*for (je = 0; je < X->Def.k_exct; je++)*/
CalcByLOBPCG.c:      }/*for (ie = 0; ie < X->Def.k_exct; ie++)*/
CalcByLOBPCG.c:    for (ie = 0; ie < X->Def.k_exct; ie++)
CalcByLOBPCG.c:      creal(hsub[ie + 1 * X->Def.k_exct + ie * nsub + 1 * nsub*X->Def.k_exct]);
CalcByLOBPCG.c:    for (ie = 0; ie < X->Def.k_exct; ie++)
CalcByLOBPCG.c:        for (ie = 0; ie < X->Def.k_exct; ie++) {
CalcByLOBPCG.c:            for (je = 0; je < X->Def.k_exct; je++)
CalcByLOBPCG.c:              work[mythread][ie] += wxp[jj][je][idim] * hsub[je + jj *X->Def.k_exct + nsub*ie];
CalcByLOBPCG.c:        for (ie = 0; ie < X->Def.k_exct; ie++) wxp[1][ie][idim] = work[mythread][ie];
CalcByLOBPCG.c:        for (ie = 0; ie < X->Def.k_exct; ie++) {
CalcByLOBPCG.c:            for (je = 0; je < X->Def.k_exct; je++)
CalcByLOBPCG.c:              work[mythread][ie] += hwxp[jj][je][idim] * hsub[je + jj *X->Def.k_exct + nsub*ie];
CalcByLOBPCG.c:        for (ie = 0; ie < X->Def.k_exct; ie++) hwxp[1][ie][idim] = work[mythread][ie];
CalcByLOBPCG.c:        for (ie = 0; ie < X->Def.k_exct; ie++) {
CalcByLOBPCG.c:            for (je = 0; je < X->Def.k_exct; je++)
CalcByLOBPCG.c:              work[mythread][ie] += wxp[jj][je][idim] * hsub[je + jj *X->Def.k_exct + nsub*ie];
CalcByLOBPCG.c:        for (ie = 0; ie < X->Def.k_exct; ie++) wxp[2][ie][idim] = work[mythread][ie];
CalcByLOBPCG.c:        for (ie = 0; ie < X->Def.k_exct; ie++) {
CalcByLOBPCG.c:            for (je = 0; je < X->Def.k_exct; je++)
CalcByLOBPCG.c:              work[mythread][ie] += hwxp[jj][je][idim] * hsub[je + jj *X->Def.k_exct + nsub*ie];
CalcByLOBPCG.c:        for (ie = 0; ie < X->Def.k_exct; ie++) hwxp[2][ie][idim] = work[mythread][ie];
CalcByLOBPCG.c:      for (ie = 0; ie < X->Def.k_exct; ie++) {
CalcByLOBPCG.c:      }/* for (ie = 0; ie < X->Def.k_exct; ie++)*/
CalcByLOBPCG.c:  }/*for (stp = 1; stp <= X->Def.Lanczos_max; stp++)*/
CalcByLOBPCG.c:  X->Large.itr = stp;
CalcByLOBPCG.c:  sprintf(sdt, cFileNameTimeKeep, X->Def.CDataFileHead);
CalcByLOBPCG.c:  d_free1(eig, X->Def.CDataFileHead);
CalcByLOBPCG.c:  c_free3(hwxp, 3, X->Def.k_exct, X->Check.idim_max + 1);
CalcByLOBPCG.c:  if (X->Def.iReStart == RESTART_OUT || X->Def.iReStart == RESTART_INOUT) Output_restart(X, wxp[1]);
CalcByLOBPCG.c:  c_malloc2(L_vec, X->Def.k_exct, X->Check.idim_max + 1);
CalcByLOBPCG.c:    for (ie = 0; ie < X->Def.k_exct; ie++) {
CalcByLOBPCG.c:    }/*for (ie = 0; ie < X->Def.k_exct; ie++)*/
CalcByLOBPCG.c:  }/*X->Def.k_exct, X->Check.idim_max + 1);*/
CalcByLOBPCG.c:  c_free3(wxp, 3, X->Def.k_exct, X->Check.idim_max + 1);
CalcByLOBPCG.c:  c_malloc1(v0, X->Check.idim_max + 1);
CalcByLOBPCG.c:  c_malloc1(v1, X->Check.idim_max + 1);
CalcByLOBPCG.c:  c_malloc1(vg, X->Check.idim_max + 1);
CalcByLOBPCG.c:  if (X->Bind.Def.iInputEigenVec == FALSE) {
CalcByLOBPCG.c:    switch (X->Bind.Def.iCalcModel) {
CalcByLOBPCG.c:      if (X->Bind.Def.iFlgGeneralSpin == TRUE) {
CalcByLOBPCG.c:        if (X->Bind.Def.initial_iv>0) {
CalcByLOBPCG.c:    if (LOBPCG_Main(&(X->Bind)) != 0) {
CalcByLOBPCG.c:  }/*if (X->Bind.Def.iInputEigenVec == FALSE)*/
CalcByLOBPCG.c:  else {// X->Bind.Def.iInputEigenVec=true :input v1:
CalcByLOBPCG.c:    c_malloc2(L_vec, X->Bind.Def.k_exct, X->Bind.Check.idim_max + 1);
CalcByLOBPCG.c:    for (ie = 0; ie < X->Bind.Def.k_exct; ie++) {
CalcByLOBPCG.c:      TimeKeeper(&(X->Bind), cFileNameTimeKeep, cReadEigenVecStart, "a");
CalcByLOBPCG.c:      sprintf(sdt, cFileNameInputEigen, X->Bind.Def.CDataFileHead, ie, myrank);
CalcByLOBPCG.c:      if (i_max != X->Bind.Check.idim_max) {
CalcByLOBPCG.c:      byte_size = fread(v1, sizeof(complex double), X->Bind.Check.idim_max + 1, fp);
CalcByLOBPCG.c:    }/*for (ie = 0; ie < X->Def.k_exct; ie++)*/
CalcByLOBPCG.c:    TimeKeeper(&(X->Bind), cFileNameTimeKeep, cReadEigenVecFinish, "a");
CalcByLOBPCG.c:  }/*X->Bind.Def.iInputEigenVec == TRUE*/
CalcByLOBPCG.c:  phys(&(X->Bind), X->Bind.Def.k_exct);
CalcByLOBPCG.c:  X->Bind.Def.St=1;
CalcByLOBPCG.c:  if (X->Bind.Def.St == 0) {
CalcByLOBPCG.c:    sprintf(sdt, cFileNameEnergy_Lanczos, X->Bind.Def.CDataFileHead);
CalcByLOBPCG.c:  else if (X->Bind.Def.St == 1) {
CalcByLOBPCG.c:    sprintf(sdt, cFileNameEnergy_CG, X->Bind.Def.CDataFileHead);
CalcByLOBPCG.c:  for (ie = 0; ie < X->Bind.Def.k_exct; ie++) {
CalcByLOBPCG.c:    //phys(&(X->Bind), ie);
CalcByLOBPCG.c:    fprintf(fp, "  Energy  %.16lf \n", X->Bind.Phys.all_energy[ie]);
CalcByLOBPCG.c:    fprintf(fp, "  Doublon  %.16lf \n", X->Bind.Phys.all_doublon[ie]);
CalcByLOBPCG.c:    fprintf(fp, "  Sz  %.16lf \n", X->Bind.Phys.all_sz[ie]);
CalcByLOBPCG.c:    //fprintf(fp, "  S^2  %.16lf \n", X->Bind.Phys.all_s2[ie]);
CalcByLOBPCG.c:    //fprintf(fp, "  N_up  %.16lf \n", X->Bind.Phys.all_num_up[ie]);
CalcByLOBPCG.c:    //fprintf(fp, "  N_down  %.16lf \n", X->Bind.Phys.all_num_down[ie]);
CalcByLOBPCG.c:  if (X->Bind.Def.iOutputEigenVec == TRUE) {
CalcByLOBPCG.c:    TimeKeeper(&(X->Bind), cFileNameTimeKeep, cOutputEigenVecStart, "a");
CalcByLOBPCG.c:    for (ie = 0; ie < X->Bind.Def.k_exct; ie++) {
CalcByLOBPCG.c:      for (idim = 0; idim < X->Bind.Check.idim_max; idim++)
CalcByLOBPCG.c:      sprintf(sdt, cFileNameOutputEigen, X->Bind.Def.CDataFileHead, ie, myrank);
CalcByLOBPCG.c:      byte_size = fwrite(&X->Bind.Large.itr, sizeof(X->Bind.Large.itr), 1, fp);
CalcByLOBPCG.c:      byte_size = fwrite(&X->Bind.Check.idim_max, sizeof(X->Bind.Check.idim_max), 1, fp);
CalcByLOBPCG.c:      byte_size = fwrite(v1, sizeof(complex double), X->Bind.Check.idim_max + 1, fp);
CalcByLOBPCG.c:    }/*for (ie = 0; ie < X->Bind.Def.k_exct; ie++)*/
CalcByLOBPCG.c:    TimeKeeper(&(X->Bind), cFileNameTimeKeep, cOutputEigenVecStart, "a");
CalcByLOBPCG.c:  }/*if (X->Bind.Def.iOutputEigenVec == TRUE)*/
CalcByLanczos.c:  if(X->Bind.Def.iInputEigenVec==FALSE){
CalcByLanczos.c:    switch(X->Bind.Def.iCalcModel){
CalcByLanczos.c:      if(X->Bind.Def.iFlgGeneralSpin ==TRUE){
CalcByLanczos.c:        if(X->Bind.Def.initial_iv>0){
CalcByLanczos.c:    iret=Lanczos_EigenValue(&(X->Bind));
CalcByLanczos.c:    if(X->Bind.Def.iCalcEigenVec==CALCVEC_NOT){
CalcByLanczos.c:       fprintf(stdoutMPI, "  Lanczos EigenValue = %.10lf \n ",X->Bind.Phys.Target_energy);
CalcByLanczos.c:    if(X->Bind.Check.idim_maxMPI != 1){
CalcByLanczos.c:      Lanczos_EigenVector(&(X->Bind));
CalcByLanczos.c:      iret=expec_energy_flct(&(X->Bind));
CalcByLanczos.c:      var      = fabs(X->Bind.Phys.var-X->Bind.Phys.energy*X->Bind.Phys.energy)/fabs(X->Bind.Phys.var);
CalcByLanczos.c:      diff_ene = fabs(X->Bind.Phys.Target_CG_energy-X->Bind.Phys.energy)/fabs(X->Bind.Phys.Target_CG_energy);
CalcByLanczos.c:      fprintf(stdoutMPI, "  LanczosEnergy = %.14e \n  EnergyByVec   = %.14e \n  diff_ene      = %.14e \n  var           = %.14e \n",X->Bind.Phys.Target_CG_energy,X->Bind.Phys.energy,diff_ene,var);
CalcByLanczos.c:      else if(X->Bind.Def.iCalcEigenVec==CALCVEC_LANCZOSCG){
CalcByLanczos.c:        X->Bind.Def.St=1;
CalcByLanczos.c:        iret=CG_EigenVector(&(X->Bind));
CalcByLanczos.c:        iret=expec_energy_flct(&(X->Bind));
CalcByLanczos.c:        var      = fabs(X->Bind.Phys.var-X->Bind.Phys.energy*X->Bind.Phys.energy)/fabs(X->Bind.Phys.var);
CalcByLanczos.c:        diff_ene = fabs(X->Bind.Phys.Target_CG_energy-X->Bind.Phys.energy)/fabs(X->Bind.Phys.Target_CG_energy);
CalcByLanczos.c:        fprintf(stdoutMPI, "  LanczosEnergy = %.14e\n  EnergyByVec   = %.14e\n  diff_ene      = %.14e\n  var           = %.14e \n ",X->Bind.Phys.Target_CG_energy,X->Bind.Phys.energy,diff_ene,var);
CalcByLanczos.c:      iret=expec_energy_flct(&(X->Bind));
CalcByLanczos.c:  else{// X->Bind.Def.iInputEigenVec=true :input v1:
CalcByLanczos.c:    TimeKeeper(&(X->Bind), cFileNameTimeKeep, cReadEigenVecStart, "a");
CalcByLanczos.c:    sprintf(sdt, cFileNameInputEigen, X->Bind.Def.CDataFileHead, X->Bind.Def.k_exct-1, myrank);
CalcByLanczos.c:    if(i_max != X->Bind.Check.idim_max){
CalcByLanczos.c:    byte_size = fread(v1, sizeof(complex double),X->Bind.Check.idim_max+1, fp);
CalcByLanczos.c:    TimeKeeper(&(X->Bind), cFileNameTimeKeep, cReadEigenVecFinish, "a");
CalcByLanczos.c:  if(expec_cisajs(&(X->Bind), v1)!=0){
CalcByLanczos.c:  if(expec_cisajscktaltdc(&(X->Bind), v1)!=0){
CalcByLanczos.c:  if(expec_totalSz(&(X->Bind), v1)!=0){
CalcByLanczos.c:  if(X->Bind.Def.St==0){
CalcByLanczos.c:    sprintf(sdt, cFileNameEnergy_Lanczos, X->Bind.Def.CDataFileHead);
CalcByLanczos.c:  }else if(X->Bind.Def.St==1){
CalcByLanczos.c:    sprintf(sdt, cFileNameEnergy_CG, X->Bind.Def.CDataFileHead);
CalcByLanczos.c:  fprintf(fp,"Energy  %.16lf \n",X->Bind.Phys.energy);
CalcByLanczos.c:  fprintf(fp,"Doublon  %.16lf \n",X->Bind.Phys.doublon);
CalcByLanczos.c:  fprintf(fp,"Sz  %.16lf \n",X->Bind.Phys.Sz);
CalcByLanczos.c:  //    fprintf(fp,"total S^2  %.10lf \n",X->Bind.Phys.s2);    
CalcByLanczos.c:  if(X->Bind.Def.iOutputEigenVec==TRUE){
CalcByLanczos.c:    TimeKeeper(&(X->Bind), cFileNameTimeKeep, cOutputEigenVecStart, "a");
CalcByLanczos.c:    sprintf(sdt, cFileNameOutputEigen, X->Bind.Def.CDataFileHead, X->Bind.Def.k_exct-1, myrank);
CalcByLanczos.c:    fwrite(&X->Bind.Large.itr, sizeof(X->Bind.Large.itr),1,fp);
CalcByLanczos.c:    fwrite(&X->Bind.Check.idim_max, sizeof(X->Bind.Check.idim_max),1,fp);
CalcByLanczos.c:    fwrite(v1, sizeof(complex double),X->Bind.Check.idim_max+1, fp);
CalcByLanczos.c:    TimeKeeper(&(X->Bind), cFileNameTimeKeep, cOutputEigenVecFinish, "a");
CalcByTEM.c:  double Time = X->Bind.Def.Param.Tinit;
CalcByTEM.c:  double dt = ((X->Bind.Def.NLaser==0)? 0.0: X->Bind.Def.Param.TimeSlice);
CalcByTEM.c:  if(X->Bind.Def.NTETimeSteps < X->Bind.Def.Lanczos_max){
CalcByTEM.c:  X->Bind.Def.St = 0;
CalcByTEM.c:  if (X->Bind.Def.iInputEigenVec == FALSE) {
CalcByTEM.c:    TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_InputEigenVectorStart, "a");
CalcByTEM.c:    if (i_max != X->Bind.Check.idim_max) {
CalcByTEM.c:    fread(v1, sizeof(complex double), X->Bind.Check.idim_max + 1, fp);
CalcByTEM.c:    if (X->Bind.Def.iReStart == RESTART_NOT || X->Bind.Def.iReStart == RESTART_OUT) {
CalcByTEM.c:  int iInterAllOffDiagonal_org = X->Bind.Def.NInterAll_OffDiagonal;
CalcByTEM.c:  int iTransfer_org = X->Bind.Def.EDNTransfer;
CalcByTEM.c:  for (step_i = step_initial; step_i < X->Bind.Def.Lanczos_max; step_i++) {
CalcByTEM.c:    X->Bind.Def.istep = step_i;
CalcByTEM.c:    X->Bind.Def.EDNTransfer = iTransfer_org;
CalcByTEM.c:    X->Bind.Def.NInterAll_OffDiagonal = iInterAllOffDiagonal_org;
CalcByTEM.c:    if (step_i % (X->Bind.Def.Lanczos_max / 10) == 0) {
CalcByTEM.c:      fprintf(stdoutMPI, cLogTEStep, step_i, X->Bind.Def.Lanczos_max);
CalcByTEM.c:    if(X->Bind.Def.NLaser !=0) {
CalcByTEM.c:      TransferWithPeierls(&(X->Bind), Time);
CalcByTEM.c:      Time = X->Bind.Def.TETime[step_i];
CalcByTEM.c:        dt = X->Bind.Def.TETime[step_i] - X->Bind.Def.TETime[step_i - 1];
CalcByTEM.c:      X->Bind.Def.Param.TimeSlice = dt;
CalcByTEM.c:      if(X->Bind.Def.NTETransferMax != 0 && X->Bind.Def.NTEInterAllMax!=0){
CalcByTEM.c:      else if (X->Bind.Def.NTETransferMax > 0) { //One-Body type
CalcByTEM.c:        MakeTEDTransfer(&(X->Bind), step_i);
CalcByTEM.c:      }else if (X->Bind.Def.NTEInterAllMax > 0) { //Two-Body type
CalcByTEM.c:        MakeTEDInterAll(&(X->Bind), step_i);
CalcByTEM.c:      TimeKeeperWithStep(&(X->Bind), cFileNameTEStep, cTEStep, "w", step_i);
CalcByTEM.c:      TimeKeeperWithStep(&(X->Bind), cFileNameTEStep, cTEStep, "a", step_i);
CalcByTEM.c:    MultiplyForTEM(&(X->Bind));
CalcByTEM.c:    expec_energy_flct(&(X->Bind));
CalcByTEM.c:    if(X->Bind.Def.NLaser >0 ) Time+=dt;
CalcByTEM.c:    fprintf(fp, "%.16lf  %.16lf %.16lf %.16lf %.16lf %d\n", Time, X->Bind.Phys.energy, X->Bind.Phys.var,
CalcByTEM.c:            X->Bind.Phys.doublon, X->Bind.Phys.num, step_i);
CalcByTEM.c:    fprintf(fp, "%.16lf %.16lf %.16lf %.16lf %.16lf %.16lf %.16lf %d\n", Time,X->Bind.Phys.num,X->Bind.Phys.num2, X->Bind.Phys.doublon,X->Bind.Phys.doublon2, X->Bind.Phys.Sz,X->Bind.Phys.Sz2,step_i);
CalcByTEM.c:      expec_cisajs(&(X->Bind), v1);
CalcByTEM.c:      expec_cisajscktaltdc(&(X->Bind), v1);
CalcByTEM.c:    if (X->Bind.Def.iOutputEigenVec == TRUE) {
CalcByTEM.c:      if (step_i % X->Bind.Def.Param.OutputInterval == 0) {
CalcByTEM.c:        sprintf(sdt, cFileNameOutputEigen, X->Bind.Def.CDataFileHead, step_i, myrank);
CalcByTEM.c:        fwrite(&X->Bind.Check.idim_max, sizeof(long int), 1, fp);
CalcByTEM.c:        fwrite(v1, sizeof(complex double), X->Bind.Check.idim_max + 1, fp);
CalcByTEM.c:  if (X->Bind.Def.iOutputEigenVec == TRUE) {
CalcByTEM.c:    sprintf(sdt, cFileNameOutputEigen, X->Bind.Def.CDataFileHead, rand_i, myrank);
CalcByTEM.c:    fwrite(&X->Bind.Check.idim_max, sizeof(long int), 1, fp);
CalcByTEM.c:    fwrite(v1, sizeof(complex double), X->Bind.Check.idim_max + 1, fp);
CalcByTEM.c:  for(i=0; i<X->Def.NTETransferMax ;i++) {
CalcByTEM.c:      X->Def.EDGeneralTransfer[i + X->Def.EDNTransfer][j] = 0;
CalcByTEM.c:    X->Def.EDParaGeneralTransfer[i+X->Def.EDNTransfer]=0.0;
CalcByTEM.c:  for(i=0; i<X->Def.NTETransfer[timeidx] ;i++){
CalcByTEM.c:      X->Def.EDGeneralTransfer[i + X->Def.EDNTransfer][j] = X->Def.TETransfer[timeidx][i][j];
CalcByTEM.c:    X->Def.EDParaGeneralTransfer[i+X->Def.EDNTransfer]=X->Def.ParaTETransfer[timeidx][i];
CalcByTEM.c:  X->Def.EDNTransfer += X->Def.NTETransfer[timeidx];
CalcByTEM.c:  for (i = 0; i < X->Def.NTEInterAllMax; i++) {
CalcByTEM.c:      X->Def.InterAll_OffDiagonal[i + X->Def.NInterAll_OffDiagonal][j] = 0;
CalcByTEM.c:    X->Def.ParaInterAll_OffDiagonal[i + X->Def.NInterAll_OffDiagonal] = 0.0;
CalcByTEM.c:  for (i = 0; i < X->Def.NTEInterAllOffDiagonal[timeidx]; i++) {
CalcByTEM.c:      X->Def.InterAll_OffDiagonal[i + X->Def.NInterAll_OffDiagonal][j] = X->Def.TEInterAllOffDiagonal[timeidx][i][j];
CalcByTEM.c:    X->Def.ParaInterAll_OffDiagonal[i + X->Def.NInterAll_OffDiagonal] = X->Def.ParaTEInterAllOffDiagonal[timeidx][i];
CalcByTEM.c:  X->Def.NInterAll_OffDiagonal += X->Def.NTEInterAllOffDiagonal[timeidx];
CalcByTPQ.c:  X->Bind.Def.St=0;
CalcByTPQ.c:    Ns = 1.0 * X->Bind.Def.NsiteMPI;
CalcByTPQ.c:    X->Bind.Def.irand=rand_i;
CalcByTPQ.c:    if(X->Bind.Def.iReStart==RESTART_INOUT || X->Bind.Def.iReStart==RESTART_IN) {
CalcByTPQ.c:      TimeKeeperWithRandAndStep(&(X->Bind), cFileNameTPQStep, cOutputVecStart, "a", rand_i, step_i);
CalcByTPQ.c:      if(i_max != X->Bind.Check.idim_max){
CalcByTPQ.c:      byte_size = fread(v0, sizeof(complex double), X->Bind.Check.idim_max+1, fp);
CalcByTPQ.c:      TimeKeeperWithRandAndStep(&(X->Bind), cFileNameTPQStep, cOutputVecFinish, "a", rand_i, step_i);
CalcByTPQ.c:      X->Bind.Def.istep=step_i;
CalcByTPQ.c:      iret=expec_energy_flct(&(X->Bind));
CalcByTPQ.c:    if(X->Bind.Def.iReStart==RESTART_NOT || X->Bind.Def.iReStart==RESTART_OUT || iret ==1) {
CalcByTPQ.c:        TimeKeeperWithRandAndStep(&(X->Bind), cFileNameTPQStep, cTPQStep, "w", rand_i, step_i);
CalcByTPQ.c:        TimeKeeperWithRandAndStep(&(X->Bind), cFileNameTPQStep, cTPQStep, "a", rand_i, step_i);
CalcByTPQ.c:      FirstMultiply(rand_i, &(X->Bind));
CalcByTPQ.c:      iret=expec_energy_flct(&(X->Bind)); //v0 = H*v1
CalcByTPQ.c:      inv_temp = (2.0 / Ns) / (LargeValue - X->Bind.Phys.energy / Ns);
CalcByTPQ.c:      iret=expec_cisajs(&(X->Bind), v1);
CalcByTPQ.c:      iret=expec_cisajscktaltdc(&(X->Bind), v1);
CalcByTPQ.c:      fprintf(fp, "%.16lf  %.16lf %.16lf %.16lf %.16lf %d\n", inv_temp, X->Bind.Phys.energy, X->Bind.Phys.var,
CalcByTPQ.c:              X->Bind.Phys.doublon, X->Bind.Phys.num, step_i);
CalcByTPQ.c:      fprintf(fp, "%.16lf %.16lf %.16lf %.16lf %.16lf %.16lf %.16lf %d\n", inv_temp,X->Bind.Phys.num,X->Bind.Phys.num2, X->Bind.Phys.doublon,X->Bind.Phys.doublon2, X->Bind.Phys.Sz,X->Bind.Phys.Sz2,step_i);
CalcByTPQ.c:      X->Bind.Def.istep = step_i;
CalcByTPQ.c:    for (step_i = X->Bind.Def.istep; step_i<X->Bind.Def.Lanczos_max; step_i++){
CalcByTPQ.c:      X->Bind.Def.istep=step_i;
CalcByTPQ.c:      if(step_i %((X->Bind.Def.Lanczos_max-step_iO)/10)==0){
CalcByTPQ.c:        fprintf(stdoutMPI, cLogTPQStep, step_i, X->Bind.Def.Lanczos_max);
CalcByTPQ.c:      X->Bind.Def.istep=step_i;
CalcByTPQ.c:      TimeKeeperWithRandAndStep(&(X->Bind), cFileNameTPQStep, cTPQStep, "a", rand_i, step_i);
CalcByTPQ.c:      Multiply(&(X->Bind));
CalcByTPQ.c:      iret=expec_energy_flct(&(X->Bind));
CalcByTPQ.c:      inv_temp = (2.0*step_i / Ns) / (LargeValue - X->Bind.Phys.energy / Ns);
CalcByTPQ.c:      fprintf(fp, "%.16lf  %.16lf %.16lf %.16lf %.16lf %d\n", inv_temp, X->Bind.Phys.energy, X->Bind.Phys.var, X->Bind.Phys.doublon, X->Bind.Phys.num ,step_i);
CalcByTPQ.c:      fprintf(fp, "%.16lf %.16lf %.16lf %.16lf %.16lf %.16lf %.16lf %d\n", inv_temp,X->Bind.Phys.num,X->Bind.Phys.num2, X->Bind.Phys.doublon,X->Bind.Phys.doublon2, X->Bind.Phys.Sz,X->Bind.Phys.Sz2,step_i);
CalcByTPQ.c:        iret=expec_cisajs(&(X->Bind),v1);
CalcByTPQ.c:        iret=expec_cisajscktaltdc(&(X->Bind), v1);
CalcByTPQ.c:    if(X->Bind.Def.iReStart== RESTART_OUT || X->Bind.Def.iReStart==RESTART_INOUT){
CalcByTPQ.c:      TimeKeeperWithRandAndStep(&(X->Bind), cFileNameTPQStep, cOutputVecStart, "a", rand_i, step_i);
CalcByTPQ.c:      fwrite(&X->Bind.Check.idim_max, sizeof(X->Bind.Check.idim_max),1,fp);
CalcByTPQ.c:      fwrite(v1, sizeof(complex double),X->Bind.Check.idim_max+1, fp);
CalcByTPQ.c:      TimeKeeperWithRandAndStep(&(X->Bind), cFileNameTPQStep, cOutputVecFinish, "a", rand_i, step_i);
CalcSpectrum.c:  sprintf(sdt, cFileNameCalcDynamicalGreen, X->Bind.Def.CDataFileHead);
CalcSpectrum.c:      creal(dcomega[i]-X->Bind.Def.dcOmegaOrg), cimag(dcomega[i]-X->Bind.Def.dcOmegaOrg),
CalcSpectrum.c:    if (SetOmega(&(X->Bind.Def)) != TRUE) {
CalcSpectrum.c:        if (X->Bind.Def.iFlgSpecOmegaOrg == FALSE) {
CalcSpectrum.c:            X->Bind.Def.dcOmegaOrg = I*(X->Bind.Def.dcOmegaMax - X->Bind.Def.dcOmegaMin) / (double) X->Bind.Def.iNOmega;
CalcSpectrum.c:    Nomega = X->Bind.Def.iNOmega;
CalcSpectrum.c:    OmegaMax = X->Bind.Def.dcOmegaMax + X->Bind.Def.dcOmegaOrg;
CalcSpectrum.c:    OmegaMin = X->Bind.Def.dcOmegaMin + X->Bind.Def.dcOmegaOrg;
CalcSpectrum.c:    if (X->Bind.Def.NSingleExcitationOperator == 0 && X->Bind.Def.NPairExcitationOperator == 0) {
CalcSpectrum.c:    if (MakeExcitedList(&(X->Bind), &iFlagListModified) == FALSE) {
CalcSpectrum.c:    X->Bind.Def.iFlagListModified=iFlagListModified;
CalcSpectrum.c:    c_malloc1(v1Org, X->Bind.Check.idim_maxOrg+1);
CalcSpectrum.c:    for(i=0; i<X->Bind.Check.idim_maxOrg+1; i++){
CalcSpectrum.c:    if (X->Bind.Def.iFlgCalcSpec == RECALC_NOT ||
CalcSpectrum.c:        X->Bind.Def.iFlgCalcSpec == RECALC_OUTPUT_TMComponents_VEC ||
CalcSpectrum.c:       (X->Bind.Def.iFlgCalcSpec == RECALC_INOUT_TMComponents_VEC && X->Bind.Def.iCalcType == CG)) {
CalcSpectrum.c:        TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_InputEigenVectorStart, "a");
CalcSpectrum.c://    sprintf(sdt, cFileNameInputEigen, X->Bind.Def.CDataFileHead, X->Bind.Def.k_exct - 1, myrank);
CalcSpectrum.c:        X->Bind.Large.itr = i_stp; //For TPQ
CalcSpectrum.c:        if (i_max != X->Bind.Check.idim_maxOrg) {
CalcSpectrum.c:        for (i = 0; i <= X->Bind.Check.idim_max; i++) {
CalcSpectrum.c:        TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_InputEigenVectorEnd, "a");
CalcSpectrum.c:        TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_CalcExcitedStateStart, "a");
CalcSpectrum.c:        GetExcitedState(&(X->Bind), v0, v1Org);
CalcSpectrum.c:        dnorm = NormMPI_dc(X->Bind.Check.idim_max, v0);
CalcSpectrum.c:            TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_CalcExcitedStateEnd, "a");
CalcSpectrum.c:            TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_CalcSpectrumEnd, "a");
CalcSpectrum.c:        for (i = 1; i <= X->Bind.Check.idim_max; i++) {
CalcSpectrum.c:        TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_CalcExcitedStateEnd, "a");
CalcSpectrum.c:    diagonalcalc(&(X->Bind));
CalcSpectrum.c:  TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_CalcSpectrumStart, "a");
CalcSpectrum.c:  switch (X->Bind.Def.iCalcType) {
CalcSpectrum.c:    TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_CalcSpectrumEnd, "a");
CalcSpectrum.c:   if(X->Def.NSingleExcitationOperator > 0 && X->Def.NPairExcitationOperator > 0){
CalcSpectrum.c:    if(X->Def.NSingleExcitationOperator > 0){
CalcSpectrum.c:    else if(X->Def.NPairExcitationOperator >0){
CalcSpectrum.c:  if(X->iFlgSpecOmegaMax == TRUE && X->iFlgSpecOmegaMin == TRUE){
CalcSpectrum.c:    if (X->iCalcType == Lanczos || X->iCalcType == FullDiag) {
CalcSpectrum.c:      sprintf(sdt, cFileNameLanczosStep, X->CDataFileHead);
CalcSpectrum.c:    }/*if (X->iCalcType == Lanczos || X->iCalcType == FullDiag)*/
CalcSpectrum.c:      sprintf(sdt, cFileNameEnergy_Lanczos, X->CDataFileHead);
CalcSpectrum.c:    if(X->iFlgSpecOmegaMax == FALSE){
CalcSpectrum.c:      X->dcOmegaMax= Emax*(double)X->Nsite;
CalcSpectrum.c:    if(X->iFlgSpecOmegaMin == FALSE){
CalcSpectrum.c:      X->dcOmegaMin= E1;
CalcSpectrum.c:    X->Check.idim_maxOrg = X->Check.idim_max;
CalcSpectrum.c:    X->Check.idim_maxMPIOrg = X->Check.idim_maxMPI;
CalcSpectrum.c:    if (X->Def.NSingleExcitationOperator > 0) {
CalcSpectrum.c:        switch (X->Def.iCalcModel) {
CalcSpectrum.c:    } else if (X->Def.NPairExcitationOperator > 0) {
CalcSpectrum.c:        switch (X->Def.iCalcModel) {
CalcSpectrum.c:                if (X->Def.PairExcitationOperator[0][1] != X->Def.PairExcitationOperator[0][3]) {
CalcSpectrum.c:            lui_malloc1(list_1_org, X->Check.idim_max + 1);
CalcSpectrum.c:            lui_malloc1(list_1buf_org, X->Check.idim_maxMPI + 1);
CalcSpectrum.c:            lui_malloc1(list_2_1_org, X->Large.SizeOflist_2_1);
CalcSpectrum.c:            lui_malloc1(list_2_2_org, X->Large.SizeOflist_2_2);
CalcSpectrum.c:            for(j =0; j<X->Large.SizeOflist_2_1; j++){
CalcSpectrum.c:            for(j =0; j<X->Large.SizeOflist_2_2; j++){
CalcSpectrum.c:        if (X->Def.NSingleExcitationOperator > 0) {
CalcSpectrum.c:            switch (X->Def.iCalcModel) {
CalcSpectrum.c:                    if (X->Def.SingleExcitationOperator[0][2] == 1) { //cis
CalcSpectrum.c:                        X->Def.Ne = X->Def.NeMPI + 1;
CalcSpectrum.c:                        X->Def.Ne = X->Def.NeMPI - 1;
CalcSpectrum.c:                    if (X->Def.SingleExcitationOperator[0][2] == 1) { //cis
CalcSpectrum.c:                        X->Def.Ne = X->Def.NeMPI + 1;
CalcSpectrum.c:                        if (X->Def.SingleExcitationOperator[0][1] == 0) {//up
CalcSpectrum.c:                            X->Def.Nup = X->Def.NupOrg + 1;
CalcSpectrum.c:                            X->Def.Ndown=X->Def.NdownOrg;
CalcSpectrum.c:                            X->Def.Nup=X->Def.NupOrg;
CalcSpectrum.c:                            X->Def.Ndown = X->Def.NdownOrg + 1;
CalcSpectrum.c:                        X->Def.Ne = X->Def.NeMPI - 1;
CalcSpectrum.c:                        if (X->Def.SingleExcitationOperator[0][1] == 0) {//up
CalcSpectrum.c:                            X->Def.Nup = X->Def.NupOrg - 1;
CalcSpectrum.c:                            X->Def.Ndown=X->Def.NdownOrg;
CalcSpectrum.c:                            X->Def.Nup=X->Def.NupOrg;
CalcSpectrum.c:                            X->Def.Ndown = X->Def.NdownOrg - 1;
CalcSpectrum.c:        } else if (X->Def.NPairExcitationOperator > 0) {
CalcSpectrum.c:            X->Def.Ne=X->Def.NeMPI;
CalcSpectrum.c:            switch (X->Def.iCalcModel) {
CalcSpectrum.c:                    if (X->Def.PairExcitationOperator[0][1] != X->Def.PairExcitationOperator[0][3]) {
CalcSpectrum.c:                      if (X->Def.PairExcitationOperator[0][1] == 0) {//up
CalcSpectrum.c:                        X->Def.Nup = X->Def.NupOrg + 1;
CalcSpectrum.c:                        X->Def.Ndown = X->Def.NdownOrg - 1;
CalcSpectrum.c:                        X->Def.Nup = X->Def.NupOrg - 1;
CalcSpectrum.c:                        X->Def.Ndown = X->Def.NdownOrg + 1;
CalcSpectrum.c:                if (X->Def.PairExcitationOperator[0][1] != X->Def.PairExcitationOperator[0][3]) {
CalcSpectrum.c:                  if (X->Def.iFlgGeneralSpin == FALSE) {
CalcSpectrum.c:                    if (X->Def.PairExcitationOperator[0][1] == 0) {//down
CalcSpectrum.c:                      X->Def.Nup = X->Def.NupOrg - 1;
CalcSpectrum.c:                      X->Def.Ndown = X->Def.NdownOrg + 1;
CalcSpectrum.c:                      X->Def.Nup = X->Def.NupOrg + 1;
CalcSpectrum.c:                      X->Def.Ndown = X->Def.NdownOrg - 1;
CalcSpectrum.c:                      X->Def.Total2Sz = X->Def.Total2SzMPI+2*(X->Def.PairExcitationOperator[0][1]-X->Def.PairExcitationOperator[0][3]);
CalcSpectrum.c:        X->Def.Nsite=X->Def.NsiteMPI;
CalcSpectrum.c:    if(X->Def.iCalcModel==HubbardNConserved){
CalcSpectrum.c:        X->Def.iCalcModel=Hubbard;
CalcSpectrum.c:    for(j=1; j<=X->Check.idim_maxOrg; j++){
CalcSpectrum.c:        fprintf(stdout, "Debug1: myrank=%d, list_1_org[ %ld] = %ld\n", myrank, j, list_1_org[j]+myrank*X->Def.OrgTpow[2*X->Def.NsiteMPI-1]);
CalcSpectrum.c:    for(j=1; j<=X->Check.idim_max; j++){
CalcSpectrumByBiCG.c:  idim_max2int = (int)X->Bind.Check.idim_max;
CalcSpectrumByBiCG.c:  if (X->Bind.Def.iFlgCalcSpec == RECALC_FROM_TMComponents ||
CalcSpectrumByBiCG.c:      X->Bind.Def.iFlgCalcSpec == RECALC_FROM_TMComponents_VEC ||
CalcSpectrumByBiCG.c:      X->Bind.Def.iFlgCalcSpec == RECALC_INOUT_TMComponents_VEC)  {
CalcSpectrumByBiCG.c:    sprintf(sdt, cFileNameTridiagonalMatrixComponents, X->Bind.Def.CDataFileHead);
CalcSpectrumByBiCG.c:      max_step = (int)X->Bind.Def.Lanczos_max;
CalcSpectrumByBiCG.c:      if (X->Bind.Def.iFlgCalcSpec > RECALC_FROM_TMComponents) {
CalcSpectrumByBiCG.c:        alphaCG = (double complex*)malloc((iter_old + X->Bind.Def.Lanczos_max) * sizeof(double complex));
CalcSpectrumByBiCG.c:        betaCG = (double complex*)malloc((iter_old + X->Bind.Def.Lanczos_max) * sizeof(double complex));
CalcSpectrumByBiCG.c:        res_save = (double complex*)malloc((iter_old + X->Bind.Def.Lanczos_max) * sizeof(double complex));
CalcSpectrumByBiCG.c:      if (X->Bind.Def.iFlgCalcSpec == RECALC_FROM_TMComponents) X->Bind.Def.Lanczos_max = 0;
CalcSpectrumByBiCG.c:      max_step = (int)(iter_old + X->Bind.Def.Lanczos_max);
CalcSpectrumByBiCG.c:  }/*if (X->Bind.Def.iFlgCalcSpec > RECALC_NOT)*/
CalcSpectrumByBiCG.c:    max_step = (int)X->Bind.Def.Lanczos_max;
CalcSpectrumByBiCG.c:  sprintf(sdt, cFileNameTridiagonalMatrixComponents, X->Bind.Def.CDataFileHead);
CalcSpectrumByBiCG.c:  iv = X->Def.initial_iv;
CalcSpectrumByBiCG.c:    for (idim = 1; idim <= X->Check.idim_max; idim++)
CalcSpectrumByBiCG.c:  dnorm = sqrt(creal(VecProdMPI(X->Check.idim_max, v4, v4)));
CalcSpectrumByBiCG.c:  for (idim = 1; idim <= X->Check.idim_max; idim++) v4[idim] /= dnorm;
CalcSpectrumByBiCG.c:  v12 = (double complex*)malloc((X->Bind.Check.idim_max + 1) * sizeof(double complex));
CalcSpectrumByBiCG.c:  v14 = (double complex*)malloc((X->Bind.Check.idim_max + 1) * sizeof(double complex));
CalcSpectrumByBiCG.c:  if (X->Bind.Def.iFlgCalcSpec == RECALC_FROM_TMComponents_VEC ||
CalcSpectrumByBiCG.c:      X->Bind.Def.iFlgCalcSpec == RECALC_INOUT_TMComponents_VEC) {
CalcSpectrumByBiCG.c:    TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_InputSpectrumRecalcvecStart, "a");
CalcSpectrumByBiCG.c:    sprintf(sdt, cFileNameOutputRestartVec, X->Bind.Def.CDataFileHead, myrank);
CalcSpectrumByBiCG.c:      for (idim = 1; idim <= X->Bind.Check.idim_max; idim++) {
CalcSpectrumByBiCG.c:      //InitShadowRes(&(X->Bind), v4);
CalcSpectrumByBiCG.c:      if (i_max != X->Bind.Check.idim_max) {
CalcSpectrumByBiCG.c:        printf("%s %ld %ld %ld\n", sdt, i_max, X->Bind.Check.idim_max, liLanczosStp_vec);
CalcSpectrumByBiCG.c:      byte_size = fread(v2, sizeof(complex double), X->Bind.Check.idim_max + 1, fp);
CalcSpectrumByBiCG.c:      byte_size = fread(v12, sizeof(complex double), X->Bind.Check.idim_max + 1, fp);
CalcSpectrumByBiCG.c:      byte_size = fread(v4, sizeof(complex double), X->Bind.Check.idim_max + 1, fp);
CalcSpectrumByBiCG.c:      byte_size = fread(v14, sizeof(complex double), X->Bind.Check.idim_max + 1, fp);
CalcSpectrumByBiCG.c:      TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_InputSpectrumRecalcvecEnd, "a");
CalcSpectrumByBiCG.c:  }/*if (X->Bind.Def.iFlgCalcSpec > RECALC_FROM_TMComponents)*/
CalcSpectrumByBiCG.c:    for (idim = 1; idim <= X->Bind.Check.idim_max; idim++) {
CalcSpectrumByBiCG.c:    //InitShadowRes(&(X->Bind), v4);
CalcSpectrumByBiCG.c:  TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_GetTridiagonalStart, "a");
CalcSpectrumByBiCG.c:  for (stp = 1; stp <= X->Bind.Def.Lanczos_max; stp++) {
CalcSpectrumByBiCG.c:    for (idim = 1; idim <= X->Bind.Check.idim_max; idim++) {
CalcSpectrumByBiCG.c:    iret = mltply(&X->Bind, v12, v2);
CalcSpectrumByBiCG.c:    iret = mltply(&X->Bind, v14, v4);
CalcSpectrumByBiCG.c:    res_proj = VecProdMPI(X->Bind.Check.idim_max, vrhs, v2);
CalcSpectrumByBiCG.c:  }/*for (stp = 0; stp <= X->Bind.Def.Lanczos_max; stp++)*/
CalcSpectrumByBiCG.c:  TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_GetTridiagonalEnd, "a");
CalcSpectrumByBiCG.c:  if (X->Bind.Def.iFlgCalcSpec != RECALC_FROM_TMComponents)
CalcSpectrumByBiCG.c:  if (X->Bind.Def.iFlgCalcSpec == RECALC_OUTPUT_TMComponents_VEC ||
CalcSpectrumByBiCG.c:      X->Bind.Def.iFlgCalcSpec == RECALC_INOUT_TMComponents_VEC) {
CalcSpectrumByBiCG.c:    TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_OutputSpectrumRecalcvecStart, "a");
CalcSpectrumByBiCG.c:    sprintf(sdt, cFileNameOutputRestartVec, X->Bind.Def.CDataFileHead, myrank);
CalcSpectrumByBiCG.c:    byte_size = fwrite(&X->Bind.Check.idim_max, sizeof(X->Bind.Check.idim_max), 1, fp);
CalcSpectrumByBiCG.c:    byte_size = fwrite(v2, sizeof(complex double), X->Bind.Check.idim_max + 1, fp);
CalcSpectrumByBiCG.c:    byte_size = fwrite(v12, sizeof(complex double), X->Bind.Check.idim_max + 1, fp);
CalcSpectrumByBiCG.c:    byte_size = fwrite(v4, sizeof(complex double), X->Bind.Check.idim_max + 1, fp);
CalcSpectrumByBiCG.c:    byte_size = fwrite(v14, sizeof(complex double), X->Bind.Check.idim_max + 1, fp);
CalcSpectrumByBiCG.c:    TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_OutputSpectrumRecalcvecEnd, "a");
CalcSpectrumByBiCG.c:  }/*if (X->Bind.Def.iFlgCalcSpec > RECALC_FROM_TMComponents)*/
CalcSpectrumByFullDiag.c:  idim_max_int = (int)X->Bind.Check.idim_max;
CalcSpectrumByFullDiag.c:  makeHam(&(X->Bind));
CalcSpectrumByFullDiag.c:  lapack_diag(&(X->Bind));
CalcSpectrumByLanczos.c:    unsigned long int liLanczosStp = X->Bind.Def.Lanczos_max;
CalcSpectrumByLanczos.c:    if(X->Bind.Def.iFlgCalcSpec == RECALC_FROM_TMComponents_VEC ||
CalcSpectrumByLanczos.c:       X->Bind.Def.iFlgCalcSpec == RECALC_INOUT_TMComponents_VEC) {
CalcSpectrumByLanczos.c:        if(ReadInitialVector( &(X->Bind), v0, v1, &liLanczosStp_vec)!=0){
CalcSpectrumByLanczos.c:    if(X->Bind.Def.iFlgCalcSpec == RECALC_FROM_TMComponents ||
CalcSpectrumByLanczos.c:       X->Bind.Def.iFlgCalcSpec ==RECALC_FROM_TMComponents_VEC||
CalcSpectrumByLanczos.c:       X->Bind.Def.iFlgCalcSpec == RECALC_INOUT_TMComponents_VEC)
CalcSpectrumByLanczos.c:        if(X->Bind.Def.iFlgCalcSpec == RECALC_INOUT_TMComponents_VEC ||
CalcSpectrumByLanczos.c:           X->Bind.Def.iFlgCalcSpec ==  RECALC_FROM_TMComponents_VEC)
CalcSpectrumByLanczos.c:        iret=ReadTMComponents(&(X->Bind), &dnorm, &liLanczosStp, iFlgTMComp);
CalcSpectrumByLanczos.c:        if(X->Bind.Def.iFlgCalcSpec == RECALC_FROM_TMComponents){
CalcSpectrumByLanczos.c:            X->Bind.Def.Lanczos_restart=0;
CalcSpectrumByLanczos.c:        else if(X->Bind.Def.iFlgCalcSpec == RECALC_INOUT_TMComponents_VEC||
CalcSpectrumByLanczos.c:                X->Bind.Def.iFlgCalcSpec == RECALC_FROM_TMComponents_VEC){
CalcSpectrumByLanczos.c:            X->Bind.Def.Lanczos_restart=liLanczosStp;
CalcSpectrumByLanczos.c:            liLanczosStp = liLanczosStp+X->Bind.Def.Lanczos_max;
CalcSpectrumByLanczos.c:    if (X->Bind.Def.iFlgCalcSpec == RECALC_NOT ||
CalcSpectrumByLanczos.c:        X->Bind.Def.iFlgCalcSpec == RECALC_OUTPUT_TMComponents_VEC ||
CalcSpectrumByLanczos.c:        X->Bind.Def.iFlgCalcSpec == RECALC_FROM_TMComponents_VEC ||
CalcSpectrumByLanczos.c:        X->Bind.Def.iFlgCalcSpec == RECALC_INOUT_TMComponents_VEC
CalcSpectrumByLanczos.c:        TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_GetTridiagonalStart, "a");
CalcSpectrumByLanczos.c:        iret = Lanczos_GetTridiagonalMatrixComponents(&(X->Bind), alpha, beta, tmp_v1, &(liLanczosStp));
CalcSpectrumByLanczos.c:        TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_GetTridiagonalEnd, "a");
CalcSpectrumByLanczos.c:        OutputTMComponents(&(X->Bind), alpha,beta, dnorm, liLanczosStp);
CalcSpectrumByLanczos.c:    }//X->Bind.Def.iFlgCalcSpec == RECALC_NOT || RECALC_FROM_TMComponents_VEC
CalcSpectrumByLanczos.c:    TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_CalcSpectrumFromTridiagonalStart, "a");
CalcSpectrumByLanczos.c:    TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_CalcSpectrumFromTridiagonalEnd, "a");
CalcSpectrumByLanczos.c:    if(X->Bind.Def.iFlgCalcSpec==RECALC_OUTPUT_TMComponents_VEC ||
CalcSpectrumByLanczos.c:       X->Bind.Def.iFlgCalcSpec==RECALC_INOUT_TMComponents_VEC){
CalcSpectrumByLanczos.c:      if(OutputLanczosVector(&(X->Bind), v0, v1, liLanczosStp)!=0){
CalcSpectrumByTPQ.c:/// \brief Read TPQ data at "X->Bind.Large.itr" step in SS_rand file.
CalcSpectrumByTPQ.c:    sprintf(sdt, cFileNameSSRand, X->Bind.Def.irand);
CalcSpectrumByTPQ.c:        fprintf(stderr, "  Error:  SS_rand%d.dat does not exist.\n", X->Bind.Def.irand);
CalcSpectrumByTPQ.c:        if(istp==X->Bind.Large.itr) break;
CalcSpectrumByTPQ.c:    unsigned long int liLanczosStp = X->Bind.Def.Lanczos_max;
CalcSpectrumByTPQ.c:    if(X->Bind.Def.iFlgCalcSpec == RECALC_FROM_TMComponents_VEC ||
CalcSpectrumByTPQ.c:       X->Bind.Def.iFlgCalcSpec == RECALC_INOUT_TMComponents_VEC) {
CalcSpectrumByTPQ.c:        TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_InputSpectrumRecalcvecStart, "a");
CalcSpectrumByTPQ.c:        sprintf(sdt, cFileNameOutputRestartVec, X->Bind.Def.CDataFileHead, myrank);
CalcSpectrumByTPQ.c:        if(i_max != X->Bind.Check.idim_max){
CalcSpectrumByTPQ.c:        byte_size = fread(v0, sizeof(complex double), X->Bind.Check.idim_max + 1, fp);
CalcSpectrumByTPQ.c:        byte_size = fread(v1, sizeof(complex double), X->Bind.Check.idim_max + 1, fp);
CalcSpectrumByTPQ.c:        TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_InputSpectrumRecalcvecEnd, "a");
CalcSpectrumByTPQ.c:    if(X->Bind.Def.iFlgCalcSpec == RECALC_FROM_TMComponents ||
CalcSpectrumByTPQ.c:       X->Bind.Def.iFlgCalcSpec ==RECALC_FROM_TMComponents_VEC||
CalcSpectrumByTPQ.c:       X->Bind.Def.iFlgCalcSpec == RECALC_INOUT_TMComponents_VEC)
CalcSpectrumByTPQ.c:        if(X->Bind.Def.iFlgCalcSpec == RECALC_INOUT_TMComponents_VEC ||
CalcSpectrumByTPQ.c:           X->Bind.Def.iFlgCalcSpec ==  RECALC_FROM_TMComponents_VEC)
CalcSpectrumByTPQ.c:        iret=ReadTMComponents(&(X->Bind), &dnorm, &liLanczosStp, iFlgTMComp);
CalcSpectrumByTPQ.c:        if(X->Bind.Def.iFlgCalcSpec == RECALC_FROM_TMComponents){
CalcSpectrumByTPQ.c:            X->Bind.Def.Lanczos_restart=0;
CalcSpectrumByTPQ.c:        else if(X->Bind.Def.iFlgCalcSpec == RECALC_INOUT_TMComponents_VEC||
CalcSpectrumByTPQ.c:                X->Bind.Def.iFlgCalcSpec == RECALC_FROM_TMComponents_VEC){
CalcSpectrumByTPQ.c:            X->Bind.Def.Lanczos_restart=liLanczosStp;
CalcSpectrumByTPQ.c:            liLanczosStp = liLanczosStp+X->Bind.Def.Lanczos_max;
CalcSpectrumByTPQ.c:    if (X->Bind.Def.iFlgCalcSpec == RECALC_NOT ||
CalcSpectrumByTPQ.c:        X->Bind.Def.iFlgCalcSpec == RECALC_OUTPUT_TMComponents_VEC ||
CalcSpectrumByTPQ.c:        X->Bind.Def.iFlgCalcSpec == RECALC_FROM_TMComponents_VEC ||
CalcSpectrumByTPQ.c:        X->Bind.Def.iFlgCalcSpec == RECALC_INOUT_TMComponents_VEC
CalcSpectrumByTPQ.c:        TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_GetTridiagonalStart, "a");
CalcSpectrumByTPQ.c:        iret = Lanczos_GetTridiagonalMatrixComponents(&(X->Bind), alpha, beta, tmp_v1, &(liLanczosStp));
CalcSpectrumByTPQ.c:        TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_GetTridiagonalEnd, "a");
CalcSpectrumByTPQ.c:        OutputTMComponents(&(X->Bind), alpha,beta, dnorm, liLanczosStp);
CalcSpectrumByTPQ.c:    }//X->Bind.Def.iFlgCalcSpec == RECALC_NOT || RECALC_FROM_TMComponents_VEC
CalcSpectrumByTPQ.c:    X->Bind.Def.nvec= stp;
CalcSpectrumByTPQ.c:    vec12(alpha,beta,stp,tmp_E, &(X->Bind));
CalcSpectrumByTPQ.c:    TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_CalcSpectrumFromTridiagonalStart, "a");
CalcSpectrumByTPQ.c:        iret = GetCalcSpectrumTPQ(dcomega[i], dtemp, dspecificHeat, dene, tmp_E, X->Bind.Def.Nsite, stp, &dctmp_Spectrum);
CalcSpectrumByTPQ.c:    TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_CalcSpectrumFromTridiagonalEnd, "a");
CalcSpectrumByTPQ.c:    if(X->Bind.Def.iFlgCalcSpec==RECALC_OUTPUT_TMComponents_VEC ||
CalcSpectrumByTPQ.c:       X->Bind.Def.iFlgCalcSpec==RECALC_INOUT_TMComponents_VEC){
CalcSpectrumByTPQ.c:        TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_OutputSpectrumRecalcvecStart, "a");
CalcSpectrumByTPQ.c:        sprintf(sdt, cFileNameOutputRestartVec, X->Bind.Def.CDataFileHead, myrank);
CalcSpectrumByTPQ.c:        fwrite(&X->Bind.Check.idim_max, sizeof(X->Bind.Check.idim_max),1,fp);
CalcSpectrumByTPQ.c:        fwrite(v0, sizeof(complex double),X->Bind.Check.idim_max+1, fp);
CalcSpectrumByTPQ.c:        fwrite(v1, sizeof(complex double),X->Bind.Check.idim_max+1, fp);
CalcSpectrumByTPQ.c:        TimeKeeper(&(X->Bind), cFileNameTimeKeep, c_OutputSpectrumRecalcvecEnd, "a");
CheckMPI.c:  X->Def.NsiteMPI = X->Def.Nsite;
CheckMPI.c:  X->Def.Total2SzMPI = X->Def.Total2Sz;
CheckMPI.c:  switch (X->Def.iCalcModel) {
CheckMPI.c:    for (isite = X->Def.NsiteMPI; isite > 0; isite--) {
CheckMPI.c:        X->Def.Nsite = isite;
CheckMPI.c:	for (isite = X->Def.NsiteMPI; isite > 0; isite--) {
CheckMPI.c:	}/*for (isite = X->Def.NsiteMPI; isite > 0; isite--)*/
CheckMPI.c:    switch (X->Def.iCalcModel) /*2 (inner)*/ {
CheckMPI.c:      for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++) {
CheckMPI.c:          X->Def.Nup -= 1;
CheckMPI.c:          X->Def.Ne -= 1;
CheckMPI.c:          X->Def.Ndown -= 1;
CheckMPI.c:          X->Def.Ne -= 1;
CheckMPI.c:          X->Def.Nup -= 1;
CheckMPI.c:          X->Def.Ndown -= 1;
CheckMPI.c:          X->Def.Ne -= 2;
CheckMPI.c:      } /*for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++)*/
CheckMPI.c:      for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++) {
CheckMPI.c:        if (SpinNum == 1 /*01*/ || SpinNum == 2 /*10*/) X->Def.Ne -= 1;
CheckMPI.c:        else if (SpinNum == 3 /*11*/) X->Def.Ne -= 2;
CheckMPI.c:      } /*for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++)*/
CheckMPI.c:      for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++)
CheckMPI.c:        if (X->Def.LocSpn[isite] != ITINERANT) X->Def.NLocSpn -= 1;
CheckMPI.c:      if (X->Def.iCalcModel == Kondo) {
CheckMPI.c:        for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++) {
CheckMPI.c:          if (X->Def.LocSpn[isite] == ITINERANT) {
CheckMPI.c:              X->Def.Nup -= 1;
CheckMPI.c:              X->Def.Ne -= 1;
CheckMPI.c:              X->Def.Ndown -= 1;
CheckMPI.c:              X->Def.Ne -= 1;
CheckMPI.c:              X->Def.Nup -= 1;
CheckMPI.c:              X->Def.Ndown -= 1;
CheckMPI.c:              X->Def.Ne -= 2;
CheckMPI.c:        }/*for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++)*/
CheckMPI.c:      } /*if (X->Def.iCalcModel == Kondo)*/
CheckMPI.c:    } /*switch (X->Def.iCalcModel) 2(inner)*/
CheckMPI.c:    if (X->Def.iFlgGeneralSpin == FALSE) {
CheckMPI.c:      for (isite = X->Def.NsiteMPI; isite > 0; isite--) {
CheckMPI.c:          X->Def.Nsite = isite;
CheckMPI.c:      }/*for (isite = X->Def.NsiteMPI; isite > 0; isite--)*/
CheckMPI.c:	for (isite = X->Def.NsiteMPI; isite > 0; isite--) {
CheckMPI.c:	}/*for (isite = X->Def.NsiteMPI; isite > 0; isite--)*/
CheckMPI.c:      if (X->Def.iCalcModel == Spin) {
CheckMPI.c:        /*X->Def.NeMPI = X->Def.Ne;*/
CheckMPI.c:        for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++) {
CheckMPI.c:            X->Def.Ndown -= 1;
CheckMPI.c:            X->Def.Ne -= 1;
CheckMPI.c:            X->Def.Nup -= 1;
CheckMPI.c:        }/*for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++)*/
CheckMPI.c:      }/*if (X->Def.iCalcModel == Spin)*/
CheckMPI.c:    } /*if (X->Def.iFlgGeneralSpin == FALSE)*/
CheckMPI.c:      for (isite = X->Def.NsiteMPI; isite > 0; isite--) {
CheckMPI.c:          X->Def.Nsite = isite;
CheckMPI.c:        NDimInterPE *= X->Def.SiteToBit[isite - 1];
CheckMPI.c:      }/*for (isite = X->Def.NsiteMPI; isite > 0; isite--)*/
CheckMPI.c:	for (isite = X->Def.NsiteMPI; isite > 0; isite--) {
CheckMPI.c:	      ismallNproc = NDimInterPE/X->Def.SiteToBit[isite - 2];
CheckMPI.c:	  NDimInterPE *= X->Def.SiteToBit[isite - 1];
CheckMPI.c:	}/*for (isite = X->Def.NsiteMPI; isite > 0; isite--)*/
CheckMPI.c:      if (X->Def.iCalcModel == Spin) {
CheckMPI.c:        X->Def.Total2SzMPI = X->Def.Total2Sz;
CheckMPI.c:        for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++) {
CheckMPI.c:          SpinNum = SmallDim % X->Def.SiteToBit[isite];
CheckMPI.c:          SmallDim /= X->Def.SiteToBit[isite];
CheckMPI.c:          X->Def.Total2Sz += X->Def.SiteToBit[isite] - 1 - 2*SpinNum;
CheckMPI.c:        }/*for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++)*/
CheckMPI.c:      }/*if (X->Def.iCalcModel == Spin)*/
CheckMPI.c:    }/*if (X->Def.iFlgGeneralSpin == TRUE)*/
CheckMPI.c:  }/*switch (X->Def.iCalcModel)*/
CheckMPI.c:  if (X->Boost.flgBoost == 1) {
CheckMPI.c:    isiteMax = X->Boost.W0;
CheckMPI.c:    for (ipivot = 0; ipivot < X->Boost.num_pivot; ipivot++) {
CheckMPI.c:      isiteMax0 = X->Boost.list_6spin_star[ipivot][1]
CheckMPI.c:                + X->Boost.list_6spin_star[ipivot][2]
CheckMPI.c:                + X->Boost.list_6spin_star[ipivot][3]
CheckMPI.c:                + X->Boost.list_6spin_star[ipivot][4]
CheckMPI.c:                + X->Boost.list_6spin_star[ipivot][5];
CheckMPI.c:      if (ishift > 1) isiteMax0 = X->Def.NsiteMPI - isiteMax0 - 1 - ishift;
CheckMPI.c:      else isiteMax0 = X->Def.NsiteMPI - isiteMax0 - 2;
CheckMPI.c:      if (X->Boost.list_6spin_star[ipivot][6] == 1) ishift += X->Boost.ishift_nspin;
CheckMPI.c:    }/*for (ipivot = 0; ipivot < X->Boost.num_pivot; ipivot++)*/
CheckMPI.c:  }/*if (X->Boost.flgBoost == 1)*/
CheckMPI.c:  for (isite = 0; isite < X->Def.Nsite; isite++) {
CheckMPI.c:    switch (X->Def.iCalcModel) {
CheckMPI.c:      if (X->Def.iFlgGeneralSpin == FALSE) {
CheckMPI.c:      }/*if (X->Def.iFlgGeneralSpin == FALSE)*/
CheckMPI.c:        fprintf(stdoutMPI, "    %4d    %4ld\n", isite, X->Def.SiteToBit[isite]);
CheckMPI.c:      }/*if (X->Def.iFlgGeneralSpin == TRUE)*/
CheckMPI.c:    } /*switch (X->Def.iCalcModel)*/
CheckMPI.c:  } /*for (isite = 0; isite < X->Def.Nsite; isite++)*/
CheckMPI.c:  for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++) {
CheckMPI.c:    switch (X->Def.iCalcModel) {
CheckMPI.c:      if (X->Def.iFlgGeneralSpin == FALSE) {
CheckMPI.c:      }/*if (X->Def.iFlgGeneralSpin == FALSE) */
CheckMPI.c:        fprintf(stdoutMPI, "    %4d    %4ld\n", isite, X->Def.SiteToBit[isite]);
CheckMPI.c:      }/*if (X->Def.iFlgGeneralSpin == TRUE) */
CheckMPI.c:    }/*switch (X->Def.iCalcModel)*/
CheckMPI.c:  }/*for (isite = X->Def.Nsite; isite < NsiteMPI; isite++)*/
CheckMPI.c:    if (myrank == iproc) idimMPI = X->Check.idim_max;
CheckMPI.c:    if (myrank == iproc) Nelec = X->Def.Nup;
CheckMPI.c:    if (myrank == iproc) Nelec = X->Def.Ndown;
CheckMPI.c:    if (myrank == iproc) Nelec = X->Def.Ne;
CheckMPI.c:    if (myrank == iproc) Nelec = X->Def.Total2Sz;
CheckMPI.c:    switch (X->Def.iCalcModel) {
CheckMPI.c:      for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++) {
CheckMPI.c:      } /*for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++)*/
CheckMPI.c:      if (X->Def.iFlgGeneralSpin == FALSE) {
CheckMPI.c:        for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++) {
CheckMPI.c:        }/*for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++)*/
CheckMPI.c:      }/*if (X->Def.iFlgGeneralSpin == FALSE)*/
CheckMPI.c:        for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++) {
CheckMPI.c:          SpinNum = SmallDim % (int)X->Def.SiteToBit[isite];
CheckMPI.c:          SmallDim /= X->Def.SiteToBit[isite];
CheckMPI.c:        }/*for (isite = X->Def.Nsite; isite < X->Def.NsiteMPI; isite++)*/
CheckMPI.c:      }/*if (X->Def.iFlgGeneralSpin == TRUE)*/
CheckMPI.c:    }/*switch (X->Def.iCalcModel)*/
CheckMPI.c:  X->Check.idim_maxMPI = SumMPI_li(X->Check.idim_max);
CheckMPI.c:  fprintf(stdoutMPI, "\n   Total dimension : %ld\n\n",  X->Check.idim_maxMPI);
CheckMPI.c:  switch (X->Def.iCalcModel) {
CheckMPI.c:    X->Def.Tpow[2 * X->Def.Nsite] = 1;
CheckMPI.c:    for (isite = 2 * X->Def.Nsite + 1; isite < 2 * X->Def.NsiteMPI; isite++)
CheckMPI.c:      X->Def.Tpow[isite] = X->Def.Tpow[isite - 1] * 2;
CheckMPI.c:    X->Def.OrgTpow[0]=1;
CheckMPI.c:    for (isite = 1; isite < 2 * X->Def.NsiteMPI; isite++)
CheckMPI.c:      X->Def.OrgTpow[isite] = X->Def.OrgTpow[isite-1]*2;
CheckMPI.c:    if (X->Def.iFlgGeneralSpin == FALSE) {
CheckMPI.c:      X->Def.Tpow[X->Def.Nsite] = 1;
CheckMPI.c:      for (isite = X->Def.Nsite + 1; isite < X->Def.NsiteMPI; isite++)
CheckMPI.c:        X->Def.Tpow[isite] = X->Def.Tpow[isite - 1] * 2;
CheckMPI.c:    }/*if (X->Def.iFlgGeneralSpin == FALSE)*/
CheckMPI.c:      X->Def.Tpow[X->Def.Nsite] = 1;
CheckMPI.c:      for (isite = X->Def.Nsite + 1; isite < X->Def.NsiteMPI; isite++)
CheckMPI.c:        X->Def.Tpow[isite] = X->Def.Tpow[isite - 1] * X->Def.SiteToBit[isite - 1];
CheckMPI.c:    }/*if (X->Def.iFlgGeneralSpin == TRUE)*/
CheckMPI.c:  } /*switch (X->Def.iCalcModel)*/
FirstMultiply.c:  Ns = 1.0*X->Def.NsiteMPI;
FirstMultiply.c:  i_max = X->Check.idim_max;
FirstMultiply.c:    u_long_i = 123432 + (rand_i + 1)*labs(X->Def.initial_iv) + mythread + nthreads * myrank;
FirstMultiply.c:    if (X->Def.iInitialVecType == 0) {
FirstMultiply.c:    }/*if (X->Def.iInitialVecType == 0)*/
HPhiTrans.c:  for (i = 0; i < X->Def.EDNTransfer; i++) {
HPhiTrans.c:      if (X->Def.EDGeneralTransfer[i][1] == X->Def.EDGeneralTransfer[k][1]
HPhiTrans.c:          && X->Def.EDGeneralTransfer[i][3] == X->Def.EDGeneralTransfer[k][3]) {
HPhiTrans.c:        if (X->Def.EDGeneralTransfer[i][0] == X->Def.EDGeneralTransfer[k][0]
HPhiTrans.c:            && X->Def.EDGeneralTransfer[i][2] == X->Def.EDGeneralTransfer[k][2]) {
HPhiTrans.c:          fprintf(fp_err, cErrDoubleCounting, X->Def.EDGeneralTransfer[k][0], X->Def.EDGeneralTransfer[k][2],
HPhiTrans.c:                  X->Def.EDGeneralTransfer[k][1], X->Def.EDGeneralTransfer[k][3]);
HPhiTrans.c:  const int Mode = (int) (X->Def.ParaLaser[0]);
HPhiTrans.c:  const double Avp = X->Def.ParaLaser[1];
HPhiTrans.c:  const double omega = X->Def.ParaLaser[2];
HPhiTrans.c:  const double time_d = X->Def.ParaLaser[3];
HPhiTrans.c:  const double time_c = X->Def.ParaLaser[4];
HPhiTrans.c:  const int Lx = (int) (X->Def.ParaLaser[5]);
HPhiTrans.c:  const int Ly = (int) (X->Def.ParaLaser[6]);
HPhiTrans.c:  const double dirX = X->Def.ParaLaser[7];
HPhiTrans.c:  const double dirY = X->Def.ParaLaser[8];
HPhiTrans.c:  for (i = 0; i < X->Def.EDNTransfer; i++) {
HPhiTrans.c:    ri_x = X->Def.EDGeneralTransfer[i][0] % Lx;
HPhiTrans.c:    rj_x = X->Def.EDGeneralTransfer[i][2] % Lx;
HPhiTrans.c:    ri_y = X->Def.EDGeneralTransfer[i][0] / Lx;
HPhiTrans.c:    rj_y = X->Def.EDGeneralTransfer[i][2] / Lx;
HPhiTrans.c:    X->Def.EDParaGeneralTransfer[i] = X->Def.ParaGeneralTransfer[i] * cexp(-I * VecPot * dir);
HPhiTrans.c:  const int Mode = (int) (X->Def.ParaLaser[0]);
HPhiTrans.c:  const double Avp = X->Def.ParaLaser[1];
HPhiTrans.c:  const double omega = X->Def.ParaLaser[2];
HPhiTrans.c:  const double time_d = X->Def.ParaLaser[3];
HPhiTrans.c:  const double time_c = X->Def.ParaLaser[4];
HPhiTrans.c:  const int Lx = (int) (X->Def.ParaLaser[5]);
HPhiTrans.c:  const int Ly = (int) (X->Def.ParaLaser[6]);
HPhiTrans.c:  const double dirX = X->Def.ParaLaser[7];
HPhiTrans.c:  const double dirY = X->Def.ParaLaser[8];
HPhiTrans.c:  for (i = 0; i < X->Def.EDNTransfer; i++) {
HPhiTrans.c:    ri_x = X->Def.EDGeneralTransfer[i][0] % Lx;
HPhiTrans.c:    rj_x = X->Def.EDGeneralTransfer[i][2] % Lx;
HPhiTrans.c:    ri_y = X->Def.EDGeneralTransfer[i][0] / Lx;
HPhiTrans.c:    rj_y = X->Def.EDGeneralTransfer[i][2] / Lx;
HPhiTrans.c:    X->Def.EDParaGeneralTransfer[i] = X->Def.ParaGeneralTransfer[i] * Bessel;
Lanczos_EigenValue.c:  sprintf(sdt_2, cFileNameLanczosStep, X->Def.CDataFileHead);
Lanczos_EigenValue.c:  i_max = X->Check.idim_max;
Lanczos_EigenValue.c:  k_exct = X->Def.k_exct;
Lanczos_EigenValue.c:  unsigned long int liLanczosStp = X->Def.Lanczos_max;
Lanczos_EigenValue.c:    if (X->Def.iReStart == RESTART_INOUT || X->Def.iReStart == RESTART_IN){
Lanczos_EigenValue.c:      X->Def.Lanczos_restart=liLanczosStp;
Lanczos_EigenValue.c:      liLanczosStp = liLanczosStp+X->Def.Lanczos_max;
Lanczos_EigenValue.c:      alpha1=alpha[X->Def.Lanczos_restart];
Lanczos_EigenValue.c:      beta1=beta[X->Def.Lanczos_restart];
Lanczos_EigenValue.c:    }/*X->Def.iReStart == RESTART_INOUT || X->Def.iReStart == RESTART_IN*/
Lanczos_EigenValue.c:      alpha1 = creal(X->Large.prdct);// alpha = v^{\dag}*H*v
Lanczos_EigenValue.c:      liLanczosStp = X->Def.Lanczos_max;
Lanczos_EigenValue.c:      X->Def.Lanczos_restart =1;
Lanczos_EigenValue.c:  if (i_max_tmp < X->Def.LanczosTarget) {
Lanczos_EigenValue.c:    X->Large.itr = stp;
Lanczos_EigenValue.c:    X->Phys.Target_energy = E[k_exct];
Lanczos_EigenValue.c:  fprintf(stdoutMPI, "  LanczosStep  E[1] E[2] E[3] E[4] Target:E[%d] E_Max/Nsite\n", X->Def.LanczosTarget + 1);
Lanczos_EigenValue.c:  for (stp = X->Def.Lanczos_restart+1; stp <= liLanczosStp; stp++) {
Lanczos_EigenValue.c:    alpha1 = creal(X->Large.prdct);
Lanczos_EigenValue.c:    Target = X->Def.LanczosTarget;
Lanczos_EigenValue.c:                E_target, E[0] / (double) X->Def.NsiteMPI);
Lanczos_EigenValue.c:                E[0] / (double) X->Def.NsiteMPI);
Lanczos_EigenValue.c:                E[0] / (double) X->Def.NsiteMPI);
Lanczos_EigenValue.c:                E[0] / (double) X->Def.NsiteMPI);
Lanczos_EigenValue.c:          if(X->Def.iReStart == RESTART_INOUT ||X->Def.iReStart == RESTART_OUT){
Lanczos_EigenValue.c:          X->Large.itr = stp;
Lanczos_EigenValue.c:          X->Phys.Target_energy = E_target;
Lanczos_EigenValue.c:          X->Phys.Target_CG_energy = E[k_exct]; //for CG
Lanczos_EigenValue.c:  if (X->Def.iReStart == RESTART_INOUT ||X->Def.iReStart == RESTART_OUT ){
Lanczos_EigenValue.c:    if(stp != X->Def.Lanczos_restart+2) { // 2 steps are needed to get the value: E[stp+2]-E[stp+1]
Lanczos_EigenValue.c:  sprintf(sdt, cFileNameTimeKeep, X->Def.CDataFileHead);
Lanczos_EigenValue.c:  i_max = X->Check.idim_max;
Lanczos_EigenValue.c:  sprintf(sdt, cFileNameLanczosStep, X->Def.CDataFileHead);
Lanczos_EigenValue.c:  if (i_max_tmp < *liLanczos_step || i_max_tmp < X->Def.LanczosTarget) {
Lanczos_EigenValue.c:  if (X->Def.Lanczos_restart == 0) { // initial procedure (not restart)
Lanczos_EigenValue.c:    alpha1 = creal(X->Large.prdct);// alpha = v^{\dag}*H*v
Lanczos_EigenValue.c:    X->Def.Lanczos_restart = 1;
Lanczos_EigenValue.c:    alpha1 = alpha[X->Def.Lanczos_restart];
Lanczos_EigenValue.c:    beta1 = beta[X->Def.Lanczos_restart];
Lanczos_EigenValue.c:  for (stp = X->Def.Lanczos_restart + 1; stp <= *liLanczos_step; stp++) {
Lanczos_EigenValue.c:    alpha1 = creal(X->Large.prdct);
Lanczos_EigenValue.c:  sprintf(sdt, cFileNameOutputRestartVec, X->Def.CDataFileHead, myrank);
Lanczos_EigenValue.c:  if(i_max != X->Check.idim_max){
Lanczos_EigenValue.c:  byte_size = fread(_v0, sizeof(complex double), X->Check.idim_max + 1, fp);
Lanczos_EigenValue.c:  byte_size = fread(_v1, sizeof(complex double), X->Check.idim_max + 1, fp);
Lanczos_EigenValue.c:  sprintf(sdt, cFileNameOutputRestartVec, X->Def.CDataFileHead, myrank);
Lanczos_EigenValue.c:  fwrite(&X->Check.idim_max, sizeof(X->Check.idim_max),1,fp);
Lanczos_EigenValue.c:  fwrite(tmp_v0, sizeof(complex double),X->Check.idim_max+1, fp);
Lanczos_EigenValue.c:  fwrite(tmp_v1, sizeof(complex double),X->Check.idim_max+1, fp);
Lanczos_EigenValue.c:  i_max = X->Check.idim_max;
Lanczos_EigenValue.c:    if(X->Def.iFlgMPI==0) {
Lanczos_EigenValue.c:      sum_i_max = SumMPI_li(X->Check.idim_max);
Lanczos_EigenValue.c:      sum_i_max =X->Check.idim_max;
Lanczos_EigenValue.c:    X->Large.iv = (sum_i_max / 2 + X->Def.initial_iv) % sum_i_max + 1;
Lanczos_EigenValue.c:    iv = X->Large.iv;
Lanczos_EigenValue.c:            X->Def.k_exct);
Lanczos_EigenValue.c:    if(X->Def.iFlgMPI==0) {
Lanczos_EigenValue.c:            if (X->Def.iInitialVecType == 0) {
Lanczos_EigenValue.c:      if (X->Def.iInitialVecType == 0) {
Lanczos_EigenValue.c:    iv = X->Def.initial_iv;
Lanczos_EigenValue.c:            X->Def.k_exct);
Lanczos_EigenValue.c:      if(X->Def.iFlgMPI==0) {
Lanczos_EigenValue.c:      if (X->Def.iInitialVecType == 0) {
Lanczos_EigenValue.c:    if(X->Def.iFlgMPI==0) {
Lanczos_EigenValue.c:  sprintf(sdt, cFileNameTridiagonalMatrixComponents, X->Def.CDataFileHead);
Lanczos_EigenValue.c:    alpha = (double *) realloc(alpha, sizeof(double) * (i_max + X->Def.Lanczos_max + 1));
Lanczos_EigenValue.c:    beta = (double *) realloc(beta, sizeof(double) * (i_max + X->Def.Lanczos_max + 1));
Lanczos_EigenValue.c:  sprintf(sdt, cFileNameTridiagonalMatrixComponents, X->Def.CDataFileHead);
Lanczos_EigenVector.c:    k_exct = X->Def.k_exct;
Lanczos_EigenVector.c:  //k_exct = X->Def.LanczosTarget+1;
Lanczos_EigenVector.c:  iv=X->Large.iv;
Lanczos_EigenVector.c:  i_max=X->Check.idim_max;
Lanczos_EigenVector.c:    sum_i_max = SumMPI_li(X->Check.idim_max);
Lanczos_EigenVector.c:    X->Large.iv = (sum_i_max / 2 + X->Def.initial_iv) % sum_i_max + 1;
Lanczos_EigenVector.c:    iv=X->Large.iv;
Lanczos_EigenVector.c:          if (X->Def.iInitialVecType == 0) {
Lanczos_EigenVector.c:    iv = X->Def.initial_iv;
Lanczos_EigenVector.c:      if (X->Def.iInitialVecType == 0) {
Lanczos_EigenVector.c:  for(i=2;i<=X->Large.itr-1;i++) {
Multiply.c:  i_max=X->Check.idim_max;      
Multiply.c:  Ns = 1.0*X->Def.NsiteMPI;
Multiply.c:  double dt=X->Def.Param.TimeSlice;
Multiply.c:  i_max=X->Check.idim_max;
Multiply.c:    for (coef = 2; coef <= X->Def.Param.ExpandCoef; coef++) {
PairEx.c:  //  i_max = X->Check.idim_max;
PairEx.c:    if(X->Def.iFlgGeneralSpin == FALSE) {
PairEx.c:        if (GetSplitBitByModel(X->Def.Nsite, X->Def.iCalcModel, &irght, &ilft, &ihfbit) != 0) {
PairEx.c:        if (GetSplitBitForGeneralSpin(X->Def.Nsite, &ihfbit, X->Def.SiteToBit) != 0) {
PairEx.c:  X->Large.i_max    =  X->Check.idim_maxOrg;
PairEx.c:  X->Large.irght    = irght;
PairEx.c:  X->Large.ilft     = ilft;
PairEx.c:  X->Large.ihfbit   = ihfbit;
PairEx.c:  X->Large.mode=M_CALCSPEC;
PairEx.c:    switch(X->Def.iCalcModel){
PairExHubbard.c:    i_max = X->Check.idim_maxOrg;
PairExHubbard.c:    for(i=0;i<X->Def.NPairExcitationOperator;i++) {
PairExHubbard.c:        org_isite1 = X->Def.PairExcitationOperator[i][0] + 1;
PairExHubbard.c:        org_isite2 = X->Def.PairExcitationOperator[i][2] + 1;
PairExHubbard.c:        org_sigma1 = X->Def.PairExcitationOperator[i][1];
PairExHubbard.c:        org_sigma2 = X->Def.PairExcitationOperator[i][3];
PairExHubbard.c:        tmp_trans = X->Def.ParaPairExcitationOperator[i];
PairExHubbard.c:        if (org_isite1 > X->Def.Nsite &&
PairExHubbard.c:            org_isite2 > X->Def.Nsite) {
PairExHubbard.c:                if (X->Def.PairExcitationOperator[i][4] == 0) {
PairExHubbard.c:                        is = X->Def.Tpow[2 * org_isite1 - 2];
PairExHubbard.c:                        is = X->Def.Tpow[2 * org_isite1 - 1];
PairExHubbard.c:                else {//X->Def.PairExcitationOperator[i][4]==1
PairExHubbard.c:                        is = X->Def.Tpow[2 * org_isite1 - 2];
PairExHubbard.c:                        is = X->Def.Tpow[2 * org_isite1 - 1];
PairExHubbard.c:        else if (org_isite2 > X->Def.Nsite || org_isite1 > X->Def.Nsite) {
PairExHubbard.c:            if (org_isite1 == org_isite2 && org_sigma1 == org_sigma2 && X->Def.PairExcitationOperator[i][4] == 1) {
PairExHubbard.c:                isite1=X->Def.Tpow[2 * org_isite1 - 2 + org_sigma1];
PairExHubbard.c:    //  i_max = X->Check.idim_max;
PairExHubbard.c:    i_max = X->Check.idim_maxOrg;
PairExHubbard.c:    if(GetSplitBitByModel(X->Def.Nsite, X->Def.iCalcModel, &irght, &ilft, &ihfbit)!=0){
PairExHubbard.c:    X->Large.i_max    = i_max;
PairExHubbard.c:    X->Large.irght    = irght;
PairExHubbard.c:    X->Large.ilft     = ilft;
PairExHubbard.c:    X->Large.ihfbit   = ihfbit;
PairExHubbard.c:    X->Large.mode=M_CALCSPEC;
PairExHubbard.c://    X->Large.mode     = M_MLTPLY;
PairExHubbard.c:    idim_maxMPI = MaxMPI_li(X->Check.idim_maxOrg);
PairExHubbard.c:    for(i=0;i<X->Def.NPairExcitationOperator;i++){
PairExHubbard.c:        org_isite1 = X->Def.PairExcitationOperator[i][0]+1;
PairExHubbard.c:        org_isite2 = X->Def.PairExcitationOperator[i][2]+1;
PairExHubbard.c:        org_sigma1 = X->Def.PairExcitationOperator[i][1];
PairExHubbard.c:        org_sigma2 = X->Def.PairExcitationOperator[i][3];
PairExHubbard.c:        tmp_trans = X->Def.ParaPairExcitationOperator[i];
PairExHubbard.c:        ibitsite1 = X->Def.OrgTpow[2*org_isite1-2+org_sigma1] ;
PairExHubbard.c:        ibitsite2 = X->Def.OrgTpow[2*org_isite2-2+org_sigma2] ;
PairExHubbard.c:        Asum = X->Large.isA_spin;
PairExHubbard.c:        Adiff = X->Large.A_spin;
PairExHubbard.c:        if(X->Def.iFlagListModified == TRUE // Not to adopt HubbrdNConserved
PairExHubbard.c:            if (org_isite1  > X->Def.Nsite &&
PairExHubbard.c:                org_isite2  > X->Def.Nsite)
PairExHubbard.c:            else if (org_isite2  > X->Def.Nsite
PairExHubbard.c:                     || org_isite1  > X->Def.Nsite)
PairExHubbard.c:            if (org_isite1  > X->Def.Nsite &&
PairExHubbard.c:                org_isite2  > X->Def.Nsite) {
PairExHubbard.c:                    is = X->Def.Tpow[2 * org_isite1 - 2 + org_sigma1];
PairExHubbard.c:                    if( X->Def.PairExcitationOperator[i][4]==0) {
PairExHubbard.c:            else if (org_isite2  > X->Def.Nsite || org_isite1  > X->Def.Nsite){
PairExHubbard.c:                    is = X->Def.Tpow[2 * org_isite1 - 2 + org_sigma1];
PairExHubbard.c:                    if( X->Def.PairExcitationOperator[i][4]==0) {
PairExSpin.c:    if (X->Def.iFlgGeneralSpin == FALSE) {
PairExSpin.c:    i_max = X->Check.idim_maxOrg;
PairExSpin.c:    for(i=0;i<X->Def.NPairExcitationOperator;i++){
PairExSpin.c:        org_isite1 = X->Def.PairExcitationOperator[i][0]+1;
PairExSpin.c:        org_isite2 = X->Def.PairExcitationOperator[i][2]+1;
PairExSpin.c:        org_sigma1 = X->Def.PairExcitationOperator[i][1];
PairExSpin.c:        org_sigma2 = X->Def.PairExcitationOperator[i][3];
PairExSpin.c:        tmp_trans = X->Def.ParaPairExcitationOperator[i];
PairExSpin.c:            if(org_isite1 > X->Def.Nsite){
PairExSpin.c:                    if(X->Def.PairExcitationOperator[i][4]==0) {
PairExSpin.c:                isite1 = X->Def.Tpow[org_isite1-1];
PairExSpin.c:                    if (X->Def.PairExcitationOperator[i][4] == 1) {
PairExSpin.c:    i_max = X->Check.idim_maxOrg;
PairExSpin.c:    for(i=0;i<X->Def.NPairExcitationOperator;i++){
PairExSpin.c:        org_isite1 = X->Def.PairExcitationOperator[i][0]+1;
PairExSpin.c:        org_isite2 = X->Def.PairExcitationOperator[i][2]+1;
PairExSpin.c:        org_sigma1 = X->Def.PairExcitationOperator[i][1];
PairExSpin.c:        org_sigma2 = X->Def.PairExcitationOperator[i][3];
PairExSpin.c:        tmp_trans = X->Def.ParaPairExcitationOperator[i];
PairExSpin.c:            if(org_isite1 > X->Def.Nsite){
PairExSpin.c:                    if(X->Def.PairExcitationOperator[i][4]==0) {
PairExSpin.c:            else{//org_isite1 <= X->Def.Nsite
PairExSpin.c:                    if(X->Def.PairExcitationOperator[i][4]==0) {
PairExSpin.c:                            num1 = BitCheckGeneral(j - 1, org_isite1, org_sigma1, X->Def.SiteToBit, X->Def.Tpow);
PairExSpin.c:                            num1 = BitCheckGeneral(j - 1, org_isite1, org_sigma1, X->Def.SiteToBit, X->Def.Tpow);
PairExSpin.c:                        num1 = GetOffCompGeneralSpin(j-1, org_isite1, org_sigma2, org_sigma1, &tmp_off, X->Def.SiteToBit, X->Def.Tpow);
PairExSpin.c:    if (X->Def.iFlgGeneralSpin == FALSE) {
PairExSpin.c:    i_max = X->Check.idim_maxOrg;
PairExSpin.c:    idim_maxMPI = MaxMPI_li(X->Check.idim_maxOrg);
PairExSpin.c:    for (i = 0; i < X->Def.NPairExcitationOperator; i++) {
PairExSpin.c:        org_isite1 = X->Def.PairExcitationOperator[i][0] + 1;
PairExSpin.c:        org_isite2 = X->Def.PairExcitationOperator[i][2] + 1;
PairExSpin.c:        org_sigma1 = X->Def.PairExcitationOperator[i][1];
PairExSpin.c:        org_sigma2 = X->Def.PairExcitationOperator[i][3];
PairExSpin.c:        tmp_trans = X->Def.ParaPairExcitationOperator[i];
PairExSpin.c:                if (org_isite1 > X->Def.Nsite) {
PairExSpin.c:                    is1_up = X->Def.Tpow[org_isite1 - 1];
PairExSpin.c:                    if (X->Def.PairExcitationOperator[i][4] == 0) {
PairExSpin.c:                }// org_isite1 > X->Def.Nsite
PairExSpin.c:                    isite1 = X->Def.Tpow[org_isite1 - 1];
PairExSpin.c:                        X->Def.PairExcitationOperator[i][4] == 1) {
PairExSpin.c:            if (org_isite1 > X->Def.Nsite) {//For MPI
PairExSpin.c:                X_child_CisAit_spin_MPIdouble(org_isite1-1, org_sigma2, tmp_trans, X, tmp_v0, tmp_v1, tmp_v1bufOrg, i_max, X->Def.Tpow,list_1_org, list_1buf_org, list_2_1, list_2_2, X->Large.irght, X->Large.ilft,X->Large.ihfbit);
PairExSpin.c:                isite1 = X->Def.Tpow[org_isite1 - 1];
PairExSpin.c:    i_max = X->Check.idim_maxOrg;
PairExSpin.c:    idim_maxMPI = MaxMPI_li(X->Check.idim_maxOrg);
PairExSpin.c:    for(i=0;i<X->Def.NPairExcitationOperator;i++){
PairExSpin.c:        org_isite1 = X->Def.PairExcitationOperator[i][0]+1;
PairExSpin.c:        org_isite2 = X->Def.PairExcitationOperator[i][2]+1;
PairExSpin.c:        org_sigma1 = X->Def.PairExcitationOperator[i][1];
PairExSpin.c:        org_sigma2 = X->Def.PairExcitationOperator[i][3];
PairExSpin.c:        tmp_trans = X->Def.ParaPairExcitationOperator[i];
PairExSpin.c:            if(org_isite1 >X->Def.Nsite){
PairExSpin.c:                                           org_isite1, org_sigma1, X->Def.SiteToBit, X->Def.Tpow);
PairExSpin.c:                    if(X->Def.PairExcitationOperator[i][4]==0) {
PairExSpin.c:                    X_child_CisAit_GeneralSpin_MPIdouble(org_isite1-1, org_sigma1, org_sigma2, tmp_trans, X, tmp_v0, tmp_v1, tmp_v1bufOrg, i_max, list_1_org, list_1buf_org, X->Large.ihfbit);
PairExSpin.c:            else {//org_isite1 <= X->Def.Nsite
PairExSpin.c:                    if (X->Def.PairExcitationOperator[i][4] == 0) {
PairExSpin.c:                            num1 = BitCheckGeneral(list_1[j], org_isite1, org_sigma1, X->Def.SiteToBit, X->Def.Tpow);
PairExSpin.c:                            num1 = BitCheckGeneral(list_1[j], org_isite1, org_sigma1, X->Def.SiteToBit, X->Def.Tpow);
PairExSpin.c:                        tmp_sgn = GetOffCompGeneralSpin(list_1_org[j], org_isite1, org_sigma2, org_sigma1, &off, X->Def.SiteToBit, X->Def.Tpow);
PairExSpin.c:                            ConvertToList1GeneralSpin(off, X->Large.ihfbit, &tmp_off);
PairExSpin.c:                            printf("rank=%d, org=%ld, tmp_off=%ld, list_1=%ld, ihfbit=%ld\n",myrank, list_1_org[j], off, list_1[tmp_off], X->Large.ihfbit);
PowerLanczos.c:  i_max=X->Check.idim_max;    
PowerLanczos.c:    //E1    = X->Phys.energy;// E^1
PowerLanczos.c:    //E2a   = X->Phys.var ;// E^2 = <v1|H*H|v1>
PowerLanczos.c:  X->Phys.energy = tmp_ene;
PowerLanczos.c:  X->Phys.var    = tmp_var;
SingleEx.c:  if (X->Def.NSingleExcitationOperator == 0) return TRUE;
SingleEx.c:  switch (X->Def.iCalcModel) {
SingleEx.c:  }/*switch (X->Def.iCalcModel)*/
SingleExHubbard.c:  if (X->Def.NSingleExcitationOperator == 0) {
SingleExHubbard.c:  idim_maxMPI = MaxMPI_li(X->Check.idim_maxOrg);
SingleExHubbard.c:  idim_max = X->Check.idim_maxOrg;
SingleExHubbard.c:  for (i = 0; i < X->Def.NSingleExcitationOperator; i++) {
SingleExHubbard.c:    org_isite = X->Def.SingleExcitationOperator[i][0];
SingleExHubbard.c:    ispin = X->Def.SingleExcitationOperator[i][1];
SingleExHubbard.c:    itype = X->Def.SingleExcitationOperator[i][2];
SingleExHubbard.c:    tmpphi = X->Def.ParaSingleExcitationOperator[i];
SingleExHubbard.c:    is1_spin = X->Def.Tpow[2 * org_isite + ispin];
SingleExHubbard.c:      if (org_isite >= X->Def.Nsite) {
SingleExHubbard.c:          X->Def.Tpow, list_1_org, list_1buf_org, list_2_1, list_2_2, \
SingleExHubbard.c:          X->Large.irght, X->Large.ilft, X->Large.ihfbit);
SingleExHubbard.c:          isgn = X_Cis(j, is1_spin, &tmp_off, list_1_org, list_2_1, list_2_2, X->Large.irght, X->Large.ilft, X->Large.ihfbit);
SingleExHubbard.c:      if (org_isite >= X->Def.Nsite) {
SingleExHubbard.c:          idim_max, X->Def.Tpow, list_1_org, list_1buf_org, \
SingleExHubbard.c:          list_2_1, list_2_2, X->Large.irght, X->Large.ilft, X->Large.ihfbit);
SingleExHubbard.c:          isgn = X_Ajt(j, is1_spin, &tmp_off, list_1_org, list_2_1, list_2_2, X->Large.irght, X->Large.ilft, X->Large.ihfbit);
SingleExHubbard.c:  //idim_max = X->Check.idim_max;
SingleExHubbard.c:  idim_max = X->Check.idim_maxOrg;
SingleExHubbard.c:  if (X->Def.NSingleExcitationOperator == 0) {
SingleExHubbard.c:  idim_maxMPI = MaxMPI_li(X->Check.idim_maxOrg);
SingleExHubbard.c:  for (i = 0; i < X->Def.NSingleExcitationOperator; i++) {
SingleExHubbard.c:    org_isite = X->Def.SingleExcitationOperator[i][0];
SingleExHubbard.c:    ispin = X->Def.SingleExcitationOperator[i][1];
SingleExHubbard.c:    itype = X->Def.SingleExcitationOperator[i][2];
SingleExHubbard.c:    tmpphi = X->Def.ParaSingleExcitationOperator[i];
SingleExHubbard.c:      if (org_isite >= X->Def.Nsite) {
SingleExHubbard.c:        X_GC_Cis_MPI(org_isite, ispin, tmpphi, tmp_v0, tmp_v1, idim_max, tmp_v1bufOrg, X->Def.Tpow);
SingleExHubbard.c:          is1_spin = X->Def.Tpow[2 * org_isite + ispin];
SingleExHubbard.c:      if (org_isite >= X->Def.Nsite) {
SingleExHubbard.c:        X_GC_Ajt_MPI(org_isite, ispin, tmpphi, tmp_v0, tmp_v1, idim_max, tmp_v1bufOrg, X->Def.Tpow);
SingleExHubbard.c:          is1_spin = X->Def.Tpow[2 * org_isite + ispin];
check.c:  if(X->Def.iCalcModel ==Spin ||X->Def.iCalcModel ==SpinGC )
check.c:    X->Def.Ne=X->Def.Nup;
check.c:    int iAllup=X->Def.Ne;
check.c:  Ns = X->Def.Nsite;
check.c:  switch(X->Def.iCalcModel){
check.c:    for(i=0;i<2*X->Def.Nsite;i++){
check.c:    if(X->Def.iFlgGeneralSpin ==FALSE){
check.c:      for(i=0;i<X->Def.Nsite;i++){
check.c:      for(i=0; i<X->Def.Nsite;i++){
check.c:	comb_sum=comb_sum*X->Def.SiteToBit[i];
check.c:    comb_up= Binomial(Ns, X->Def.Nup, comb, Ns);
check.c:    comb_down= Binomial(Ns, X->Def.Ndown, comb, Ns);
check.c:    if(X->Def.Ne > X->Def.Nsite){
check.c:      iMinup = X->Def.Ne-X->Def.Nsite;
check.c:      iAllup = X->Def.Nsite;
check.c:      comb_down= Binomial(Ns, X->Def.Ne-i, comb, Ns);
check.c:    Nup     = X->Def.Nup;
check.c:    Ndown   = X->Def.Ndown;
check.c:    NCond   = X->Def.Nsite-X->Def.NLocSpn;
check.c:    NLocSpn = X->Def.NLocSpn;
check.c:    for(u_loc=0;u_loc<=X->Def.Nup;u_loc++){
check.c:    NCond   = X->Def.Nsite-X->Def.NLocSpn;
check.c:    NLocSpn = X->Def.NLocSpn;
check.c:    if(X->Def.iFlgGeneralSpin ==FALSE){
check.c:      if(X->Def.Nup+X->Def.Ndown != X->Def.Nsite){
check.c:      //comb_sum= Binomial(Ns, X->Def.Ne, comb, Ns);
check.c:      comb_sum= Binomial(Ns, X->Def.Nup, comb, Ns);
check.c:      X->Def.Tpow[0]=idimmax;
check.c:      for(isite=0; isite<X->Def.Nsite;isite++){
check.c:	idimmax=idimmax*X->Def.SiteToBit[isite];
check.c:	X->Def.Tpow[isite+1]=idimmax;
check.c:	for(isite=0; isite<X->Def.Nsite;isite++){
check.c:	  tmp_sz += GetLocal2Sz(isite+1,idim, X->Def.SiteToBit, X->Def.Tpow );	  
check.c:	if(tmp_sz == X->Def.Total2Sz){
check.c:    fprintf(stderr, cErrNoModel, X->Def.iCalcModel);
check.c:  X->Check.idim_max = comb_sum;
check.c:  switch(X->Def.iCalcType) {
check.c:      switch (X->Def.iCalcModel) {
check.c:          X->Check.max_mem = 5.5 * X->Check.idim_max * 8.0 / (pow(10, 9));
check.c:          X->Check.max_mem = 4.5 * X->Check.idim_max * 8.0 / (pow(10, 9));
check.c:      switch (X->Def.iCalcModel) {
check.c:          X->Check.max_mem = (6 * X->Def.k_exct + 2) * X->Check.idim_max * 16.0 / (pow(10, 9));
check.c:          X->Check.max_mem = (6 * X->Def.k_exct + 1.5) * X->Check.idim_max * 16.0 / (pow(10, 9));
check.c:      switch (X->Def.iCalcModel) {
check.c:          if (X->Def.iFlgCalcSpec != CALCSPEC_NOT) {
check.c:            X->Check.max_mem = (2) * X->Check.idim_max * 16.0 / (pow(10, 9));
check.c:            X->Check.max_mem = 4.5 * X->Check.idim_max * 16.0 / (pow(10, 9));
check.c:          if (X->Def.iFlgCalcSpec != CALCSPEC_NOT) {
check.c:            X->Check.max_mem = (2) * X->Check.idim_max * 16.0 / (pow(10, 9));
check.c:            X->Check.max_mem = 3.5 * X->Check.idim_max * 16.0 / (pow(10, 9));
check.c:      X->Check.max_mem = X->Check.idim_max * 8.0 * X->Check.idim_max * 8.0 / (pow(10, 9));
check.c:      X->Check.max_mem = (4 + 2 + 1) * X->Check.idim_max * 16.0 / (pow(10, 9));
check.c:  //fprintf(stdoutMPI, "  MAX DIMENSION idim_max=%ld \n",X->Check.idim_max);
check.c:  //fprintf(stdoutMPI, "  APPROXIMATE REQUIRED MEMORY  max_mem=%lf GB \n",X->Check.max_mem);
check.c:  unsigned long int li_dim_max=MaxMPI_li(X->Check.idim_max);
check.c:  double dmax_mem=MaxMPI_d(X->Check.max_mem);
check.c:  fprintf(fp,"  MAX DIMENSION idim_max=%ld \n",X->Check.idim_max);
check.c:  fprintf(fp,"  APPROXIMATE REQUIRED MEMORY  max_mem=%lf GB \n",X->Check.max_mem);
check.c:  switch(X->Def.iCalcModel){
check.c:    while(tmp <= X->Def.Nsite){
check.c:    if(X->Def.iFlgGeneralSpin==FALSE){ 
check.c:      while(tmp <= X->Def.Nsite/2){
check.c:      GetSplitBitForGeneralSpin(X->Def.Nsite, &tmp_sdim, X->Def.SiteToBit);
check.c:    fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
check.c:  X->Check.sdim=tmp_sdim;
check.c:  switch(X->Def.iCalcModel){
check.c:    //fprintf(stdoutMPI, "sdim=%ld =2^%d\n",X->Check.sdim,X->Def.Nsite);
check.c:    fprintf(fp,"sdim=%ld =2^%d\n",X->Check.sdim,X->Def.Nsite);
check.c:    if(X->Def.iFlgGeneralSpin==FALSE){
check.c:      //fprintf(stdoutMPI, "sdim=%ld =2^%d\n",X->Check.sdim,X->Def.Nsite/2);
check.c:      fprintf(fp,"sdim=%ld =2^%d\n",X->Check.sdim,X->Def.Nsite/2);
check.c:  X->Def.Tpow[0]=u_tmp;
check.c:  switch(X->Def.iCalcModel){
check.c:    for(i=1;i<=2*X->Def.Nsite;i++){
check.c:      X->Def.Tpow[i]=u_tmp;
check.c:    for(i=1;i<=2*X->Def.Nsite-1;i++){
check.c:      X->Def.Tpow[i]=u_tmp;
check.c:   if(X->Def.iFlgGeneralSpin==FALSE){
check.c:     for(i=1;i<=X->Def.Nsite;i++){
check.c:       X->Def.Tpow[i]=u_tmp;
check.c:     X->Def.Tpow[0]=u_tmp;
check.c:      for(i=1;i<X->Def.Nsite;i++){
check.c:	u_tmp=u_tmp*X->Def.SiteToBit[i-1];
check.c:	X->Def.Tpow[i]=u_tmp;
check.c:   if(X->Def.iFlgGeneralSpin==FALSE){
check.c:     for(i=1;i<=X->Def.Nsite-1;i++){
check.c:       X->Def.Tpow[i]=u_tmp;
check.c:     for(i=0;i<X->Def.Nsite;i++){
check.c:       fprintf(fp,"%ld %ld \n",i,X->Def.Tpow[i]);
check.c:    fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:  long unsigned int i_max=X->Check.idim_max;
diagonalcalc.c:  if(X->Def.NCoulombIntra>0){
diagonalcalc.c:    for(i = 0; i < X->Def.NCoulombIntra; i++){
diagonalcalc.c:      isite1 = X->Def.CoulombIntra[i][0]+1;
diagonalcalc.c:      tmp_V  = X->Def.ParaCoulombIntra[i];     
diagonalcalc.c:  if(X->Def.EDNChemi>0){
diagonalcalc.c:    for(i = 0; i < X->Def.EDNChemi; i++){
diagonalcalc.c:      isite1 = X->Def.EDChemi[i]+1;
diagonalcalc.c:      spin   = X->Def.EDSpinChemi[i];
diagonalcalc.c:      tmp_V  = -X->Def.EDParaChemi[i];
diagonalcalc.c:  if(X->Def.NCoulombInter>0){
diagonalcalc.c:    for(i = 0; i < X->Def.NCoulombInter; i++){
diagonalcalc.c:      isite1 = X->Def.CoulombInter[i][0]+1;
diagonalcalc.c:      isite2 = X->Def.CoulombInter[i][1]+1;
diagonalcalc.c:      tmp_V  = X->Def.ParaCoulombInter[i];
diagonalcalc.c:  if(X->Def.NHundCoupling>0){
diagonalcalc.c:    for(i = 0; i < X->Def.NHundCoupling; i++){
diagonalcalc.c:      isite1 = X->Def.HundCoupling[i][0]+1;
diagonalcalc.c:      isite2 = X->Def.HundCoupling[i][1]+1;
diagonalcalc.c:      tmp_V  = -X->Def.ParaHundCoupling[i];
diagonalcalc.c:  if(X->Def.NInterAll_Diagonal>0){    
diagonalcalc.c:    for(i = 0; i < X->Def.NInterAll_Diagonal; i++){
diagonalcalc.c:      isite1=X->Def.InterAll_Diagonal[i][0]+1;
diagonalcalc.c:      A_spin=X->Def.InterAll_Diagonal[i][1];
diagonalcalc.c:      isite2=X->Def.InterAll_Diagonal[i][2]+1;
diagonalcalc.c:      B_spin=X->Def.InterAll_Diagonal[i][3];
diagonalcalc.c:      tmp_V =  X->Def.ParaInterAll_Diagonal[i];
diagonalcalc.c:  if (X->Def.NTETransferDiagonal[_istep] > 0) {
diagonalcalc.c:    for (i = 0; i < X->Def.NTETransferDiagonal[_istep]; i++) {
diagonalcalc.c:      isite1 = X->Def.TETransferDiagonal[_istep][i][0] + 1;
diagonalcalc.c:      A_spin = X->Def.TETransferDiagonal[_istep][i][1];
diagonalcalc.c:      tmp_V = X->Def.ParaTETransferDiagonal[_istep][i];
diagonalcalc.c:  else if (X->Def.NTEInterAllDiagonal[_istep] >0) {
diagonalcalc.c:    for (i = 0; i < X->Def.NTEInterAllDiagonal[_istep]; i++) {
diagonalcalc.c:      isite1 = X->Def.TEInterAllDiagonal[_istep][i][0] + 1;
diagonalcalc.c:      A_spin = X->Def.TEInterAllDiagonal[_istep][i][1];
diagonalcalc.c:      isite2 = X->Def.TEInterAllDiagonal[_istep][i][2] + 1;
diagonalcalc.c:      B_spin = X->Def.TEInterAllDiagonal[_istep][i][3];
diagonalcalc.c:      tmp_V = X->Def.ParaTEInterAllDiagonal[_istep][i];
diagonalcalc.c:    if (X->Def.NTEChemi[_istep] > 0) {
diagonalcalc.c:      for(i=0; i< X->Def.NTEChemi[_istep]; i++) {
diagonalcalc.c:        isite1 = X->Def.TEChemi[_istep][i] + 1;
diagonalcalc.c:        A_spin = X->Def.SpinTEChemi[_istep][i];
diagonalcalc.c:        tmp_V = -X->Def.ParaTEChemi[_istep][i];
diagonalcalc.c:  long unsigned int i_max=X->Check.idim_max;
diagonalcalc.c:  if (isite1 > X->Def.Nsite){
diagonalcalc.c:    switch (X->Def.iCalcModel) {
diagonalcalc.c:      is1_up   = X->Def.Tpow[2 * isite1 - 2];
diagonalcalc.c:      is1_down = X->Def.Tpow[2 * isite1 - 1];
diagonalcalc.c:      fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:    }/*switch (X->Def.iCalcModel)*/
diagonalcalc.c:  }/*if (isite1 >= X->Def.Nsite*/
diagonalcalc.c:    switch (X->Def.iCalcModel){
diagonalcalc.c:      is1_up   = X->Def.Tpow[2*isite1-2];
diagonalcalc.c:      is1_down = X->Def.Tpow[2*isite1-1];
diagonalcalc.c:      is1_up   = X->Def.Tpow[2*isite1-2];
diagonalcalc.c:      is1_down = X->Def.Tpow[2*isite1-1];
diagonalcalc.c:      fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:  long unsigned int i_max=X->Check.idim_max;
diagonalcalc.c:  if (isite1 > X->Def.Nsite){
diagonalcalc.c:    switch (X->Def.iCalcModel) {
diagonalcalc.c:        is1 = X->Def.Tpow[2 * isite1 - 2];
diagonalcalc.c:        is1 = X->Def.Tpow[2 * isite1 - 1];
diagonalcalc.c:      if (X->Def.iFlgGeneralSpin == FALSE) {
diagonalcalc.c:        is1_up = X->Def.Tpow[isite1 - 1];
diagonalcalc.c:      } /*if (X->Def.iFlgGeneralSpin == FALSE)*/
diagonalcalc.c:      else /*if (X->Def.iFlgGeneralSpin == TRUE)*/ {
diagonalcalc.c:          isite1, isigma1, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:      }/*if (X->Def.iFlgGeneralSpin == TRUE)*/
diagonalcalc.c:      fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:    } /*switch (X->Def.iCalcModel)*/
diagonalcalc.c:  }/*if (isite1 >= X->Def.Nsite*/
diagonalcalc.c:  switch (X->Def.iCalcModel){
diagonalcalc.c:      is1   = X->Def.Tpow[2*isite1-2];
diagonalcalc.c:      is1 = X->Def.Tpow[2*isite1-1];
diagonalcalc.c:      is1   = X->Def.Tpow[2*isite1-2];
diagonalcalc.c:      is1 = X->Def.Tpow[2*isite1-1];
diagonalcalc.c:    if(X->Def.iFlgGeneralSpin==FALSE){
diagonalcalc.c:      is1_up   = X->Def.Tpow[isite1-1];
diagonalcalc.c:       num1=BitCheckGeneral (j-1, isite1, isigma1, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:    if(X->Def.iFlgGeneralSpin==FALSE){
diagonalcalc.c:      is1_up   = X->Def.Tpow[isite1-1];
diagonalcalc.c:       num1=BitCheckGeneral (list_1[j], isite1, isigma1, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:    fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:  long unsigned int i_max=X->Check.idim_max;
diagonalcalc.c:  if (/*isite2 => */ isite1 > X->Def.Nsite) {
diagonalcalc.c:    switch (X->Def.iCalcModel) {
diagonalcalc.c:      is1_up   = X->Def.Tpow[2 * isite1 - 2];
diagonalcalc.c:      is1_down = X->Def.Tpow[2 * isite1 - 1];
diagonalcalc.c:      is2_up   = X->Def.Tpow[2 * isite2 - 2];
diagonalcalc.c:      is2_down = X->Def.Tpow[2 * isite2 - 1];
diagonalcalc.c:      fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:    }/*switch (X->Def.iCalcModel)*/
diagonalcalc.c:  }/*if (isite1 > X->Def.Nsite)*/
diagonalcalc.c:  else if (isite2 > X->Def.Nsite /* => isite1 */) {
diagonalcalc.c:    switch(X->Def.iCalcModel){
diagonalcalc.c:      is1_up   = X->Def.Tpow[2 * isite1 - 2];
diagonalcalc.c:      is1_down = X->Def.Tpow[2 * isite1 - 1];
diagonalcalc.c:      is2_up   = X->Def.Tpow[2 * isite2 - 2];
diagonalcalc.c:      is2_down = X->Def.Tpow[2 * isite2 - 1];      
diagonalcalc.c:      fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:    switch (X->Def.iCalcModel) {
diagonalcalc.c:      fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:    }/*switch (X->Def.iCalcModel)*/
diagonalcalc.c:  }/*else if (isite2 > X->Def.Nsite)*/
diagonalcalc.c:    switch (X->Def.iCalcModel){
diagonalcalc.c:      is1_up   = X->Def.Tpow[2*isite1-2];
diagonalcalc.c:      is1_down = X->Def.Tpow[2*isite1-1];
diagonalcalc.c:      is2_up   = X->Def.Tpow[2*isite2-2];
diagonalcalc.c:      is2_down = X->Def.Tpow[2*isite2-1];
diagonalcalc.c:      is1_up   = X->Def.Tpow[2*isite1-2];
diagonalcalc.c:      is1_down = X->Def.Tpow[2*isite1-1];
diagonalcalc.c:      is2_up   = X->Def.Tpow[2*isite2-2];
diagonalcalc.c:      is2_down = X->Def.Tpow[2*isite2-1];
diagonalcalc.c:      fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:  long unsigned int i_max=X->Check.idim_max;
diagonalcalc.c:  if (/*isite2 >= */ isite1 > X->Def.Nsite){
diagonalcalc.c:    switch (X->Def.iCalcModel) {
diagonalcalc.c:      is1_up   = X->Def.Tpow[2 * isite1 - 2];
diagonalcalc.c:      is1_down = X->Def.Tpow[2 * isite1 - 1];
diagonalcalc.c:      is2_up   = X->Def.Tpow[2 * isite2 - 2];
diagonalcalc.c:      is2_down = X->Def.Tpow[2 * isite2 - 1];
diagonalcalc.c:      is1_up = X->Def.Tpow[isite1 - 1];
diagonalcalc.c:      is2_up = X->Def.Tpow[isite2 - 1];
diagonalcalc.c:      fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:  }/*if (isite1 > X->Def.Nsite)*/
diagonalcalc.c:  else if (isite2 > X->Def.Nsite /* >= isite1 */) {
diagonalcalc.c:    switch (X->Def.iCalcModel) {
diagonalcalc.c:      is1_up   = X->Def.Tpow[2 * isite1 - 2];
diagonalcalc.c:      is1_down = X->Def.Tpow[2 * isite1 - 1];
diagonalcalc.c:      is2_up   = X->Def.Tpow[2 * isite2 - 2];
diagonalcalc.c:      is2_down = X->Def.Tpow[2 * isite2 - 1];
diagonalcalc.c:      is1_up   = X->Def.Tpow[2 * isite1 - 2];
diagonalcalc.c:      is1_down = X->Def.Tpow[2 * isite1 - 1];
diagonalcalc.c:      is2_up   = X->Def.Tpow[2 * isite2 - 2];
diagonalcalc.c:      is2_down = X->Def.Tpow[2 * isite2 - 1];
diagonalcalc.c:      is1_up = X->Def.Tpow[isite1 - 1];
diagonalcalc.c:      is2_up = X->Def.Tpow[isite2 - 1];
diagonalcalc.c:      is1_up = X->Def.Tpow[isite1 - 1];
diagonalcalc.c:      is2_up = X->Def.Tpow[isite2 - 1];
diagonalcalc.c:      fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:    }/*switch (X->Def.iCalcModel)*/
diagonalcalc.c:  }/*else if (isite2 > X->Def.Nsite)*/
diagonalcalc.c:    switch (X->Def.iCalcModel){
diagonalcalc.c:      is1_up   = X->Def.Tpow[2*isite1-2];
diagonalcalc.c:      is1_down = X->Def.Tpow[2*isite1-1];
diagonalcalc.c:      is2_up   = X->Def.Tpow[2*isite2-2];
diagonalcalc.c:      is2_down = X->Def.Tpow[2*isite2-1];
diagonalcalc.c:      is1_up   = X->Def.Tpow[2*isite1-2];
diagonalcalc.c:      is1_down = X->Def.Tpow[2*isite1-1];
diagonalcalc.c:      is2_up   = X->Def.Tpow[2*isite2-2];
diagonalcalc.c:      is2_down = X->Def.Tpow[2*isite2-1];
diagonalcalc.c:      is1_up   = X->Def.Tpow[isite1-1];
diagonalcalc.c:      is2_up   = X->Def.Tpow[isite2-1];
diagonalcalc.c:      is1_up   = X->Def.Tpow[isite1-1];
diagonalcalc.c:      is2_up   = X->Def.Tpow[isite2-1];
diagonalcalc.c:      fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:  long unsigned int i_max=X->Check.idim_max;
diagonalcalc.c:  if (isite1 > X->Def.Nsite) {
diagonalcalc.c:    switch (X->Def.iCalcModel) {
diagonalcalc.c:      is1_spin = X->Def.Tpow[2 * isite1 - 2 + isigma1];
diagonalcalc.c:      is2_spin = X->Def.Tpow[2 * isite2 - 2 + isigma2];
diagonalcalc.c:      if (X->Def.iFlgGeneralSpin == FALSE) {
diagonalcalc.c:        is1_up = X->Def.Tpow[isite1 - 1];
diagonalcalc.c:        is2_up = X->Def.Tpow[isite2 - 1];
diagonalcalc.c:      }/*if (X->Def.iFlgGeneralSpin == FALSE)*/
diagonalcalc.c:          X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:          X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:      }/*if (X->Def.iFlgGeneralSpin == TRUE)*/
diagonalcalc.c:      fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:    }/*if (isite1 > X->Def.Nsite)*/
diagonalcalc.c:  }/*if (isite1 > X->Def.Nsite)*/
diagonalcalc.c:  else if (isite2 > X->Def.Nsite) {
diagonalcalc.c:    switch (X->Def.iCalcModel) {
diagonalcalc.c:      is1_spin = X->Def.Tpow[2 * isite1 - 2 + isigma1];
diagonalcalc.c:      is2_spin = X->Def.Tpow[2 * isite2 - 2 + isigma2];
diagonalcalc.c:      is1_spin = X->Def.Tpow[2 * isite1 - 2 + isigma1];
diagonalcalc.c:      is2_spin = X->Def.Tpow[2 * isite2 - 2 + isigma2];
diagonalcalc.c:      if (X->Def.iFlgGeneralSpin == FALSE) {
diagonalcalc.c:        is1_up = X->Def.Tpow[isite1 - 1];
diagonalcalc.c:        is2_up = X->Def.Tpow[isite2 - 1];
diagonalcalc.c:      }/* if (X->Def.iFlgGeneralSpin == FALSE)*/
diagonalcalc.c:          X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:            num1 = BitCheckGeneral(j - 1, isite1, isigma1, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:      }/* if (X->Def.iFlgGeneralSpin == TRUE)*/
diagonalcalc.c:      if (X->Def.iFlgGeneralSpin == FALSE) {
diagonalcalc.c:        is1_up = X->Def.Tpow[isite1 - 1];
diagonalcalc.c:        is2_up = X->Def.Tpow[isite2 - 1];
diagonalcalc.c:      }/* if (X->Def.iFlgGeneralSpin == FALSE)*/
diagonalcalc.c:      else /* if (X->Def.iFlgGeneralSpin == TRUE)*/{
diagonalcalc.c:          X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:            num1 = BitCheckGeneral(list_1[j], isite1, isigma1, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:      } /* if (X->Def.iFlgGeneralSpin == TRUE)*/
diagonalcalc.c:      fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:    }/*switch (X->Def.iCalcModel)*/
diagonalcalc.c:  }/*else if (isite2 > X->Def.Nsite)*/
diagonalcalc.c:  switch (X->Def.iCalcModel){
diagonalcalc.c:    is1_spin   = X->Def.Tpow[2*isite1-2+isigma1];
diagonalcalc.c:    is2_spin   = X->Def.Tpow[2*isite2-2+isigma2];
diagonalcalc.c:    is1_spin  = X->Def.Tpow[2*isite1-2+isigma1];
diagonalcalc.c:    is2_spin = X->Def.Tpow[2*isite2-2+isigma2];
diagonalcalc.c:   if(X->Def.iFlgGeneralSpin==FALSE){
diagonalcalc.c:     is1_up   = X->Def.Tpow[isite1-1];
diagonalcalc.c:     is2_up   = X->Def.Tpow[isite2-1];
diagonalcalc.c:       num1=BitCheckGeneral (list_1[j], isite1, isigma1, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:	 num1=BitCheckGeneral (list_1[j], isite2, isigma2, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:   if(X->Def.iFlgGeneralSpin==FALSE){
diagonalcalc.c:     is1_up   = X->Def.Tpow[isite1-1];
diagonalcalc.c:     is2_up   = X->Def.Tpow[isite2-1];
diagonalcalc.c:       num1=BitCheckGeneral (j-1, isite1, isigma1, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:	 num1=BitCheckGeneral (j-1, isite2, isigma2, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:    fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:  long unsigned int i_max=X->Check.idim_max;
diagonalcalc.c:  if (isite1 > X->Def.Nsite) {
diagonalcalc.c:    switch (X->Def.iCalcModel) {
diagonalcalc.c:        is1_spin = X->Def.Tpow[2 * isite1 - 2 + isigma1];
diagonalcalc.c:        is2_spin = X->Def.Tpow[2 * isite2 - 2 + isigma2];
diagonalcalc.c:        if (X->Def.iFlgGeneralSpin == FALSE) {
diagonalcalc.c:          is1_up = X->Def.Tpow[isite1 - 1];
diagonalcalc.c:          is2_up = X->Def.Tpow[isite2 - 1];
diagonalcalc.c:        }/*if (X->Def.iFlgGeneralSpin == FALSE)*/
diagonalcalc.c:                                 X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:                                 X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:        fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:    }/*if (isite1 > X->Def.Nsite)*/
diagonalcalc.c:    X->Large.prdct += dam_pr;
diagonalcalc.c:  }/*if (isite1 > X->Def.Nsite)*/
diagonalcalc.c:  else if (isite2 > X->Def.Nsite) {
diagonalcalc.c:    switch (X->Def.iCalcModel) {
diagonalcalc.c:        is1_spin = X->Def.Tpow[2 * isite1 - 2 + isigma1];
diagonalcalc.c:        is2_spin = X->Def.Tpow[2 * isite2 - 2 + isigma2];
diagonalcalc.c:        is1_spin = X->Def.Tpow[2 * isite1 - 2 + isigma1];
diagonalcalc.c:        is2_spin = X->Def.Tpow[2 * isite2 - 2 + isigma2];
diagonalcalc.c:        if (X->Def.iFlgGeneralSpin == FALSE) {
diagonalcalc.c:          is1_up = X->Def.Tpow[isite1 - 1];
diagonalcalc.c:          is2_up = X->Def.Tpow[isite2 - 1];
diagonalcalc.c:        }/* if (X->Def.iFlgGeneralSpin == FALSE)*/
diagonalcalc.c:                                 X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:              num1 = BitCheckGeneral(j - 1, isite1, isigma1, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:        }/* if (X->Def.iFlgGeneralSpin == TRUE)*/
diagonalcalc.c:        if (X->Def.iFlgGeneralSpin == FALSE) {
diagonalcalc.c:          is1_up = X->Def.Tpow[isite1 - 1];
diagonalcalc.c:          is2_up = X->Def.Tpow[isite2 - 1];
diagonalcalc.c:        }/* if (X->Def.iFlgGeneralSpin == FALSE)*/
diagonalcalc.c:        else /* if (X->Def.iFlgGeneralSpin == TRUE)*/{
diagonalcalc.c:          X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:              num1 = BitCheckGeneral(list_1[j], isite1, isigma1, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:        } /* if (X->Def.iFlgGeneralSpin == TRUE)*/
diagonalcalc.c:        fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:    }/*switch (X->Def.iCalcModel)*/
diagonalcalc.c:    X->Large.prdct += dam_pr;
diagonalcalc.c:  }/*else if (isite2 > X->Def.Nsite)*/
diagonalcalc.c:  switch (X->Def.iCalcModel){
diagonalcalc.c:      is1_spin   = X->Def.Tpow[2*isite1-2+isigma1];
diagonalcalc.c:      is2_spin   = X->Def.Tpow[2*isite2-2+isigma2];
diagonalcalc.c:      is1_spin  = X->Def.Tpow[2*isite1-2+isigma1];
diagonalcalc.c:      is2_spin = X->Def.Tpow[2*isite2-2+isigma2];
diagonalcalc.c:      if(X->Def.iFlgGeneralSpin==FALSE){
diagonalcalc.c:        is1_up   = X->Def.Tpow[isite1-1];
diagonalcalc.c:        is2_up   = X->Def.Tpow[isite2-1];
diagonalcalc.c:          num1=BitCheckGeneral (list_1[j], isite1, isigma1, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:            num1=BitCheckGeneral (list_1[j], isite2, isigma2, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:      if(X->Def.iFlgGeneralSpin==FALSE){
diagonalcalc.c:        is1_up   = X->Def.Tpow[isite1-1];
diagonalcalc.c:        is2_up   = X->Def.Tpow[isite2-1];
diagonalcalc.c:          num1=BitCheckGeneral (j-1, isite1, isigma1, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:            num1=BitCheckGeneral (j-1, isite2, isigma2, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:      fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:  X->Large.prdct += dam_pr;
diagonalcalc.c:  long unsigned int i_max=X->Check.idim_max;
diagonalcalc.c:  if (isite1 > X->Def.Nsite){
diagonalcalc.c:    switch (X->Def.iCalcModel) {
diagonalcalc.c:          is1 = X->Def.Tpow[2 * isite1 - 2];
diagonalcalc.c:          is1 = X->Def.Tpow[2 * isite1 - 1];
diagonalcalc.c:        if (X->Def.iFlgGeneralSpin == FALSE) {
diagonalcalc.c:          is1_up = X->Def.Tpow[isite1 - 1];
diagonalcalc.c:        } /*if (X->Def.iFlgGeneralSpin == FALSE)*/
diagonalcalc.c:        else /*if (X->Def.iFlgGeneralSpin == TRUE)*/ {
diagonalcalc.c:                                 isite1, isigma1, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:        }/*if (X->Def.iFlgGeneralSpin == TRUE)*/
diagonalcalc.c:        fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:    } /*switch (X->Def.iCalcModel)*/
diagonalcalc.c:    X->Large.prdct += dam_pr;
diagonalcalc.c:  }/*if (isite1 >= X->Def.Nsite*/
diagonalcalc.c:  switch (X->Def.iCalcModel){
diagonalcalc.c:        is1   = X->Def.Tpow[2*isite1-2];
diagonalcalc.c:        is1 = X->Def.Tpow[2*isite1-1];
diagonalcalc.c:        is1   = X->Def.Tpow[2*isite1-2];
diagonalcalc.c:        is1 = X->Def.Tpow[2*isite1-1];
diagonalcalc.c:      if(X->Def.iFlgGeneralSpin==FALSE){
diagonalcalc.c:        is1_up   = X->Def.Tpow[isite1-1];
diagonalcalc.c:          num1=BitCheckGeneral (j-1, isite1, isigma1, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:      if(X->Def.iFlgGeneralSpin==FALSE){
diagonalcalc.c:        is1_up   = X->Def.Tpow[isite1-1];
diagonalcalc.c:          num1=BitCheckGeneral (list_1[j], isite1, isigma1, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:      fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:  X->Large.prdct += dam_pr;
diagonalcalc.c:  long unsigned int i_max=X->Check.idim_max;
diagonalcalc.c:  if (isite1 > X->Def.Nsite){
diagonalcalc.c:    switch (X->Def.iCalcModel) {
diagonalcalc.c:          is1 = X->Def.Tpow[2 * isite1 - 2];
diagonalcalc.c:          is1 = X->Def.Tpow[2 * isite1 - 1];
diagonalcalc.c:        if (X->Def.iFlgGeneralSpin == FALSE) {
diagonalcalc.c:          is1_up = X->Def.Tpow[isite1 - 1];
diagonalcalc.c:        } /*if (X->Def.iFlgGeneralSpin == FALSE)*/
diagonalcalc.c:        else /*if (X->Def.iFlgGeneralSpin == TRUE)*/ {
diagonalcalc.c:                                 isite1, isigma1, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:        }/*if (X->Def.iFlgGeneralSpin == TRUE)*/
diagonalcalc.c:        fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:    } /*switch (X->Def.iCalcModel)*/
diagonalcalc.c:  }/*if (isite1 >= X->Def.Nsite*/
diagonalcalc.c:  else {//(isite1 < X->Def.Nsite)
diagonalcalc.c:    switch (X->Def.iCalcModel) {
diagonalcalc.c:          is1 = X->Def.Tpow[2 * isite1 - 2];
diagonalcalc.c:          is1 = X->Def.Tpow[2 * isite1 - 1];
diagonalcalc.c:          is1 = X->Def.Tpow[2 * isite1 - 2];
diagonalcalc.c:          is1 = X->Def.Tpow[2 * isite1 - 1];
diagonalcalc.c:        if (X->Def.iFlgGeneralSpin == FALSE) {
diagonalcalc.c:          is1_up = X->Def.Tpow[isite1 - 1];
diagonalcalc.c:            num1 = BitCheckGeneral(j - 1, isite1, isigma1, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:        if (X->Def.iFlgGeneralSpin == FALSE) {
diagonalcalc.c:          is1_up = X->Def.Tpow[isite1 - 1];
diagonalcalc.c:            num1 = BitCheckGeneral(list_1[j], isite1, isigma1, X->Def.SiteToBit, X->Def.Tpow);
diagonalcalc.c:        fprintf(stdoutMPI, cErrNoModel, X->Def.iCalcModel);
diagonalcalc.c:  X->Large.prdct += dam_pr;
expec_cisajs.c:  if(X->Def.NCisAjt <1) return 0;
expec_cisajs.c:  i_max = X->Check.idim_max;      
expec_cisajs.c:  if(GetSplitBitByModel(X->Def.Nsite, X->Def.iCalcModel, &irght, &ilft, &ihfbit)!=0){
expec_cisajs.c:  X->Large.i_max    = i_max;
expec_cisajs.c:  X->Large.irght    = irght;
expec_cisajs.c:  X->Large.ilft     = ilft;
expec_cisajs.c:  X->Large.ihfbit   = ihfbit;
expec_cisajs.c:  X->Large.mode     = M_CORR;
expec_cisajs.c:  switch(X->Def.iCalcType){
expec_cisajs.c:    if(X->Def.St==0){
expec_cisajs.c:      sprintf(sdt, cFileName1BGreen_Lanczos, X->Def.CDataFileHead);
expec_cisajs.c:    }else if(X->Def.St==1){
expec_cisajs.c:      sprintf(sdt, cFileName1BGreen_CG, X->Def.CDataFileHead);
expec_cisajs.c:    step=X->Def.istep;
expec_cisajs.c:    rand_i=X->Def.irand;
expec_cisajs.c:    sprintf(sdt, cFileName1BGreen_TPQ, X->Def.CDataFileHead, rand_i, step);
expec_cisajs.c:      step=X->Def.istep;
expec_cisajs.c:      sprintf(sdt, cFileName1BGreen_TE, X->Def.CDataFileHead, step);
expec_cisajs.c:    sprintf(sdt, cFileName1BGreen_FullDiag, X->Def.CDataFileHead, X->Phys.eigen_num);
expec_cisajs.c:  switch(X->Def.iCalcModel){
expec_cisajs.c:  if(X->Def.St==0){
expec_cisajs.c:    if(X->Def.iCalcType==Lanczos){
expec_cisajs.c:    else if(X->Def.iCalcType==TPQCalc){
expec_cisajs.c:    else if(X->Def.iCalcType==TimeEvolution){
expec_cisajs.c:  }else if(X->Def.St==1){
expec_cisajs.c:    i_max = X->Check.idim_max;
expec_cisajs.c:    for(i=0;i<X->Def.NCisAjt;i++){
expec_cisajs.c:        org_isite1 = X->Def.CisAjt[i][0]+1;
expec_cisajs.c:        org_isite2 = X->Def.CisAjt[i][2]+1;
expec_cisajs.c:        org_sigma1 = X->Def.CisAjt[i][1];
expec_cisajs.c:        org_sigma2 = X->Def.CisAjt[i][3];
expec_cisajs.c:        if (org_isite1  > X->Def.Nsite &&
expec_cisajs.c:            org_isite2  > X->Def.Nsite) {
expec_cisajs.c:                    is   = X->Def.Tpow[2 * org_isite1 - 2];
expec_cisajs.c:                    is = X->Def.Tpow[2 * org_isite1 - 1];
expec_cisajs.c:        else if (org_isite2  > X->Def.Nsite || org_isite1  > X->Def.Nsite){
expec_cisajs.c:    i_max = X->Check.idim_max;
expec_cisajs.c:    for(i=0;i<X->Def.NCisAjt;i++){
expec_cisajs.c:        org_isite1 = X->Def.CisAjt[i][0]+1;
expec_cisajs.c:        org_isite2 = X->Def.CisAjt[i][2]+1;
expec_cisajs.c:        org_sigma1 = X->Def.CisAjt[i][1];
expec_cisajs.c:        org_sigma2 = X->Def.CisAjt[i][3];
expec_cisajs.c:        if(X->Def.iFlgSzConserved ==TRUE){
expec_cisajs.c:        if(X->Def.iCalcModel==Kondo || X->Def.iCalcModel==KondoGC) {
expec_cisajs.c:          if( (X->Def.LocSpn[org_isite1 - 1] == 1 && X->Def.LocSpn[org_isite2 - 1] == 0) ||
expec_cisajs.c:                  (X->Def.LocSpn[org_isite1 - 1] == 0 && X->Def.LocSpn[org_isite2 - 1] == 1)
expec_cisajs.c:        if (org_isite1  > X->Def.Nsite &&
expec_cisajs.c:            org_isite2  > X->Def.Nsite) {
expec_cisajs.c:                is   = X->Def.Tpow[2 * org_isite1 - 2+org_sigma1];
expec_cisajs.c:        else if (org_isite2  > X->Def.Nsite || org_isite1  > X->Def.Nsite){
expec_cisajs.c:              is   = X->Def.Tpow[2 * org_isite1 - 2 + org_sigma1];
expec_cisajs.c:    if (X->Def.iFlgGeneralSpin == FALSE) {
expec_cisajs.c:    i_max = X->Check.idim_max;
expec_cisajs.c:    for(i=0;i<X->Def.NCisAjt;i++){
expec_cisajs.c:        org_isite1 = X->Def.CisAjt[i][0]+1;
expec_cisajs.c:        org_isite2 = X->Def.CisAjt[i][2]+1;
expec_cisajs.c:        org_sigma1 = X->Def.CisAjt[i][1];
expec_cisajs.c:        org_sigma2 = X->Def.CisAjt[i][3];
expec_cisajs.c:                if(org_isite1 > X->Def.Nsite){
expec_cisajs.c:                    is1_up = X->Def.Tpow[org_isite1 - 1];
expec_cisajs.c:                }// org_isite1 > X->Def.Nsite
expec_cisajs.c:                    isite1     = X->Def.Tpow[org_isite1-1];
expec_cisajs.c:    i_max = X->Check.idim_max;
expec_cisajs.c:    for(i=0;i<X->Def.NCisAjt;i++){
expec_cisajs.c:        org_isite1 = X->Def.CisAjt[i][0]+1;
expec_cisajs.c:        org_isite2 = X->Def.CisAjt[i][2]+1;
expec_cisajs.c:        org_sigma1 = X->Def.CisAjt[i][1];
expec_cisajs.c:        org_sigma2 = X->Def.CisAjt[i][3];
expec_cisajs.c:            if(org_isite1 >X->Def.Nsite){
expec_cisajs.c:                                           org_isite1, org_sigma1, X->Def.SiteToBit, X->Def.Tpow);
expec_cisajs.c:            else {//org_isite1 <= X->Def.Nsite
expec_cisajs.c:                        num1 = BitCheckGeneral(list_1[j], org_isite1, org_sigma1, X->Def.SiteToBit, X->Def.Tpow);
expec_cisajs.c:    if (X->Def.iFlgGeneralSpin == FALSE) {
expec_cisajs.c:    i_max = X->Check.idim_max;
expec_cisajs.c:    for(i=0;i<X->Def.NCisAjt;i++){
expec_cisajs.c:        org_isite1 = X->Def.CisAjt[i][0]+1;
expec_cisajs.c:        org_isite2 = X->Def.CisAjt[i][2]+1;
expec_cisajs.c:        org_sigma1 = X->Def.CisAjt[i][1];
expec_cisajs.c:        org_sigma2 = X->Def.CisAjt[i][3];
expec_cisajs.c:            if(org_isite1 > X->Def.Nsite){
expec_cisajs.c:                isite1 = X->Def.Tpow[org_isite1-1];
expec_cisajs.c:    i_max = X->Check.idim_max;
expec_cisajs.c:    for (i = 0; i < X->Def.NCisAjt; i++) {
expec_cisajs.c:        org_isite1 = X->Def.CisAjt[i][0] + 1;
expec_cisajs.c:        org_isite2 = X->Def.CisAjt[i][2] + 1;
expec_cisajs.c:        org_sigma1 = X->Def.CisAjt[i][1];
expec_cisajs.c:        org_sigma2 = X->Def.CisAjt[i][3];
expec_cisajs.c:            if (org_isite1 > X->Def.Nsite) {
expec_cisajs.c:            } else {//org_isite1 <= X->Def.Nsite
expec_cisajs.c:                        num1 = BitCheckGeneral(j - 1, org_isite1, org_sigma1, X->Def.SiteToBit, X->Def.Tpow);
expec_cisajs.c:                                                     X->Def.SiteToBit, X->Def.Tpow);
expec_cisajscktaltdc.c:  if(X->Def.NCisAjtCkuAlvDC <1) return 0;
expec_cisajscktaltdc.c:  X->Large.mode=M_CORR;
expec_cisajscktaltdc.c:  if(GetSplitBitByModel(X->Def.Nsite, X->Def.iCalcModel, &irght, &ilft, &ihfbit)!=0){
expec_cisajscktaltdc.c:  switch (X->Def.iCalcType){
expec_cisajscktaltdc.c:    if(X->Def.St==0){
expec_cisajscktaltdc.c:      sprintf(sdt, cFileName2BGreen_Lanczos, X->Def.CDataFileHead);
expec_cisajscktaltdc.c:    }else if(X->Def.St==1){
expec_cisajscktaltdc.c:      sprintf(sdt, cFileName2BGreen_CG, X->Def.CDataFileHead);
expec_cisajscktaltdc.c:    step=X->Def.istep;
expec_cisajscktaltdc.c:    rand_i=X->Def.irand;
expec_cisajscktaltdc.c:    sprintf(sdt, cFileName2BGreen_TPQ, X->Def.CDataFileHead, rand_i, step);
expec_cisajscktaltdc.c:    step=X->Def.istep;
expec_cisajscktaltdc.c:    sprintf(sdt, cFileName2BGreen_TE, X->Def.CDataFileHead, rand_i, step);
expec_cisajscktaltdc.c:    sprintf(sdt, cFileName2BGreen_FullDiag, X->Def.CDataFileHead, X->Phys.eigen_num);
expec_cisajscktaltdc.c:  switch(X->Def.iCalcModel){
expec_cisajscktaltdc.c:  if(X->Def.iCalcType==Lanczos){
expec_cisajscktaltdc.c:    if(X->Def.St==0){
expec_cisajscktaltdc.c:    }else if(X->Def.St==1){
expec_cisajscktaltdc.c:  else if(X->Def.iCalcType==TPQCalc){
expec_cisajscktaltdc.c:  else if(X->Def.iCalcType==TimeEvolution){
expec_cisajscktaltdc.c:     if(X->Def.iCalcType==FullDiag){
expec_cisajscktaltdc.c:     if(X->Def.iCalcModel==Spin){
expec_cisajscktaltdc.c:     }else if(X->Def.iCalcModel==Hubbard || X->Def.iCalcModel==Kondo){
expec_cisajscktaltdc.c:     X->Phys.s2=0.0;   
expec_cisajscktaltdc.c:  tmp_org_isite1   = X->Def.CisAjtCkuAlvDC[i][0]+1;
expec_cisajscktaltdc.c:  tmp_org_sigma1   = X->Def.CisAjtCkuAlvDC[i][1];
expec_cisajscktaltdc.c:  tmp_org_isite2   = X->Def.CisAjtCkuAlvDC[i][2]+1;
expec_cisajscktaltdc.c:  tmp_org_sigma2   = X->Def.CisAjtCkuAlvDC[i][3];
expec_cisajscktaltdc.c:  tmp_org_isite3   = X->Def.CisAjtCkuAlvDC[i][4]+1;
expec_cisajscktaltdc.c:  tmp_org_sigma3   = X->Def.CisAjtCkuAlvDC[i][5];
expec_cisajscktaltdc.c:  tmp_org_isite4   = X->Def.CisAjtCkuAlvDC[i][6]+1;
expec_cisajscktaltdc.c:  tmp_org_sigma4   = X->Def.CisAjtCkuAlvDC[i][7];
expec_cisajscktaltdc.c:    for(i=0;i<X->Def.NCisAjtCkuAlvDC;i++){
expec_cisajscktaltdc.c:        org_isite1   = X->Def.CisAjtCkuAlvDC[i][0]+1;
expec_cisajscktaltdc.c:        org_sigma1   = X->Def.CisAjtCkuAlvDC[i][1];
expec_cisajscktaltdc.c:        org_isite2   = X->Def.CisAjtCkuAlvDC[i][2]+1;
expec_cisajscktaltdc.c:        org_sigma2   = X->Def.CisAjtCkuAlvDC[i][3];
expec_cisajscktaltdc.c:        org_isite3   = X->Def.CisAjtCkuAlvDC[i][4]+1;
expec_cisajscktaltdc.c:        org_sigma3   = X->Def.CisAjtCkuAlvDC[i][5];
expec_cisajscktaltdc.c:        org_isite4   = X->Def.CisAjtCkuAlvDC[i][6]+1;
expec_cisajscktaltdc.c:        org_sigma4   = X->Def.CisAjtCkuAlvDC[i][7];
expec_cisajscktaltdc.c:            isite1 = X->Def.OrgTpow[2*org_isite1-2+org_sigma1] ;
expec_cisajscktaltdc.c:            isite2 = X->Def.OrgTpow[2*org_isite2-2+org_sigma2] ;
expec_cisajscktaltdc.c:            isite3 = X->Def.OrgTpow[2*org_isite3-2+org_sigma3] ;
expec_cisajscktaltdc.c:            isite4 = X->Def.OrgTpow[2*org_isite4-2+org_sigma4] ;
expec_cisajscktaltdc.c:            i_max  = X->Large.i_max;
expec_cisajscktaltdc.c:            isite1 = X->Large.is1_spin;
expec_cisajscktaltdc.c:            isite2 = X->Large.is2_spin;
expec_cisajscktaltdc.c:            Asum   = X->Large.isA_spin;
expec_cisajscktaltdc.c:            Adiff  = X->Large.A_spin;
expec_cisajscktaltdc.c:            isite3 = X->Large.is3_spin;
expec_cisajscktaltdc.c:            isite4 = X->Large.is4_spin;
expec_cisajscktaltdc.c:            Bsum   = X->Large.isB_spin;
expec_cisajscktaltdc.c:            Bdiff  = X->Large.B_spin;
expec_cisajscktaltdc.c:    for(i=0;i<X->Def.NCisAjtCkuAlvDC;i++){
expec_cisajscktaltdc.c:        org_isite1   = X->Def.CisAjtCkuAlvDC[i][0]+1;
expec_cisajscktaltdc.c:        org_sigma1   = X->Def.CisAjtCkuAlvDC[i][1];
expec_cisajscktaltdc.c:        org_isite2   = X->Def.CisAjtCkuAlvDC[i][2]+1;
expec_cisajscktaltdc.c:        org_sigma2   = X->Def.CisAjtCkuAlvDC[i][3];
expec_cisajscktaltdc.c:        org_isite3   = X->Def.CisAjtCkuAlvDC[i][4]+1;
expec_cisajscktaltdc.c:        org_sigma3   = X->Def.CisAjtCkuAlvDC[i][5];
expec_cisajscktaltdc.c:        org_isite4   = X->Def.CisAjtCkuAlvDC[i][6]+1;
expec_cisajscktaltdc.c:        org_sigma4   = X->Def.CisAjtCkuAlvDC[i][7];
expec_cisajscktaltdc.c:        if(X->Def.iFlgSzConserved ==TRUE){
expec_cisajscktaltdc.c:            isite1 = X->Def.OrgTpow[2*org_isite1-2+org_sigma1] ;
expec_cisajscktaltdc.c:            isite2 = X->Def.OrgTpow[2*org_isite2-2+org_sigma2] ;
expec_cisajscktaltdc.c:            isite3 = X->Def.OrgTpow[2*org_isite3-2+org_sigma3] ;
expec_cisajscktaltdc.c:            isite4 = X->Def.OrgTpow[2*org_isite4-2+org_sigma4] ;
expec_cisajscktaltdc.c:            i_max  = X->Large.i_max;
expec_cisajscktaltdc.c:            isite1 = X->Large.is1_spin;
expec_cisajscktaltdc.c:            isite2 = X->Large.is2_spin;
expec_cisajscktaltdc.c:            Asum   = X->Large.isA_spin;
expec_cisajscktaltdc.c:            Adiff  = X->Large.A_spin;
expec_cisajscktaltdc.c:            isite3 = X->Large.is3_spin;
expec_cisajscktaltdc.c:            isite4 = X->Large.is4_spin;
expec_cisajscktaltdc.c:            Bsum   = X->Large.isB_spin;
expec_cisajscktaltdc.c:            Bdiff  = X->Large.B_spin;
expec_cisajscktaltdc.c:    if (X->Def.iFlgGeneralSpin == FALSE) {
expec_cisajscktaltdc.c:    i_max=X->Check.idim_max;
expec_cisajscktaltdc.c:    X->Large.mode=M_CORR;
expec_cisajscktaltdc.c:    for(i=0;i<X->Def.NCisAjtCkuAlvDC;i++){
expec_cisajscktaltdc.c:        tmp_org_isite1   = X->Def.CisAjtCkuAlvDC[i][0]+1;
expec_cisajscktaltdc.c:        tmp_org_sigma1   = X->Def.CisAjtCkuAlvDC[i][1];
expec_cisajscktaltdc.c:        tmp_org_isite2   = X->Def.CisAjtCkuAlvDC[i][2]+1;
expec_cisajscktaltdc.c:        tmp_org_sigma2   = X->Def.CisAjtCkuAlvDC[i][3];
expec_cisajscktaltdc.c:        tmp_org_isite3   = X->Def.CisAjtCkuAlvDC[i][4]+1;
expec_cisajscktaltdc.c:        tmp_org_sigma3   = X->Def.CisAjtCkuAlvDC[i][5];
expec_cisajscktaltdc.c:        tmp_org_isite4   = X->Def.CisAjtCkuAlvDC[i][6]+1;
expec_cisajscktaltdc.c:        tmp_org_sigma4   = X->Def.CisAjtCkuAlvDC[i][7];
expec_cisajscktaltdc.c:        if(org_isite1 >X->Def.Nsite && org_isite3>X->Def.Nsite){
expec_cisajscktaltdc.c:                is1_up = X->Def.Tpow[org_isite1 - 1];
expec_cisajscktaltdc.c:                is2_up = X->Def.Tpow[org_isite3 - 1];
expec_cisajscktaltdc.c:                is1_up = X->Def.Tpow[org_isite1 - 1];
expec_cisajscktaltdc.c:        else if(org_isite1 > X->Def.Nsite || org_isite3>X->Def.Nsite){
expec_cisajscktaltdc.c:                is1_up = X->Def.Tpow[org_isite1 - 1];
expec_cisajscktaltdc.c:                is2_up = X->Def.Tpow[org_isite3 - 1];
expec_cisajscktaltdc.c:            isA_up = X->Def.Tpow[org_isite1-1];
expec_cisajscktaltdc.c:            isB_up = X->Def.Tpow[org_isite3-1];
expec_cisajscktaltdc.c:    i_max=X->Check.idim_max;
expec_cisajscktaltdc.c:    X->Large.mode=M_CORR;
expec_cisajscktaltdc.c:    for(i=0;i<X->Def.NCisAjtCkuAlvDC;i++){
expec_cisajscktaltdc.c:        tmp_org_isite1   = X->Def.CisAjtCkuAlvDC[i][0]+1;
expec_cisajscktaltdc.c:        tmp_org_sigma1   = X->Def.CisAjtCkuAlvDC[i][1];
expec_cisajscktaltdc.c:        tmp_org_isite2   = X->Def.CisAjtCkuAlvDC[i][2]+1;
expec_cisajscktaltdc.c:        tmp_org_sigma2   = X->Def.CisAjtCkuAlvDC[i][3];
expec_cisajscktaltdc.c:        tmp_org_isite3   = X->Def.CisAjtCkuAlvDC[i][4]+1;
expec_cisajscktaltdc.c:        tmp_org_sigma3   = X->Def.CisAjtCkuAlvDC[i][5];
expec_cisajscktaltdc.c:        tmp_org_isite4   = X->Def.CisAjtCkuAlvDC[i][6]+1;
expec_cisajscktaltdc.c:        tmp_org_sigma4   = X->Def.CisAjtCkuAlvDC[i][7];
expec_cisajscktaltdc.c:        tmp_org = X->Def.CisAjtCkuAlvDC[i][4*j+1]*X->Def.Tpow[X->Def.CisAjtCkuAlvDC[i][4 * j]];
expec_cisajscktaltdc.c:        tmp_Sz += GetLocal2Sz(X->Def.CisAjtCkuAlvDC[i][4 * j] + 1, tmp_org, X->Def.SiteToBit, X->Def.Tpow);
expec_cisajscktaltdc.c:        tmp_org = X->Def.CisAjtCkuAlvDC[i][4*j+3]*X->Def.Tpow[X->Def.CisAjtCkuAlvDC[i][4 * j+2]];
expec_cisajscktaltdc.c:        tmp_Sz -= GetLocal2Sz(X->Def.CisAjtCkuAlvDC[i][4 * j+2] + 1, tmp_org, X->Def.SiteToBit, X->Def.Tpow);
expec_cisajscktaltdc.c:        if(org_isite1 >X->Def.Nsite && org_isite3>X->Def.Nsite){
expec_cisajscktaltdc.c:        else if(org_isite3 > X->Def.Nsite || org_isite1 > X->Def.Nsite){
expec_cisajscktaltdc.c:                    num1=BitCheckGeneral(list_1[j], org_isite1, org_sigma1, X->Def.SiteToBit, X->Def.Tpow);
expec_cisajscktaltdc.c:                        num1=BitCheckGeneral(list_1[j], org_isite3, org_sigma3, X->Def.SiteToBit, X->Def.Tpow);
expec_cisajscktaltdc.c:                  num1 = GetOffCompGeneralSpin(list_1[j], org_isite3, org_sigma4, org_sigma3, &tmp_off, X->Def.SiteToBit, X->Def.Tpow);
expec_cisajscktaltdc.c:                                                 X->Def.SiteToBit, X->Def.Tpow);
expec_cisajscktaltdc.c:                      ConvertToList1GeneralSpin(tmp_off_2, X->Check.sdim, &list1_off);
expec_cisajscktaltdc.c:    if (X->Def.iFlgGeneralSpin == FALSE) {
expec_cisajscktaltdc.c:    i_max=X->Check.idim_max;
expec_cisajscktaltdc.c:    for(i=0;i<X->Def.NCisAjtCkuAlvDC;i++){
expec_cisajscktaltdc.c:        tmp_org_isite1   = X->Def.CisAjtCkuAlvDC[i][0]+1;
expec_cisajscktaltdc.c:        tmp_org_sigma1   = X->Def.CisAjtCkuAlvDC[i][1];
expec_cisajscktaltdc.c:        tmp_org_isite2   = X->Def.CisAjtCkuAlvDC[i][2]+1;
expec_cisajscktaltdc.c:        tmp_org_sigma2   = X->Def.CisAjtCkuAlvDC[i][3];
expec_cisajscktaltdc.c:        tmp_org_isite3   = X->Def.CisAjtCkuAlvDC[i][4]+1;
expec_cisajscktaltdc.c:        tmp_org_sigma3   = X->Def.CisAjtCkuAlvDC[i][5];
expec_cisajscktaltdc.c:        tmp_org_isite4   = X->Def.CisAjtCkuAlvDC[i][6]+1;
expec_cisajscktaltdc.c:        tmp_org_sigma4   = X->Def.CisAjtCkuAlvDC[i][7];
expec_cisajscktaltdc.c:        if(org_isite1>X->Def.Nsite && org_isite3>X->Def.Nsite){ //org_isite3 >= org_isite1 > Nsite
expec_cisajscktaltdc.c:        else if(org_isite3>X->Def.Nsite || org_isite1>X->Def.Nsite){ //org_isite3 > Nsite >= org_isite1
expec_cisajscktaltdc.c:                isA_up = X->Def.Tpow[org_isite2-1];
expec_cisajscktaltdc.c:                isB_up = X->Def.Tpow[org_isite4-1];
expec_cisajscktaltdc.c:    i_max=X->Check.idim_max;
expec_cisajscktaltdc.c:    X->Large.mode=M_CORR;
expec_cisajscktaltdc.c:  for(i=0;i<X->Def.NCisAjtCkuAlvDC;i++){
expec_cisajscktaltdc.c:        tmp_org_isite1   = X->Def.CisAjtCkuAlvDC[i][0]+1;
expec_cisajscktaltdc.c:        tmp_org_sigma1   = X->Def.CisAjtCkuAlvDC[i][1];
expec_cisajscktaltdc.c:        tmp_org_isite2   = X->Def.CisAjtCkuAlvDC[i][2]+1;
expec_cisajscktaltdc.c:        tmp_org_sigma2   = X->Def.CisAjtCkuAlvDC[i][3];
expec_cisajscktaltdc.c:        tmp_org_isite3   = X->Def.CisAjtCkuAlvDC[i][4]+1;
expec_cisajscktaltdc.c:        tmp_org_sigma3   = X->Def.CisAjtCkuAlvDC[i][5];
expec_cisajscktaltdc.c:        tmp_org_isite4   = X->Def.CisAjtCkuAlvDC[i][6]+1;
expec_cisajscktaltdc.c:        tmp_org_sigma4   = X->Def.CisAjtCkuAlvDC[i][7];
expec_cisajscktaltdc.c:      if(org_isite1 > X->Def.Nsite && org_isite3 > X->Def.Nsite){
expec_cisajscktaltdc.c:        else if(org_isite3 > X->Def.Nsite || org_isite1 > X->Def.Nsite){
expec_cisajscktaltdc.c:                    num1=BitCheckGeneral(j-1, org_isite1, org_sigma1, X->Def.SiteToBit, X->Def.Tpow);
expec_cisajscktaltdc.c:                        num1=BitCheckGeneral(j-1, org_isite3, org_sigma3, X->Def.SiteToBit, X->Def.Tpow);
expec_cisajscktaltdc.c:                    num1 = GetOffCompGeneralSpin(j-1, org_isite3, org_sigma4, org_sigma3, &tmp_off, X->Def.SiteToBit, X->Def.Tpow);
expec_cisajscktaltdc.c:                        num1=BitCheckGeneral(tmp_off, org_isite1, org_sigma1, X->Def.SiteToBit, X->Def.Tpow);
expec_cisajscktaltdc.c:                    num1 = BitCheckGeneral(j-1, org_isite3, org_sigma3, X->Def.SiteToBit, X->Def.Tpow);
expec_cisajscktaltdc.c:                        num1 = GetOffCompGeneralSpin(j-1, org_isite1, org_sigma2, org_sigma1, &tmp_off, X->Def.SiteToBit, X->Def.Tpow);
expec_cisajscktaltdc.c:                    num1 = GetOffCompGeneralSpin(j-1, org_isite3, org_sigma4, org_sigma3, &tmp_off, X->Def.SiteToBit, X->Def.Tpow);
expec_cisajscktaltdc.c:                        num1 = GetOffCompGeneralSpin(tmp_off, org_isite1, org_sigma2, org_sigma1, &tmp_off_2, X->Def.SiteToBit, X->Def.Tpow);
expec_energy_flct.c:  switch(X->Def.iCalcType){
expec_energy_flct.c:  i_max=X->Check.idim_max;      
expec_energy_flct.c:  if(GetSplitBitByModel(X->Def.Nsite, X->Def.iCalcModel, &irght, &ilft, &ihfbit)!=0){
expec_energy_flct.c:  X->Large.i_max    = i_max;
expec_energy_flct.c:  X->Large.irght    = irght;
expec_energy_flct.c:  X->Large.ilft     = ilft;
expec_energy_flct.c:  X->Large.ihfbit   = ihfbit;
expec_energy_flct.c:  X->Large.mode     = M_ENERGY;
expec_energy_flct.c:  X->Phys.energy=0.0;
expec_energy_flct.c:  if(X->Def.iCalcType == Lanczos){
expec_energy_flct.c:  else if (X->Def.iCalcType == TPQCalc){
expec_energy_flct.c:  switch(X->Def.iCalcModel){
expec_energy_flct.c:  if(X->Def.iFlgGeneralSpin == FALSE) {
expec_energy_flct.c:    if(X->Def.iFlgGeneralSpin == FALSE){
expec_energy_flct.c:      X->Phys.doublon   = 0.0;
expec_energy_flct.c:      X->Phys.doublon2  = 0.0;
expec_energy_flct.c:      X->Phys.num       = X->Def.NsiteMPI;
expec_energy_flct.c:      X->Phys.num2      = X->Def.NsiteMPI*X->Def.NsiteMPI;
expec_energy_flct.c:      X->Phys.Sz        = 0.5 * (double)X->Def.Total2SzMPI;
expec_energy_flct.c:      X->Phys.Sz2       = X->Phys.Sz * X->Phys.Sz;
expec_energy_flct.c:  if(X->Def.iCalcType == Lanczos){
expec_energy_flct.c:  else if (X->Def.iCalcType == TPQCalc){
expec_energy_flct.c:  X->Phys.energy = dam_pr;
expec_energy_flct.c:  X->Phys.var    = dam_pr1;
expec_energy_flct.c:  switch(X->Def.iCalcType) {
expec_energy_flct.c:    i_max=X->Check.idim_max;
expec_energy_flct.c:    for (isite1 = 1; isite1 <= X->Def.NsiteMPI; isite1++) {
expec_energy_flct.c:        if (isite1 > X->Def.Nsite) {
expec_energy_flct.c:            is1_up_a += X->Def.Tpow[2 * isite1 - 2];
expec_energy_flct.c:            is1_down_a += X->Def.Tpow[2 * isite1 - 1];
expec_energy_flct.c:            is1_up_b += X->Def.Tpow[2 * isite1 - 2];
expec_energy_flct.c:            is1_down_b += X->Def.Tpow[2 * isite1 - 1];
expec_energy_flct.c:// isite1 > X->Def.Nsite
expec_energy_flct.c:// isite1 <= X->Def.Nsite
expec_energy_flct.c:    X->Phys.doublon   = tmp_D;
expec_energy_flct.c:    X->Phys.doublon2  = tmp_D2;
expec_energy_flct.c:    X->Phys.num       = tmp_N;
expec_energy_flct.c:    X->Phys.num2      = tmp_N2;
expec_energy_flct.c:    X->Phys.Sz        = tmp_Sz*0.5;
expec_energy_flct.c:    X->Phys.Sz2       = tmp_Sz2*0.25;
expec_energy_flct.c:    X->Phys.num_up    = 0.5*(tmp_N+tmp_Sz);
expec_energy_flct.c:    X->Phys.num_down  = 0.5*(tmp_N-tmp_Sz);
expec_energy_flct.c:    i_max=X->Check.idim_max;
expec_energy_flct.c:    for(isite1=1;isite1<=X->Def.NsiteMPI;isite1++){
expec_energy_flct.c:        if(isite1 > X->Def.Nsite){
expec_energy_flct.c:            is1_up_a   += X->Def.Tpow[2*isite1 - 2];
expec_energy_flct.c:            is1_down_a += X->Def.Tpow[2*isite1 - 1];
expec_energy_flct.c:            is1_up_b   += X->Def.Tpow[2*isite1 - 2];
expec_energy_flct.c:            is1_down_b += X->Def.Tpow[2*isite1 - 1];
expec_energy_flct.c:// isite1 > X->Def.Nsite
expec_energy_flct.c:// isite1 <= X->Def.Nsite
expec_energy_flct.c:    X->Phys.doublon   = tmp_D;
expec_energy_flct.c:    X->Phys.doublon2  = tmp_D2;
expec_energy_flct.c:    X->Phys.num       = tmp_N;
expec_energy_flct.c:    X->Phys.num2      = tmp_N2;
expec_energy_flct.c:    X->Phys.Sz        = tmp_Sz*0.5;
expec_energy_flct.c:    X->Phys.Sz2       = tmp_Sz2*0.25;
expec_energy_flct.c:    X->Phys.num_up    = 0.5*(tmp_N+tmp_Sz);
expec_energy_flct.c:    X->Phys.num_down  = 0.5*(tmp_N-tmp_Sz);
expec_energy_flct.c:    i_max=X->Check.idim_max;
expec_energy_flct.c:    for(isite1=1;isite1<=X->Def.NsiteMPI;isite1++){
expec_energy_flct.c:        if(isite1 > X->Def.Nsite){
expec_energy_flct.c:            is1_up_a += X->Def.Tpow[isite1 - 1];
expec_energy_flct.c:            is1_up_b += X->Def.Tpow[isite1 - 1];
expec_energy_flct.c:// isite1 > X->Def.Nsite
expec_energy_flct.c:// isite1 <= X->Def.Nsite
expec_energy_flct.c:        Sz      = 2*Sz-X->Def.NsiteMPI;
expec_energy_flct.c:    X->Phys.doublon   = 0.0;
expec_energy_flct.c:    X->Phys.doublon2  = 0.0;
expec_energy_flct.c:    X->Phys.num       = X->Def.NsiteMPI;
expec_energy_flct.c:    X->Phys.num2      = X->Def.NsiteMPI*X->Def.NsiteMPI;
expec_energy_flct.c:    X->Phys.Sz        = tmp_Sz*0.5;
expec_energy_flct.c:    X->Phys.Sz2       = tmp_Sz2*0.25;
expec_energy_flct.c:    X->Phys.num_up    = 0.5*(X->Def.NsiteMPI+tmp_Sz);
expec_energy_flct.c:    X->Phys.num_down  = 0.5*(X->Def.NsiteMPI-tmp_Sz);
expec_energy_flct.c:    i_max=X->Check.idim_max;
expec_energy_flct.c:        for(isite1=1;isite1<=X->Def.NsiteMPI;isite1++){
expec_energy_flct.c:            if(isite1 > X->Def.Nsite){
expec_energy_flct.c:                Sz += GetLocal2Sz(isite1, myrank, X->Def.SiteToBit, X->Def.Tpow);
expec_energy_flct.c:                Sz += GetLocal2Sz(isite1, j-1, X->Def.SiteToBit, X->Def.Tpow);
expec_energy_flct.c:    X->Phys.doublon   = 0.0;
expec_energy_flct.c:    X->Phys.doublon2  = 0.0;
expec_energy_flct.c:    X->Phys.num       = X->Def.NsiteMPI;
expec_energy_flct.c:    X->Phys.num2      = X->Def.NsiteMPI*X->Def.NsiteMPI;
expec_energy_flct.c:    X->Phys.Sz        = tmp_Sz*0.5;
expec_energy_flct.c:    X->Phys.Sz2       = tmp_Sz2*0.25;
expec_energy_flct.c:    X->Phys.num_up    = 0.5*(X->Def.NsiteMPI+tmp_Sz);
expec_energy_flct.c:    X->Phys.num_down  = 0.5*(X->Def.NsiteMPI-tmp_Sz);
expec_energy_flct.c:  i_max=X->Check.idim_max;
expec_energy_flct.c:  for(isite1=1;isite1<=X->Def.NsiteMPI;isite1++){
expec_energy_flct.c:    if(isite1 > X->Def.Nsite){
expec_energy_flct.c:      is1_up_a += X->Def.Tpow[isite1 - 1];
expec_energy_flct.c:      is1_up_b += X->Def.Tpow[isite1 - 1];
expec_energy_flct.c:// isite1 > X->Def.Nsite
expec_energy_flct.c:// isite1 <= X->Def.Nsite
expec_energy_flct.c:    Sz      = 2*Sz-X->Def.NsiteMPI;
expec_energy_flct.c:  X->Phys.doublon   = 0.0;
expec_energy_flct.c:  X->Phys.doublon2  = 0.0;
expec_energy_flct.c:  X->Phys.num       = X->Def.NsiteMPI;
expec_energy_flct.c:  X->Phys.num2      = X->Def.NsiteMPI*X->Def.NsiteMPI;
expec_energy_flct.c:  X->Phys.Sz        = tmp_Sz*0.5;
expec_energy_flct.c:  X->Phys.Sz2       = tmp_Sz2*0.25;
expec_energy_flct.c:  X->Phys.num_up    = 0.5*(X->Def.NsiteMPI+tmp_Sz);
expec_energy_flct.c:  X->Phys.num_down  = 0.5*(X->Def.NsiteMPI-tmp_Sz);
expec_energy_flct.c:  i_max=X->Check.idim_max;
expec_energy_flct.c:    for(isite1=1;isite1<=X->Def.NsiteMPI;isite1++){
expec_energy_flct.c:      if(isite1 > X->Def.Nsite){
expec_energy_flct.c:        Sz += GetLocal2Sz(isite1, myrank, X->Def.SiteToBit, X->Def.Tpow);
expec_energy_flct.c:        Sz += GetLocal2Sz(isite1, tmp_list1, X->Def.SiteToBit, X->Def.Tpow);
expec_energy_flct.c:  X->Phys.doublon   = 0.0;
expec_energy_flct.c:  X->Phys.doublon2  = 0.0;
expec_energy_flct.c:  X->Phys.num       = X->Def.NsiteMPI;
expec_energy_flct.c:  X->Phys.num2      = X->Def.NsiteMPI*X->Def.NsiteMPI;
expec_energy_flct.c:  X->Phys.Sz        = tmp_Sz*0.5;
expec_energy_flct.c:  X->Phys.Sz2       = tmp_Sz2*0.25;
expec_energy_flct.c:  X->Phys.num_up    = 0.5*(X->Def.NsiteMPI+tmp_Sz);
expec_energy_flct.c:  X->Phys.num_down  = 0.5*(X->Def.NsiteMPI-tmp_Sz);
expec_totalspin.c:  X->Large.mode = M_TOTALS;
expec_totalspin.c:  switch(X->Def.iCalcModel){
expec_totalspin.c:     X->Phys.Sz=X->Def.Total2SzMPI/2.;
expec_totalspin.c:    X->Phys.s2=0.0;
expec_totalspin.c:    X->Phys.Sz=0.0;
expec_totalspin.c:	i_max = X->Check.idim_max;
expec_totalspin.c:	GetSplitBitByModel(X->Def.Nsite, X->Def.iCalcModel, &irght, &ilft, &ihfbit);
expec_totalspin.c:	for (isite1 = 1; isite1 <= X->Def.NsiteMPI; isite1++) {
expec_totalspin.c:		is1_up = X->Def.Tpow[2 * isite1 - 2];
expec_totalspin.c:		is1_down = X->Def.Tpow[2 * isite1 - 1];
expec_totalspin.c:		for (isite2 = 1; isite2 <= X->Def.NsiteMPI; isite2++) {
expec_totalspin.c:			is2_up = X->Def.Tpow[2 * isite2 - 2];
expec_totalspin.c:			is2_down = X->Def.Tpow[2 * isite2 - 1];
expec_totalspin.c:	X->Phys.s2 = creal(spn);
expec_totalspin.c:	X->Phys.Sz = creal(spn_z);
expec_totalspin.c:  i_max = X->Check.idim_max;
expec_totalspin.c:  for (isite1 = 1; isite1 <= X->Def.NsiteMPI; isite1++) {
expec_totalspin.c:    for (isite2 = 1; isite2 <= X->Def.NsiteMPI; isite2++) {
expec_totalspin.c:      is1_up = X->Def.Tpow[2 * isite1 - 2];
expec_totalspin.c:      is1_down = X->Def.Tpow[2 * isite1 - 1];
expec_totalspin.c:      is2_up = X->Def.Tpow[2 * isite2 - 2];
expec_totalspin.c:      is2_down = X->Def.Tpow[2 * isite2 - 1];
expec_totalspin.c:  X->Phys.s2 = creal(spn);
expec_totalspin.c:  X->Phys.Sz = creal(spn_z);
expec_totalspin.c:	i_max = X->Check.idim_max;
expec_totalspin.c:	if (X->Def.iFlgGeneralSpin == FALSE) {
expec_totalspin.c:		GetSplitBitByModel(X->Def.Nsite, X->Def.iCalcModel, &irght, &ilft, &ihfbit);
expec_totalspin.c:		for (isite1 = 1; isite1 <= X->Def.NsiteMPI; isite1++) {
expec_totalspin.c:			for (isite2 = 1; isite2 <= X->Def.NsiteMPI; isite2++) {
expec_totalspin.c:				if (isite1 > X->Def.Nsite && isite2 > X->Def.Nsite) {
expec_totalspin.c:					is1_up = X->Def.Tpow[isite1 - 1];
expec_totalspin.c:					is2_up = X->Def.Tpow[isite2 - 1];
expec_totalspin.c:				} else if (isite1 > X->Def.Nsite || isite2 > X->Def.Nsite) {
expec_totalspin.c:					is1_up = X->Def.Tpow[tmp_isite1 - 1];
expec_totalspin.c:					is2_up = X->Def.Tpow[tmp_isite2 - 1];
expec_totalspin.c:					is1_up = X->Def.Tpow[isite1 - 1];
expec_totalspin.c:					is2_up = X->Def.Tpow[isite2 - 1];
expec_totalspin.c:		for (isite1 = 1; isite1 <= X->Def.NsiteMPI; isite1++) {
expec_totalspin.c:			for (isite2 = 1; isite2 <= X->Def.NsiteMPI; isite2++) {
expec_totalspin.c:				S1 = 0.5 * (X->Def.SiteToBit[isite1 - 1] - 1);
expec_totalspin.c:				S2 = 0.5 * (X->Def.SiteToBit[isite2 - 1] - 1);
expec_totalspin.c:						spn_z1 = 0.5 * GetLocal2Sz(isite1, list_1[j], X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:						spn_z1 = 0.5 * GetLocal2Sz(isite1, list_1[j], X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:						spn_z2 = 0.5 * GetLocal2Sz(isite2, list_1[j], X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:						sigma_1 = GetBitGeneral(isite1, list_1[j], X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:						sigma_2 = GetBitGeneral(isite2, list_1[j], X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:						ibit_tmp = GetOffCompGeneralSpin(list_1[j], isite2, sigma_2, sigma_2 + 1, &off, X->Def.SiteToBit,
expec_totalspin.c:																						 X->Def.Tpow);
expec_totalspin.c:							ibit_tmp = GetOffCompGeneralSpin(off, isite1, sigma_1, sigma_1 - 1, &off_2, X->Def.SiteToBit,
expec_totalspin.c:																							 X->Def.Tpow);
expec_totalspin.c:								ConvertToList1GeneralSpin(off_2, X->Check.sdim, &off);
expec_totalspin.c:						ibit_tmp = GetOffCompGeneralSpin(list_1[j], isite2, sigma_2, sigma_2 - 1, &off, X->Def.SiteToBit,
expec_totalspin.c:																						 X->Def.Tpow);
expec_totalspin.c:							ibit_tmp = GetOffCompGeneralSpin(off, isite1, sigma_1, sigma_1 + 1, &off_2, X->Def.SiteToBit,
expec_totalspin.c:																							 X->Def.Tpow);
expec_totalspin.c:								ConvertToList1GeneralSpin(off_2, X->Check.sdim, &off);
expec_totalspin.c:	X->Phys.s2 = creal(spn);
expec_totalspin.c:	X->Phys.Sz = creal(spn_z);
expec_totalspin.c:  i_max=X->Check.idim_max;
expec_totalspin.c:  X->Large.mode = M_TOTALS;
expec_totalspin.c:  if(X->Def.iFlgGeneralSpin==FALSE){
expec_totalspin.c:    for(isite1=1;isite1<=X->Def.NsiteMPI;isite1++){
expec_totalspin.c:      if(isite1 > X->Def.Nsite){
expec_totalspin.c:  is1_up      = X->Def.Tpow[isite1-1];
expec_totalspin.c:  is1_up      = X->Def.Tpow[isite1-1];
expec_totalspin.c:      for(isite2=1;isite2<=X->Def.NsiteMPI;isite2++){
expec_totalspin.c:  if(isite1 > X->Def.Nsite && isite2 > X->Def.Nsite){
expec_totalspin.c:    is1_up      = X->Def.Tpow[isite1-1];
expec_totalspin.c:    is2_up      = X->Def.Tpow[isite2-1];
expec_totalspin.c:  else if(isite1 > X->Def.Nsite || isite2 > X->Def.Nsite){
expec_totalspin.c:    is1_up = X->Def.Tpow[tmp_isite1 - 1];
expec_totalspin.c:    is2_up = X->Def.Tpow[tmp_isite2 - 1];
expec_totalspin.c:    is2_up      = X->Def.Tpow[isite2-1];
expec_totalspin.c:    for(isite1=1;isite1<=X->Def.NsiteMPI;isite1++){
expec_totalspin.c:      S1=0.5*(X->Def.SiteToBit[isite1-1]-1);
expec_totalspin.c:      if(isite1 > X->Def.Nsite){
expec_totalspin.c:  spn_z1  = 0.5*GetLocal2Sz(isite1, (unsigned long int) myrank, X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:    spn_z1  = 0.5*GetLocal2Sz(isite1, j-1, X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:      for(isite2=1;isite2<=X->Def.NsiteMPI;isite2++){
expec_totalspin.c:  S2=0.5*(X->Def.SiteToBit[isite2-1]-1);
expec_totalspin.c:  if(isite1 > X->Def.Nsite && isite2 > X->Def.Nsite){
expec_totalspin.c:    spn_z1  = 0.5*GetLocal2Sz(isite1, (unsigned long int) myrank, X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:    spn_z2  = 0.5*GetLocal2Sz(isite2, (unsigned long int) myrank, X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:  else if(isite1 > X->Def.Nsite || isite2 > X->Def.Nsite){
expec_totalspin.c:   spn_z2  = 0.5*GetLocal2Sz(tmp_isite2, (unsigned long int) myrank, X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:   sigma_2 = GetBitGeneral(tmp_isite2, (unsigned long int) myrank, X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:      spn_z1  = 0.5*GetLocal2Sz(isite1, j-1, X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:      spn_z2  = 0.5*GetLocal2Sz(isite2, j-1, X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:      sigma_1=GetBitGeneral(isite1, j-1, X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:      sigma_2=GetBitGeneral(isite2, j-1, X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:      ibit_tmp = GetOffCompGeneralSpin(j-1, isite2, sigma_2, sigma_2+1, &off, X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:        ibit_tmp = GetOffCompGeneralSpin(off, isite1, sigma_1, sigma_1-1,&off_2, X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:      ibit_tmp = GetOffCompGeneralSpin(j-1, isite2, sigma_2, sigma_2-1, &off, X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:        ibit_tmp = GetOffCompGeneralSpin(off, isite1, sigma_1, sigma_1+1, &off_2, X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:  X->Phys.s2=creal(spn+spn_d);
expec_totalspin.c:  X->Phys.Sz=creal(spn_z);
expec_totalspin.c:	X->Large.mode = M_TOTALS;
expec_totalspin.c:	switch (X->Def.iCalcModel) {
expec_totalspin.c:			X->Phys.Sz = X->Def.Total2SzMPI / 2.;
expec_totalspin.c:			X->Phys.Sz = X->Def.Total2SzMPI / 2.;
expec_totalspin.c:			X->Phys.Sz = 0.0;
expec_totalspin.c:	i_max = X->Check.idim_max;
expec_totalspin.c:	for (isite1 = 1; isite1 <= X->Def.NsiteMPI; isite1++) {
expec_totalspin.c:		if (isite1 > X->Def.Nsite) {
expec_totalspin.c:			is1_up = X->Def.Tpow[2 * isite1 - 2];
expec_totalspin.c:			is1_down = X->Def.Tpow[2 * isite1 - 1];
expec_totalspin.c:		} else {//isite1 > X->Def.Nsite
expec_totalspin.c:			is1_up = X->Def.Tpow[2 * isite1 - 2];
expec_totalspin.c:			is1_down = X->Def.Tpow[2 * isite1 - 1];
expec_totalspin.c:	X->Phys.Sz = creal(spn_z);
expec_totalspin.c:	i_max = X->Check.idim_max;
expec_totalspin.c:	X->Large.mode = M_TOTALS;
expec_totalspin.c:	if (X->Def.iFlgGeneralSpin == FALSE) {
expec_totalspin.c:		for (isite1 = 1; isite1 <= X->Def.NsiteMPI; isite1++) {
expec_totalspin.c:			if (isite1 > X->Def.Nsite) {
expec_totalspin.c:				is1_up = X->Def.Tpow[isite1 - 1];
expec_totalspin.c:				is1_up = X->Def.Tpow[isite1 - 1];
expec_totalspin.c:		for (isite1 = 1; isite1 <= X->Def.NsiteMPI; isite1++) {
expec_totalspin.c:			if (isite1 > X->Def.Nsite) {
expec_totalspin.c:				spn_z1 = 0.5 * GetLocal2Sz(isite1, (unsigned long int) myrank, X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:					spn_z1 = 0.5 * GetLocal2Sz(isite1, j - 1, X->Def.SiteToBit, X->Def.Tpow);
expec_totalspin.c:	X->Phys.Sz = creal(spn_z);
input.c:  long int imax = X->Check.idim_max;
input.c:  sprintf(sdt,cFileNamePhys_FullDiag_Ham, X->Def.CDataFileHead);
lapack_diag.c:  i_max = X->Check.idim_max;
lapack_diag.c:  if (X->Def.iNGPU == 0) {
lapack_diag.c:    if(diag_magma_cmp(xMsize, Ham, v0, L_vec, X->Def.iNGPU) != 0) {
log.c:  sprintf(sdt, cFileName, X->Def.CDataFileHead);
log.c:  sprintf(sdt, cFileName, X->Def.CDataFileHead);
log.c:  sprintf(sdt, cFileName, X->Def.CDataFileHead);
makeHam.c:	i_max = X->Check.idim_max;
makeHam.c:	if (GetSplitBitByModel(X->Def.Nsite, X->Def.iCalcModel, &irght, &ilft, &ihfbit) != 0) {
makeHam.c:	X->Large.i_max = i_max;
makeHam.c:	X->Large.irght = irght;
makeHam.c:	X->Large.ilft = ilft;
makeHam.c:	X->Large.ihfbit = ihfbit;
makeHam.c:	X->Large.prdct = 0.0;
makeHam.c:	X->Large.mode = M_Ham;
makeHam.c:	switch (X->Def.iCalcModel) {
makeHam.c:			for (i = 0; i < X->Def.EDNTransfer / 2; i++) {
makeHam.c:					isite1 = X->Def.EDGeneralTransfer[idx][0] + 1;
makeHam.c:					isite2 = X->Def.EDGeneralTransfer[idx][2] + 1;
makeHam.c:					sigma1 = X->Def.EDGeneralTransfer[idx][1];
makeHam.c:					sigma2 = X->Def.EDGeneralTransfer[idx][3];
makeHam.c:					tmp_trans = -X->Def.EDParaGeneralTransfer[idx];
makeHam.c:					for (j = 1; j <= X->Large.i_max; j++) {
makeHam.c:									GC_CisAjt(j, v0, v1, X, X->Large.is1_spin, X->Large.is2_spin, X->Large.isA_spin, X->Large.A_spin,
makeHam.c:			for (i = 0; i < X->Def.NInterAll_OffDiagonal / 2; i++) {
makeHam.c:					isite1 = X->Def.InterAll_OffDiagonal[idx][0] + 1;
makeHam.c:					isite2 = X->Def.InterAll_OffDiagonal[idx][2] + 1;
makeHam.c:					isite3 = X->Def.InterAll_OffDiagonal[idx][4] + 1;
makeHam.c:					isite4 = X->Def.InterAll_OffDiagonal[idx][6] + 1;
makeHam.c:					sigma1 = X->Def.InterAll_OffDiagonal[idx][1];
makeHam.c:					sigma2 = X->Def.InterAll_OffDiagonal[idx][3];
makeHam.c:					sigma3 = X->Def.InterAll_OffDiagonal[idx][5];
makeHam.c:					sigma4 = X->Def.InterAll_OffDiagonal[idx][7];
makeHam.c:					tmp_V = X->Def.ParaInterAll_OffDiagonal[idx];
makeHam.c:					i_max = X->Large.i_max;
makeHam.c:					isite1 = X->Large.is1_spin;
makeHam.c:					isite2 = X->Large.is2_spin;
makeHam.c:					Asum = X->Large.isA_spin;
makeHam.c:					Adiff = X->Large.A_spin;
makeHam.c:					isite3 = X->Large.is3_spin;
makeHam.c:					isite4 = X->Large.is4_spin;
makeHam.c:					Bsum = X->Large.isB_spin;
makeHam.c:					Bdiff = X->Large.B_spin;
makeHam.c:					tmp_V = X->Large.tmp_V;
makeHam.c:			for (i = 0; i < X->Def.NPairHopping / 2; i++) {
makeHam.c:					for (j = 1; j <= X->Large.i_max; j++) {
makeHam.c:			for (i = 0; i < X->Def.NExchangeCoupling; i++) {
makeHam.c:				for (j = 1; j <= X->Large.i_max; j++) {
makeHam.c:			for (i = 0; i < X->Def.EDNTransfer / 2; i++) {
makeHam.c:					isite1 = X->Def.EDGeneralTransfer[idx][0] + 1;
makeHam.c:					isite2 = X->Def.EDGeneralTransfer[idx][2] + 1;
makeHam.c:					sigma1 = X->Def.EDGeneralTransfer[idx][1];
makeHam.c:					sigma2 = X->Def.EDGeneralTransfer[idx][3];
makeHam.c:					tmp_trans = -X->Def.EDParaGeneralTransfer[idx];
makeHam.c:					for (j = 1; j <= X->Large.i_max; j++) {
makeHam.c:									X_CisAjt(list_1[j], X, X->Large.is1_spin, X->Large.is2_spin, X->Large.isA_spin, X->Large.A_spin,
makeHam.c:			for (i = 0; i < X->Def.NInterAll_OffDiagonal / 2; i++) {
makeHam.c:					isite1 = X->Def.InterAll_OffDiagonal[idx][0] + 1;
makeHam.c:					isite2 = X->Def.InterAll_OffDiagonal[idx][2] + 1;
makeHam.c:					isite3 = X->Def.InterAll_OffDiagonal[idx][4] + 1;
makeHam.c:					isite4 = X->Def.InterAll_OffDiagonal[idx][6] + 1;
makeHam.c:					sigma1 = X->Def.InterAll_OffDiagonal[idx][1];
makeHam.c:					sigma2 = X->Def.InterAll_OffDiagonal[idx][3];
makeHam.c:					sigma3 = X->Def.InterAll_OffDiagonal[idx][5];
makeHam.c:					sigma4 = X->Def.InterAll_OffDiagonal[idx][7];
makeHam.c:					tmp_V = X->Def.ParaInterAll_OffDiagonal[idx];
makeHam.c:					i_max = X->Large.i_max;
makeHam.c:					isite1 = X->Large.is1_spin;
makeHam.c:					isite2 = X->Large.is2_spin;
makeHam.c:					Asum = X->Large.isA_spin;
makeHam.c:					Adiff = X->Large.A_spin;
makeHam.c:					isite3 = X->Large.is3_spin;
makeHam.c:					isite4 = X->Large.is4_spin;
makeHam.c:					Bsum = X->Large.isB_spin;
makeHam.c:					Bdiff = X->Large.B_spin;
makeHam.c:					tmp_V = X->Large.tmp_V;
makeHam.c:			for (i = 0; i < X->Def.NPairHopping / 2; i++) {
makeHam.c:					for (j = 1; j <= X->Large.i_max; j++) {
makeHam.c:			for (i = 0; i < X->Def.NExchangeCoupling; i++) {
makeHam.c:				for (j = 1; j <= X->Large.i_max; j++) {
makeHam.c:			if (X->Def.iFlgGeneralSpin == FALSE) {
makeHam.c:				for (i = 0; i < X->Def.EDNTransfer / 2; i++) {
makeHam.c:						isite1 = X->Def.EDGeneralTransfer[idx][0] + 1;
makeHam.c:						isite2 = X->Def.EDGeneralTransfer[idx][2] + 1;
makeHam.c:						sigma1 = X->Def.EDGeneralTransfer[idx][1];
makeHam.c:						sigma2 = X->Def.EDGeneralTransfer[idx][3];
makeHam.c:						tmp_trans = -X->Def.EDParaGeneralTransfer[idx];
makeHam.c:							is1_spin = X->Def.Tpow[isite1 - 1];
makeHam.c:								is1_spin = X->Def.Tpow[isite1 - 1];
makeHam.c:				for (i = 0; i < X->Def.NInterAll_OffDiagonal / 2; i++) {
makeHam.c:						isite1 = X->Def.InterAll_OffDiagonal[idx][0] + 1;
makeHam.c:						isite2 = X->Def.InterAll_OffDiagonal[idx][4] + 1;
makeHam.c:						sigma1 = X->Def.InterAll_OffDiagonal[idx][1];
makeHam.c:						sigma2 = X->Def.InterAll_OffDiagonal[idx][3];
makeHam.c:						sigma3 = X->Def.InterAll_OffDiagonal[idx][5];
makeHam.c:						sigma4 = X->Def.InterAll_OffDiagonal[idx][7];
makeHam.c:						tmp_V = X->Def.ParaInterAll_OffDiagonal[idx];
makeHam.c:						isA_up = X->Def.Tpow[isite1 - 1];
makeHam.c:						isB_up = X->Def.Tpow[isite2 - 1];
makeHam.c:				for (i = 0; i < X->Def.NExchangeCoupling; i++) {
makeHam.c:					for (j = 1; j <= X->Large.i_max; j++) {
makeHam.c:				for (i = 0; i < X->Def.NPairLiftCoupling / 2; i++) {
makeHam.c:						for (j = 1; j <= X->Large.i_max; j++) {
makeHam.c:				for (i = 0; i < X->Def.EDNTransfer / 2; i++) {
makeHam.c:						isite1 = X->Def.EDGeneralTransfer[idx][0] + 1;
makeHam.c:						isite2 = X->Def.EDGeneralTransfer[idx][2] + 1;
makeHam.c:						sigma1 = X->Def.EDGeneralTransfer[idx][1];
makeHam.c:						sigma2 = X->Def.EDGeneralTransfer[idx][3];
makeHam.c:						tmp_trans = -X->Def.EDParaGeneralTransfer[idx];
makeHam.c:								num1 = GetOffCompGeneralSpin(j - 1, isite1, sigma2, sigma1, &off, X->Def.SiteToBit, X->Def.Tpow);
makeHam.c:				for (i = 0; i < X->Def.NInterAll_OffDiagonal / 2; i++) {
makeHam.c:						isite1 = X->Def.InterAll_OffDiagonal[idx][0] + 1;
makeHam.c:						isite2 = X->Def.InterAll_OffDiagonal[idx][4] + 1;
makeHam.c:						sigma1 = X->Def.InterAll_OffDiagonal[idx][1];
makeHam.c:						sigma2 = X->Def.InterAll_OffDiagonal[idx][3];
makeHam.c:						sigma3 = X->Def.InterAll_OffDiagonal[idx][5];
makeHam.c:						sigma4 = X->Def.InterAll_OffDiagonal[idx][7];
makeHam.c:						tmp_V = X->Def.ParaInterAll_OffDiagonal[idx];
makeHam.c:							num1 = GetOffCompGeneralSpin(j - 1, isite1, sigma2, sigma1, &tmp_off, X->Def.SiteToBit, X->Def.Tpow);
makeHam.c:								num1 = GetOffCompGeneralSpin(tmp_off, isite2, sigma4, sigma3, &off, X->Def.SiteToBit, X->Def.Tpow);
makeHam.c:			if (X->Def.iFlgGeneralSpin == FALSE) {
makeHam.c:				for (i = 0; i < X->Def.NInterAll_OffDiagonal / 2; i++) {
makeHam.c:						isite1 = X->Def.InterAll_OffDiagonal[idx][0] + 1;
makeHam.c:						isite2 = X->Def.InterAll_OffDiagonal[idx][4] + 1;
makeHam.c:						sigma1 = X->Def.InterAll_OffDiagonal[idx][1];
makeHam.c:						sigma2 = X->Def.InterAll_OffDiagonal[idx][3];
makeHam.c:						sigma3 = X->Def.InterAll_OffDiagonal[idx][5];
makeHam.c:						sigma4 = X->Def.InterAll_OffDiagonal[idx][7];
makeHam.c:						tmp_V = X->Def.ParaInterAll_OffDiagonal[idx];
makeHam.c:						isA_up = X->Large.is1_up;
makeHam.c:						isB_up = X->Large.is2_up;
makeHam.c:				for (i = 0; i < X->Def.NExchangeCoupling; i++) {
makeHam.c:					for (j = 1; j <= X->Large.i_max; j++) {
makeHam.c:				for (i = 0; i < X->Def.NInterAll_OffDiagonal / 2; i++) {
makeHam.c:						isite1 = X->Def.InterAll_OffDiagonal[idx][0] + 1;
makeHam.c:						isite2 = X->Def.InterAll_OffDiagonal[idx][4] + 1;
makeHam.c:						sigma1 = X->Def.InterAll_OffDiagonal[idx][1];
makeHam.c:						sigma2 = X->Def.InterAll_OffDiagonal[idx][3];
makeHam.c:						sigma3 = X->Def.InterAll_OffDiagonal[idx][5];
makeHam.c:						sigma4 = X->Def.InterAll_OffDiagonal[idx][7];
makeHam.c:						tmp_V = X->Def.ParaInterAll_OffDiagonal[idx];
makeHam.c:							num1 = GetOffCompGeneralSpin(list_1[j], isite1, sigma2, sigma1, &tmp_off, X->Def.SiteToBit, X->Def.Tpow);
makeHam.c:								num1 = GetOffCompGeneralSpin(tmp_off, isite2, sigma4, sigma3, &off, X->Def.SiteToBit, X->Def.Tpow);
makeHam.c:									ConvertToList1GeneralSpin(off, X->Check.sdim, &tmp_off);
mltply.c:  i_max = X->Check.idim_max;
mltply.c:  X->Large.prdct = 0.0;
mltply.c:    if (X->Def.iFlgGeneralSpin == FALSE) {
mltply.c:      if (GetSplitBitByModel(X->Def.Nsite, X->Def.iCalcModel, &irght, &ilft, &ihfbit) != 0) {
mltply.c:      if(X->Def.iCalcModel==Spin){
mltply.c:        if (GetSplitBitForGeneralSpin(X->Def.Nsite, &ihfbit, X->Def.SiteToBit) != 0) {
mltply.c:  X->Large.i_max = i_max;
mltply.c:  X->Large.irght = irght;
mltply.c:  X->Large.ilft = ilft;
mltply.c:  X->Large.ihfbit = ihfbit;
mltply.c:  X->Large.mode = M_MLTPLY;
mltply.c:  X->Large.prdct += dam_pr;
mltply.c:  if (X->Def.iCalcType == TimeEvolution) diagonalcalcForTE(step_i, X, tmp_v0, tmp_v1);
mltply.c:  switch (X->Def.iCalcModel) {
mltply.c:  X->Large.prdct = SumMPI_dc(X->Large.prdct);  
mltplyHubbard.c:  for (i = 0; i < X->Def.EDNTransfer; i+=2) {
mltplyHubbard.c:    if (X->Def.EDGeneralTransfer[i][0] + 1 > X->Def.Nsite &&
mltplyHubbard.c:        X->Def.EDGeneralTransfer[i][2] + 1 > X->Def.Nsite) {
mltplyHubbard.c:    else if (X->Def.EDGeneralTransfer[i][2] + 1 > X->Def.Nsite) {
mltplyHubbard.c:    else if (X->Def.EDGeneralTransfer[i][0] + 1 > X->Def.Nsite) {
mltplyHubbard.c:        isite1 = X->Def.EDGeneralTransfer[idx][0] + 1;
mltplyHubbard.c:        isite2 = X->Def.EDGeneralTransfer[idx][2] + 1;
mltplyHubbard.c:        sigma1 = X->Def.EDGeneralTransfer[idx][1];
mltplyHubbard.c:        sigma2 = X->Def.EDGeneralTransfer[idx][3];
mltplyHubbard.c:        tmp_trans = -X->Def.EDParaGeneralTransfer[idx];
mltplyHubbard.c:        X->Large.tmp_trans = tmp_trans;
mltplyHubbard.c:        X->Large.prdct += dam_pr;
mltplyHubbard.c:  }/*for (i = 0; i < X->Def.EDNTransfer; i+=2)*/
mltplyHubbard.c:  for (i = 0; i < X->Def.NInterAll_OffDiagonal; i+=2) {
mltplyHubbard.c:    isite1 = X->Def.InterAll_OffDiagonal[i][0] + 1;
mltplyHubbard.c:    isite2 = X->Def.InterAll_OffDiagonal[i][2] + 1;
mltplyHubbard.c:    isite3 = X->Def.InterAll_OffDiagonal[i][4] + 1;
mltplyHubbard.c:    isite4 = X->Def.InterAll_OffDiagonal[i][6] + 1;
mltplyHubbard.c:    sigma1 = X->Def.InterAll_OffDiagonal[i][1];
mltplyHubbard.c:    sigma2 = X->Def.InterAll_OffDiagonal[i][3];
mltplyHubbard.c:    sigma3 = X->Def.InterAll_OffDiagonal[i][5];
mltplyHubbard.c:    sigma4 = X->Def.InterAll_OffDiagonal[i][7];
mltplyHubbard.c:    tmp_V = X->Def.ParaInterAll_OffDiagonal[i];
mltplyHubbard.c:      ibitsite1 = X->Def.OrgTpow[2*isite1-2+sigma1] ;
mltplyHubbard.c:      ibitsite2 = X->Def.OrgTpow[2 * isite2 - 2 + sigma2];
mltplyHubbard.c:      ibitsite3 = X->Def.OrgTpow[2 * isite3 - 2 + sigma3];
mltplyHubbard.c:      ibitsite4 = X->Def.OrgTpow[2 * isite4 - 2 + sigma4];
mltplyHubbard.c:        isite1 = X->Def.InterAll_OffDiagonal[idx][0] + 1;
mltplyHubbard.c:        isite2 = X->Def.InterAll_OffDiagonal[idx][2] + 1;
mltplyHubbard.c:        isite3 = X->Def.InterAll_OffDiagonal[idx][4] + 1;
mltplyHubbard.c:        isite4 = X->Def.InterAll_OffDiagonal[idx][6] + 1;
mltplyHubbard.c:        sigma1 = X->Def.InterAll_OffDiagonal[idx][1];
mltplyHubbard.c:        sigma2 = X->Def.InterAll_OffDiagonal[idx][3];
mltplyHubbard.c:        sigma3 = X->Def.InterAll_OffDiagonal[idx][5];
mltplyHubbard.c:        sigma4 = X->Def.InterAll_OffDiagonal[idx][7];
mltplyHubbard.c:        tmp_V = X->Def.ParaInterAll_OffDiagonal[idx];
mltplyHubbard.c:    X->Large.prdct += dam_pr;
mltplyHubbard.c:  }/*for (i = 0; i < X->Def.NInterAll_OffDiagonal; i+=2)*/
mltplyHubbard.c:  for (i = 0; i < X->Def.NPairHopping; i +=2) {
mltplyHubbard.c:    if ( X->Def.PairHopping[i][0] + 1 > X->Def.Nsite 
mltplyHubbard.c:      || X->Def.PairHopping[i][1] + 1 > X->Def.Nsite)
mltplyHubbard.c:        X->Def.PairHopping[i][0], sigma1, X->Def.PairHopping[i][1], sigma1, 
mltplyHubbard.c:        X->Def.PairHopping[i][0], sigma2, X->Def.PairHopping[i][1], sigma2, 
mltplyHubbard.c:        X->Def.ParaPairHopping[i], X, tmp_v0, tmp_v1);
mltplyHubbard.c:    X->Large.prdct += dam_pr;
mltplyHubbard.c:  }/*for (i = 0; i < X->Def.NPairHopping; i += 2)*/
mltplyHubbard.c:  for (i = 0; i < X->Def.NExchangeCoupling; i ++) {
mltplyHubbard.c:    if (X->Def.ExchangeCoupling[i][0] + 1 > X->Def.Nsite ||
mltplyHubbard.c:        X->Def.ExchangeCoupling[i][1] + 1 > X->Def.Nsite) 
mltplyHubbard.c:        X->Def.ExchangeCoupling[i][0], sigma1, X->Def.ExchangeCoupling[i][1], sigma1,
mltplyHubbard.c:        X->Def.ExchangeCoupling[i][1], sigma2, X->Def.ExchangeCoupling[i][0], sigma2,
mltplyHubbard.c:        X->Def.ParaExchangeCoupling[i], X, tmp_v0, tmp_v1);
mltplyHubbard.c:    X->Large.prdct += dam_pr;
mltplyHubbard.c:  }/*for (i = 0; i < X->Def.NExchangeCoupling; i ++)*/
mltplyHubbard.c:  for (i = 0; i < X->Def.EDNTransfer; i += 2) {
mltplyHubbard.c:    if (X->Def.EDGeneralTransfer[i][0] + 1 > X->Def.Nsite &&
mltplyHubbard.c:        X->Def.EDGeneralTransfer[i][2] + 1 > X->Def.Nsite) {
mltplyHubbard.c:    else if (X->Def.EDGeneralTransfer[i][2] + 1 > X->Def.Nsite){
mltplyHubbard.c:    else if (X->Def.EDGeneralTransfer[i][0] + 1 > X->Def.Nsite) {
mltplyHubbard.c:        isite1 = X->Def.EDGeneralTransfer[idx][0] + 1;
mltplyHubbard.c:        isite2 = X->Def.EDGeneralTransfer[idx][2] + 1;
mltplyHubbard.c:        sigma1 = X->Def.EDGeneralTransfer[idx][1];
mltplyHubbard.c:        sigma2 = X->Def.EDGeneralTransfer[idx][3];
mltplyHubbard.c:        tmp_trans = -X->Def.EDParaGeneralTransfer[idx];
mltplyHubbard.c:        X->Large.prdct += dam_pr;
mltplyHubbard.c:  }/*for (i = 0; i < X->Def.EDNTransfer; i += 2)*/
mltplyHubbard.c:  for (i = 0; i < X->Def.NInterAll_OffDiagonal; i+=2) {
mltplyHubbard.c:    isite1 = X->Def.InterAll_OffDiagonal[i][0] + 1;
mltplyHubbard.c:    isite2 = X->Def.InterAll_OffDiagonal[i][2] + 1;
mltplyHubbard.c:    isite3 = X->Def.InterAll_OffDiagonal[i][4] + 1;
mltplyHubbard.c:    isite4 = X->Def.InterAll_OffDiagonal[i][6] + 1;
mltplyHubbard.c:    sigma1 = X->Def.InterAll_OffDiagonal[i][1];
mltplyHubbard.c:    sigma2 = X->Def.InterAll_OffDiagonal[i][3];
mltplyHubbard.c:    sigma3 = X->Def.InterAll_OffDiagonal[i][5];
mltplyHubbard.c:    sigma4 = X->Def.InterAll_OffDiagonal[i][7];
mltplyHubbard.c:    tmp_V = X->Def.ParaInterAll_OffDiagonal[i];
mltplyHubbard.c:      ibitsite1 = X->Def.OrgTpow[2 * isite1 - 2 + sigma1];
mltplyHubbard.c:      ibitsite2 = X->Def.OrgTpow[2 * isite2 - 2 + sigma2];
mltplyHubbard.c:      ibitsite3 = X->Def.OrgTpow[2 * isite3 - 2 + sigma3];
mltplyHubbard.c:      ibitsite4 = X->Def.OrgTpow[2 * isite4 - 2 + sigma4];
mltplyHubbard.c:        isite1 = X->Def.InterAll_OffDiagonal[idx][0] + 1;
mltplyHubbard.c:        isite2 = X->Def.InterAll_OffDiagonal[idx][2] + 1;
mltplyHubbard.c:        isite3 = X->Def.InterAll_OffDiagonal[idx][4] + 1;
mltplyHubbard.c:        isite4 = X->Def.InterAll_OffDiagonal[idx][6] + 1;
mltplyHubbard.c:        sigma1 = X->Def.InterAll_OffDiagonal[idx][1];
mltplyHubbard.c:        sigma2 = X->Def.InterAll_OffDiagonal[idx][3];
mltplyHubbard.c:        sigma3 = X->Def.InterAll_OffDiagonal[idx][5];
mltplyHubbard.c:        sigma4 = X->Def.InterAll_OffDiagonal[idx][7];
mltplyHubbard.c:        tmp_V = X->Def.ParaInterAll_OffDiagonal[idx];
mltplyHubbard.c:    X->Large.prdct += dam_pr;
mltplyHubbard.c:  }/*for (i = 0; i < X->Def.NInterAll_OffDiagonal; i+=2)*/
mltplyHubbard.c:  for (i = 0; i < X->Def.NPairHopping; i +=2) {
mltplyHubbard.c:    if ( X->Def.PairHopping[i][0] + 1 > X->Def.Nsite
mltplyHubbard.c:      || X->Def.PairHopping[i][1] + 1 > X->Def.Nsite) 
mltplyHubbard.c:        X->Def.PairHopping[i][0], sigma1, X->Def.PairHopping[i][1], sigma1,
mltplyHubbard.c:        X->Def.PairHopping[i][0], sigma2, X->Def.PairHopping[i][1], sigma2,
mltplyHubbard.c:        X->Def.ParaPairHopping[i], X, tmp_v0, tmp_v1);
mltplyHubbard.c:    X->Large.prdct += dam_pr;
mltplyHubbard.c:  }/*for (i = 0; i < X->Def.NPairHopping; i += 2)*/
mltplyHubbard.c:  for (i = 0; i < X->Def.NExchangeCoupling; i++) {
mltplyHubbard.c:    if ( X->Def.ExchangeCoupling[i][0] + 1 > X->Def.Nsite
mltplyHubbard.c:      || X->Def.ExchangeCoupling[i][1] + 1 > X->Def.Nsite) 
mltplyHubbard.c:        X->Def.ExchangeCoupling[i][0], sigma1, X->Def.ExchangeCoupling[i][1], sigma1,
mltplyHubbard.c:        X->Def.ExchangeCoupling[i][1], sigma2, X->Def.ExchangeCoupling[i][0], sigma2,
mltplyHubbard.c:        X->Def.ParaExchangeCoupling[i], X, tmp_v0, tmp_v1);
mltplyHubbard.c:    X->Large.prdct += dam_pr;
mltplyHubbard.c:  }/*for (i = 0; i < X->Def.NExchangeCoupling; i++)*/
mltplyHubbard.c:  long unsigned int i_max = X->Large.i_max;
mltplyHubbard.c:  long unsigned int i_max = X->Large.i_max;
mltplyHubbard.c:  long unsigned int i_max = X->Large.i_max;
mltplyHubbard.c:  isite1 = X->Large.is1_spin;
mltplyHubbard.c:  isite2 = X->Large.is2_spin;
mltplyHubbard.c:  Asum = X->Large.isA_spin;
mltplyHubbard.c:  Adiff = X->Large.A_spin;
mltplyHubbard.c:  long unsigned int i_max = X->Large.i_max;
mltplyHubbard.c:  isite1 = X->Large.is1_spin;
mltplyHubbard.c:  isite2 = X->Large.is2_spin;
mltplyHubbard.c:  Asum = X->Large.isA_spin;
mltplyHubbard.c:  Adiff = X->Large.A_spin;
mltplyHubbard.c:  i_max = X->Large.i_max;
mltplyHubbard.c:  isite1 = X->Large.is1_spin;
mltplyHubbard.c:  isite2 = X->Large.is2_spin;
mltplyHubbard.c:  Asum = X->Large.isA_spin;
mltplyHubbard.c:  Adiff = X->Large.A_spin;
mltplyHubbard.c:  isite3 = X->Large.is3_spin;
mltplyHubbard.c:  isite4 = X->Large.is4_spin;
mltplyHubbard.c:  Bsum = X->Large.isB_spin;
mltplyHubbard.c:  Bdiff = X->Large.B_spin;
mltplyHubbard.c:  tmp_V = X->Large.tmp_V;
mltplyHubbard.c:  i_max = X->Large.i_max;
mltplyHubbard.c:  isite1 = X->Large.is1_spin;
mltplyHubbard.c:  isite2 = X->Large.is2_spin;
mltplyHubbard.c:  Asum = X->Large.isA_spin;
mltplyHubbard.c:  Adiff = X->Large.A_spin;
mltplyHubbard.c:  isite3 = X->Large.is3_spin;
mltplyHubbard.c:  isite4 = X->Large.is4_spin;
mltplyHubbard.c:  Bsum = X->Large.isB_spin;
mltplyHubbard.c:  Bdiff = X->Large.B_spin;
mltplyHubbard.c:  tmp_V = X->Large.tmp_V;
mltplyHubbard.c:  long unsigned int i_max = X->Large.i_max;
mltplyHubbard.c:  long unsigned int i_max = X->Large.i_max;
mltplyHubbardCore.c:  X->Large.is1_spin = X->Def.Tpow[2 * isite1 - 2 + sigma1];
mltplyHubbardCore.c:  X->Large.is2_spin = X->Def.Tpow[2 * isite2 - 2 + sigma2];
mltplyHubbardCore.c:    X->Large.A_spin = (X->Def.Tpow[2 * isite1 - 2 + sigma1] - X->Def.Tpow[2 * isite2 - 1 + sigma2]);
mltplyHubbardCore.c:    X->Large.A_spin = (X->Def.Tpow[2 * isite2 - 2 + sigma2] - X->Def.Tpow[2 * isite1 - 1 + sigma1]);
mltplyHubbardCore.c:      X->Large.A_spin = (X->Def.Tpow[2 * isite1 - 2 + sigma1] - X->Def.Tpow[2 * isite2 - 1 + sigma2]);
mltplyHubbardCore.c:      X->Large.A_spin = (X->Def.Tpow[2 * isite2 - 2 + sigma2] - X->Def.Tpow[2 * isite1 - 1 + sigma1]);
mltplyHubbardCore.c:  X->Large.isA_spin = X->Large.is1_spin + X->Large.is2_spin;
mltplyHubbardCore.c:  is1_spin = X->Def.Tpow[2 * isite1 - 2 + sigma1];
mltplyHubbardCore.c:  is2_spin = X->Def.Tpow[2 * isite2 - 2 + sigma2];
mltplyHubbardCore.c:    A_spin = (X->Def.Tpow[2 * isite1 - 2 + sigma1] - X->Def.Tpow[2 * isite2 - 1 + sigma2]);
mltplyHubbardCore.c:    A_spin = (X->Def.Tpow[2 * isite2 - 2 + sigma2] - X->Def.Tpow[2 * isite1 - 1 + sigma1]);
mltplyHubbardCore.c:      A_spin = (X->Def.Tpow[2 * isite1 - 2 + sigma1] - X->Def.Tpow[2 * isite2 - 1 + sigma2]);
mltplyHubbardCore.c:      A_spin = (X->Def.Tpow[2 * isite2 - 2 + sigma2] - X->Def.Tpow[2 * isite1 - 1 + sigma1]);
mltplyHubbardCore.c:  is3_spin = X->Def.Tpow[2 * isite3 - 2 + sigma3];
mltplyHubbardCore.c:  is4_spin = X->Def.Tpow[2 * isite4 - 2 + sigma4];
mltplyHubbardCore.c:    B_spin = (X->Def.Tpow[2 * isite3 - 2 + sigma3] - X->Def.Tpow[2 * isite4 - 1 + sigma4]);
mltplyHubbardCore.c:    B_spin = (X->Def.Tpow[2 * isite4 - 2 + sigma4] - X->Def.Tpow[2 * isite3 - 1 + sigma3]);
mltplyHubbardCore.c:      B_spin = (X->Def.Tpow[2 * isite3 - 2 + sigma3] - X->Def.Tpow[2 * isite4 - 1 + sigma4]);
mltplyHubbardCore.c:      B_spin = (X->Def.Tpow[2 * isite4 - 2 + sigma4] - X->Def.Tpow[2 * isite3 - 1 + sigma3]);
mltplyHubbardCore.c:  X->Large.is1_spin = is1_spin;
mltplyHubbardCore.c:  X->Large.is2_spin = is2_spin;
mltplyHubbardCore.c:  X->Large.is3_spin = is3_spin;
mltplyHubbardCore.c:  X->Large.is4_spin = is4_spin;
mltplyHubbardCore.c:  X->Large.isA_spin = isA_spin;
mltplyHubbardCore.c:  X->Large.isB_spin = isB_spin;
mltplyHubbardCore.c:  X->Large.A_spin = A_spin;
mltplyHubbardCore.c:  X->Large.B_spin = B_spin;
mltplyHubbardCore.c:  X->Large.tmp_V = tmp_V;
mltplyHubbardCore.c:  X->Large.isite1 = isite1;
mltplyHubbardCore.c:  X->Large.isite2 = isite2;
mltplyHubbardCore.c:  X->Large.isite3 = isite3;
mltplyHubbardCore.c:  X->Large.isite4 = isite4;
mltplyHubbardCore.c:  int isite1 = X->Def.PairHopping[iPairHopp][0] + 1;
mltplyHubbardCore.c:  int isite2 = X->Def.PairHopping[iPairHopp][1] + 1;
mltplyHubbardCore.c:  X->Large.tmp_J = X->Def.ParaPairHopping[iPairHopp];
mltplyHubbardCore.c:  X->Large.is1_up = X->Def.Tpow[2 * isite1 - 2];
mltplyHubbardCore.c:  X->Large.is1_down = X->Def.Tpow[2 * isite1 - 1];
mltplyHubbardCore.c:  X->Large.is2_up = X->Def.Tpow[2 * isite2 - 2];
mltplyHubbardCore.c:  X->Large.is2_down = X->Def.Tpow[2 * isite2 - 1];
mltplyHubbardCore.c:  int isite1 = X->Def.ExchangeCoupling[iExchange][0] + 1;
mltplyHubbardCore.c:  int isite2 = X->Def.ExchangeCoupling[iExchange][1] + 1;
mltplyHubbardCore.c:  X->Large.tmp_J = -X->Def.ParaExchangeCoupling[iExchange];
mltplyHubbardCore.c:  X->Large.is1_up = X->Def.Tpow[2 * isite1 - 2];
mltplyHubbardCore.c:  X->Large.is1_down = X->Def.Tpow[2 * isite1 - 1];
mltplyHubbardCore.c:  X->Large.is2_up = X->Def.Tpow[2 * isite2 - 2];
mltplyHubbardCore.c:  X->Large.is2_down = X->Def.Tpow[2 * isite2 - 1];
mltplyHubbardCore.c:  if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyHubbardCore.c:  }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyHubbardCore.c:  if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyHubbardCore.c:  }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyHubbardCore.c:    if(GetOffComp(list_2_1, list_2_2, iexchg, X->Large.irght, X->Large.ilft, X->Large.ihfbit, &off)==FALSE){
mltplyHubbardCore.c:    if(X->Large.mode==M_CORR){
mltplyHubbardCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyHubbardCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyHubbardCore.c:    if(GetOffComp(list_2_1, list_2_2, *tmp_off, X->Large.irght, X->Large.ilft, X->Large.ihfbit, &off)!=TRUE){
mltplyHubbardCore.c:  long unsigned int is1_up = X->Large.is1_up;
mltplyHubbardCore.c:  long unsigned int is2_up = X->Large.is2_up;
mltplyHubbardCore.c:  long unsigned int is1_down = X->Large.is1_down;
mltplyHubbardCore.c:  long unsigned int is2_down = X->Large.is2_down;
mltplyHubbardCore.c:  long unsigned int irght = X->Large.irght;
mltplyHubbardCore.c:  long unsigned int ilft = X->Large.ilft;
mltplyHubbardCore.c:  long unsigned int ihfbit = X->Large.ihfbit;
mltplyHubbardCore.c:  double complex tmp_J = X->Large.tmp_J;
mltplyHubbardCore.c:  int mode = X->Large.mode;
mltplyHubbardCore.c:  long unsigned int is1_up = X->Large.is1_up;
mltplyHubbardCore.c:  long unsigned int is2_up = X->Large.is2_up;
mltplyHubbardCore.c:  long unsigned int is1_down = X->Large.is1_down;
mltplyHubbardCore.c:  long unsigned int is2_down = X->Large.is2_down;
mltplyHubbardCore.c:  long unsigned int irght = X->Large.irght;
mltplyHubbardCore.c:  long unsigned int ilft = X->Large.ilft;
mltplyHubbardCore.c:  long unsigned int ihfbit = X->Large.ihfbit;
mltplyHubbardCore.c:  double complex tmp_J = X->Large.tmp_J;
mltplyHubbardCore.c:  int mode = X->Large.mode;
mltplyHubbardCore.c:    if (mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyHubbardCore.c:  long unsigned int is1_up = X->Large.is1_up;
mltplyHubbardCore.c:  long unsigned int is2_up = X->Large.is2_up;
mltplyHubbardCore.c:  long unsigned int is1_down = X->Large.is1_down;
mltplyHubbardCore.c:  long unsigned int is2_down = X->Large.is2_down;
mltplyHubbardCore.c:  double complex tmp_J = X->Large.tmp_J;
mltplyHubbardCore.c:  int mode = X->Large.mode;
mltplyHubbardCore.c:  long unsigned int is1_up = X->Large.is1_up;
mltplyHubbardCore.c:  long unsigned int is2_up = X->Large.is2_up;
mltplyHubbardCore.c:  long unsigned int is1_down = X->Large.is1_down;
mltplyHubbardCore.c:  long unsigned int is2_down = X->Large.is2_down;
mltplyHubbardCore.c:  double complex tmp_J = X->Large.tmp_J;
mltplyHubbardCore.c:  int mode = X->Large.mode;
mltplyHubbardCore.c:    if (mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyHubbardCore.c:  if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyHubbardCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyHubbardCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyHubbardCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyHubbardCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyHubbardCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyHubbardCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyHubbardCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyHubbardCore.c:    //if (X->Large.mode == M_MLTPLY) { // for multply
mltplyHubbardCore.c:    //if (X->Large.mode == M_MLTPLY) { // for multply
mltplyMPIBoost.c:  i_max = X->Check.idim_max;
mltplyMPIBoost.c:  //defmodelBoost(X->Boost.W0, X->Boost.R0, X->Boost.num_pivot, X->Boost.ishift_nspin, X->Boost.list_6spin_star, X->Boost.list_6spin_pair, 1, X->Boost.arrayJ, X->Boost.vecB);
mltplyMPIBoost.c:  for(iloop=0; iloop < X->Boost.R0; iloop++){
mltplyMPIBoost.c:    for(j=iloop*X->Boost.num_pivot; j < (iloop+1)*X->Boost.num_pivot; j++){
mltplyMPIBoost.c:      num_J_star = (long unsigned int)X->Boost.list_6spin_star[j][0]; //(0,j) 
mltplyMPIBoost.c:      ishift1    = (long unsigned int)X->Boost.list_6spin_star[j][1]; //(1,j) 
mltplyMPIBoost.c:      ishift2    = (long unsigned int)X->Boost.list_6spin_star[j][2]; //(2,j) 
mltplyMPIBoost.c:      ishift3    = (long unsigned int)X->Boost.list_6spin_star[j][3]; //(3,j)
mltplyMPIBoost.c:      ishift4    = (long unsigned int)X->Boost.list_6spin_star[j][4]; //(4,j)
mltplyMPIBoost.c:      ishift5    = (long unsigned int)X->Boost.list_6spin_star[j][5]; //(5,j)
mltplyMPIBoost.c:      pivot_flag = (long unsigned int)X->Boost.list_6spin_star[j][6]; //(6,j)
mltplyMPIBoost.c:        mi   = (long unsigned int)X->Boost.list_6spin_pair[j][0][ell]; //(1,ell,j)
mltplyMPIBoost.c:        mj   = (long unsigned int)X->Boost.list_6spin_pair[j][1][ell]; //(2,ell,j)
mltplyMPIBoost.c:        mri  = (long unsigned int)X->Boost.list_6spin_pair[j][2][ell]; //(3,ell,j)
mltplyMPIBoost.c:        mrj  = (long unsigned int)X->Boost.list_6spin_pair[j][3][ell]; //(4,ell,j)
mltplyMPIBoost.c:        mrk  = (long unsigned int)X->Boost.list_6spin_pair[j][4][ell]; //(5,ell,j)
mltplyMPIBoost.c:        mrl  = (long unsigned int)X->Boost.list_6spin_pair[j][5][ell]; //(6,ell,j)
mltplyMPIBoost.c:        indj = X->Boost.list_6spin_pair[j][6][ell]; //(7,ell,j)
mltplyMPIBoost.c:            vecJ[i1][i2] = X->Boost.arrayJ[(indj-1)][i1][i2];
mltplyMPIBoost.c:        matB[0][0] = + X->Boost.vecB[2]; // -BM
mltplyMPIBoost.c:        matB[1][1] = - X->Boost.vecB[2]; // -BM
mltplyMPIBoost.c:        matB[0][1] = - X->Boost.vecB[0] + I*X->Boost.vecB[1]; // -BM
mltplyMPIBoost.c:        matB[1][0] = - X->Boost.vecB[0] - I*X->Boost.vecB[1]; // -BM
mltplyMPIBoost.c:            for(ellj2=0; ellj2<X->Boost.ishift_nspin; ellj2++){
mltplyMPIBoost.c:        iomp=i_max/(int)pow(2.0,X->Boost.ishift_nspin);
mltplyMPIBoost.c:          for(ell4 = 0; ell4 < (int)pow(2.0,X->Boost.ishift_nspin); ell4++){
mltplyMPIBoost.c:            tmp_v0[(1 + ell5+(i_max/(int)pow(2.0,X->Boost.ishift_nspin))*ell4)] = tmp_v1[(1 + ell4+((int)pow(2.0,X->Boost.ishift_nspin))*ell5)];
mltplyMPIBoost.c:        iomp=i_max/(int)pow(2.0,X->Boost.ishift_nspin);
mltplyMPIBoost.c:          for(ell4 = 0; ell4 < (int)pow(2.0,X->Boost.ishift_nspin); ell4++){
mltplyMPIBoost.c:            tmp_v1[(1 + ell5+(i_max/(int)pow(2.0,X->Boost.ishift_nspin))*ell4)] = tmp_v3[(1 + ell4+((int)pow(2.0,X->Boost.ishift_nspin))*ell5)];
mltplyMPIBoost.c:    iomp=(int)pow(2.0,X->Boost.W0)/nproc;
mltplyMPIBoost.c:    //for(ell4 = 0; ell4 < (int)pow(2.0,X->Boost.W0)/nproc; ell4++ ){
mltplyMPIBoost.c:        for(ell6 = 0; ell6 < (int)(i_max/(int)pow(2.0,X->Boost.W0)); ell6++ ){
mltplyMPIBoost.c:          tmp_v1[(1 + ell6+ell5*i_max/(int)pow(2.0,X->Boost.W0)+ell4*i_max/((int)pow(2.0,X->Boost.W0)/nproc))] = tmp_v3[(1 + ell6+ell4*i_max/(int)pow(2.0,X->Boost.W0)+ell5*i_max/nproc)];
mltplyMPIBoost.c:          tmp_v0[(1 + ell6+ell5*i_max/(int)pow(2.0,X->Boost.W0)+ell4*i_max/((int)pow(2.0,X->Boost.W0)/nproc))] = tmp_v2[(1 + ell6+ell4*i_max/(int)pow(2.0,X->Boost.W0)+ell5*i_max/nproc)];
mltplyMPIBoost.c:  X->Large.prdct += dam_pr;
mltplyMPIHubbard.c:    X->Def.EDGeneralTransfer[itrans][0], X->Def.EDGeneralTransfer[itrans][1],
mltplyMPIHubbard.c:    X->Def.EDGeneralTransfer[itrans][2], X->Def.EDGeneralTransfer[itrans][3],
mltplyMPIHubbard.c:    X->Def.EDParaGeneralTransfer[itrans], X, tmp_v0, tmp_v1);
mltplyMPIHubbard.c:  X->Large.prdct += dam_pr;
mltplyMPIHubbard.c:  mask1 = (int)X->Def.Tpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbard.c:  mask2 = (int)X->Def.Tpow[2 * org_isite2 + org_ispin2];
mltplyMPIHubbard.c:    if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) trans = 0.0;
mltplyMPIHubbard.c:  ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPIHubbard.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPIHubbard.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbard.c:    }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbard.c:  mask1 = (int) X->Def.Tpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbard.c:  mask2 = (int) X->Def.Tpow[2 * org_isite2 + org_ispin2];
mltplyMPIHubbard.c:    if (X->Large.mode == M_CORR|| X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbard.c:  ierr = MPI_Sendrecv(&X->Check.idim_maxOrg, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPIHubbard.c:  ierr = MPI_Sendrecv(list_1_org, X->Check.idim_maxOrg + 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPIHubbard.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_maxOrg + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPIHubbard.c:  if (X->Large.mode == M_MLTPLY|| X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbard.c:                 X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPIHubbard.c:  }/*if (X->Large.mode == M_MLTPLY|| X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbard.c:    X->Def.EDGeneralTransfer[itrans][0], X->Def.EDGeneralTransfer[itrans][1],
mltplyMPIHubbard.c:    X->Def.EDGeneralTransfer[itrans][2], X->Def.EDGeneralTransfer[itrans][3],
mltplyMPIHubbard.c:    X->Def.EDParaGeneralTransfer[itrans], X, tmp_v0, tmp_v1       );
mltplyMPIHubbard.c:  X->Large.prdct += dam_pr;
mltplyMPIHubbard.c:  mask2 = (int) X->Def.Tpow[2 * org_isite2 + org_ispin2];
mltplyMPIHubbard.c:  ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPIHubbard.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPIHubbard.c:  mask1 = X->Def.Tpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbard.c:    if (X->Large.mode == M_CORR|| X->Large.mode == M_CALCSPEC) trans = 0;
mltplyMPIHubbard.c:  bit1diff = X->Def.Tpow[2 * X->Def.Nsite - 1] * 2 - mask1 * 2;
mltplyMPIHubbard.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbard.c:    }/*if (X->Large.mode == M_MLTPLY|| X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbard.c:    }/*if (! (X->Large.mode == M_MLTPLY|| X->Large.mode == M_CALCSPEC))*/
mltplyMPIHubbard.c:    X->Def.EDGeneralTransfer[itrans][0], X->Def.EDGeneralTransfer[itrans][1],
mltplyMPIHubbard.c:    X->Def.EDGeneralTransfer[itrans][2], X->Def.EDGeneralTransfer[itrans][3],
mltplyMPIHubbard.c:    X->Def.EDParaGeneralTransfer[itrans], X, tmp_v0, tmp_v1);
mltplyMPIHubbard.c:  X->Large.prdct += dam_pr;
mltplyMPIHubbard.c:  mask1 = (int) X->Def.Tpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbard.c:  mask2 = (int) X->Def.Tpow[2 * org_isite2 + org_ispin2];
mltplyMPIHubbard.c:    if (X->Large.mode == M_CORR|| X->Large.mode == M_CALCSPEC) trans = 0;
mltplyMPIHubbard.c:  ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPIHubbard.c:  ierr = MPI_Sendrecv(list_1, X->Check.idim_max + 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPIHubbard.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPIHubbard.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbard.c:          X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPIHubbard.c:    }/*if (X->Large.mode == M_MLTPLY|| X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbard.c:          X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPIHubbard.c:    X->Def.EDGeneralTransfer[itrans][0], X->Def.EDGeneralTransfer[itrans][1],
mltplyMPIHubbard.c:    X->Def.EDGeneralTransfer[itrans][2], X->Def.EDGeneralTransfer[itrans][3],
mltplyMPIHubbard.c:    X->Def.EDParaGeneralTransfer[itrans], X, tmp_v0, tmp_v1);
mltplyMPIHubbard.c:  X->Large.prdct += dam_pr;
mltplyMPIHubbard.c:  mask2 = (int)X->Def.Tpow[2 * org_isite2+org_ispin2];
mltplyMPIHubbard.c:  ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPIHubbard.c:  ierr = MPI_Sendrecv(list_1, X->Check.idim_max + 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPIHubbard.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPIHubbard.c:  mask1 = X->Def.Tpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbard.c:    if (X->Large.mode == M_CORR|| X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbard.c:  bit1diff = X->Def.Tpow[2 * X->Def.Nsite - 1] * 2 - mask1 * 2;
mltplyMPIHubbard.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbard.c:            X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPIHubbard.c:    }/*if (X->Large.mode == M_MLTPLY|| X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbard.c:            X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPIHubbard.c:          if(X->Large.mode==M_CORR){
mltplyMPIHubbard.c:    }/*if (! (X->Large.mode == M_MLTPLY|| X->Large.mode == M_CALCSPEC))*/
mltplyMPIHubbard.c:  mask2 = (int)X->Def.Tpow[2 * org_isite2+org_ispin2];
mltplyMPIHubbard.c:  ierr = MPI_Sendrecv(&X->Check.idim_maxOrg, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPIHubbard.c:  ierr = MPI_Sendrecv(list_1_org, X->Check.idim_maxOrg + 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPIHubbard.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_maxOrg + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPIHubbard.c:  mask1 = X->Def.Tpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbard.c:  bit1diff = X->Def.Tpow[2 * X->Def.Nsite - 1] * 2 - mask1 * 2;
mltplyMPIHubbard.c:  if (X->Large.mode == M_MLTPLY|| X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbard.c:                   X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPIHubbard.c:  }/*if (X->Large.mode == M_MLTPLY|| X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbardCore.c:  if (org_isite + 1 > X->Def.Nsite) {
mltplyMPIHubbardCore.c:    tmp_ispin = X->Def.Tpow[2 * org_isite1 + org_isigma1];
mltplyMPIHubbardCore.c:    tmp_ispin = X->Def.Tpow[2 * org_isite2 + org_isigma2];
mltplyMPIHubbardCore.c:    tmp_ispin = X->Def.Tpow[2 * org_isite3 + org_isigma3];
mltplyMPIHubbardCore.c:    tmp_ispin = X->Def.Tpow[2 * org_isite4 + org_isigma4];
mltplyMPIHubbardCore.c:    tmp_ispin = X->Def.Tpow[2 * org_isite1 + org_isigma1];
mltplyMPIHubbardCore.c:    tmp_ispin = X->Def.Tpow[2 * org_isite3 + org_isigma3];
mltplyMPIHubbardCore.c:  *offbit = *offbit%X->Def.OrgTpow[2*X->Def.Nsite];
mltplyMPIHubbardCore.c:  unsigned long int i_max = X->Check.idim_max;
mltplyMPIHubbardCore.c:    if (org_isite1 + 1 > X->Def.Nsite && org_isite3 + 1 > X->Def.Nsite) {
mltplyMPIHubbardCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbardCore.c:      }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbardCore.c:      }/*if (!(X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC))*/
mltplyMPIHubbardCore.c:    }/*if (org_isite1 + 1 > X->Def.Nsite && org_isite3 + 1 > X->Def.Nsite)*/
mltplyMPIHubbardCore.c:    else if (org_isite1 + 1 > X->Def.Nsite || org_isite3 + 1 > X->Def.Nsite) {
mltplyMPIHubbardCore.c:      if (org_isite1 > org_isite3) tmp_ispin1 = X->Def.Tpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:      else                         tmp_ispin1 = X->Def.Tpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbardCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyMPIHubbardCore.c:      }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbardCore.c:      }/*if (!(X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC))*/
mltplyMPIHubbardCore.c:  unsigned long int i_max = X->Check.idim_max;
mltplyMPIHubbardCore.c:  isite1 = X->Def.Tpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbardCore.c:  isite2 = X->Def.Tpow[2 * org_isite2 + org_ispin2];
mltplyMPIHubbardCore.c:  isite3 = X->Def.Tpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:    tmp_isite1 = X->Def.OrgTpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbardCore.c:    tmp_isite2 = X->Def.OrgTpow[2 * org_isite2 + org_ispin2];
mltplyMPIHubbardCore.c:    tmp_isite3 = X->Def.OrgTpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:    tmp_isite4 = X->Def.OrgTpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:      tmp_isite4 = X->Def.OrgTpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbardCore.c:      tmp_isite3 = X->Def.OrgTpow[2 * org_isite2 + org_ispin2];
mltplyMPIHubbardCore.c:      tmp_isite2 = X->Def.OrgTpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:      tmp_isite1 = X->Def.OrgTpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:      if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbardCore.c:      if (X->Large.mode != M_CORR) {
mltplyMPIHubbardCore.c:      }/*if (X->Large.mode != M_CORR)*/
mltplyMPIHubbardCore.c:    ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPIHubbardCore.c:    ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPIHubbardCore.c:      if (org_isite1 + 1 > X->Def.Nsite && org_isite2 + 1 > X->Def.Nsite) {
mltplyMPIHubbardCore.c:        if (org_isite3 + 1 > X->Def.Nsite) {
mltplyMPIHubbardCore.c:          if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbardCore.c:        else { //org_isite3 <= X->Def.Nsite
mltplyMPIHubbardCore.c:          if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbardCore.c:      }/*if (org_isite1 + 1 > X->Def.Nsite && org_isite2 + 1 > X->Def.Nsite)*/
mltplyMPIHubbardCore.c:        org_rankbit = X->Def.OrgTpow[2 * X->Def.Nsite] * origin;
mltplyMPIHubbardCore.c:        if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbardCore.c:        }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbardCore.c:  unsigned long int i_max = X->Check.idim_max;
mltplyMPIHubbardCore.c:  isite1 = X->Def.Tpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbardCore.c:  isite2 = X->Def.Tpow[2 * org_isite2 + org_ispin2];
mltplyMPIHubbardCore.c:  isite3 = X->Def.Tpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:  isite4 = X->Def.Tpow[2 * org_isite4 + org_ispin4];
mltplyMPIHubbardCore.c:    tmp_isite1 = X->Def.OrgTpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbardCore.c:    tmp_isite2 = X->Def.OrgTpow[2 * org_isite2 + org_ispin2];
mltplyMPIHubbardCore.c:    tmp_isite3 = X->Def.OrgTpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:    tmp_isite4 = X->Def.OrgTpow[2 * org_isite4 + org_ispin4];
mltplyMPIHubbardCore.c:      tmp_isite4 = X->Def.OrgTpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbardCore.c:      tmp_isite3 = X->Def.OrgTpow[2 * org_isite2 + org_ispin2];
mltplyMPIHubbardCore.c:      tmp_isite2 = X->Def.OrgTpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:      tmp_isite1 = X->Def.OrgTpow[2 * org_isite4 + org_ispin4];
mltplyMPIHubbardCore.c:      if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbardCore.c:      if (X->Large.mode != M_CORR) { //for hermite
mltplyMPIHubbardCore.c:      }/*if (X->Large.mode != M_CORR)*/
mltplyMPIHubbardCore.c:      if (X->Large.mode != M_CORR) { //for hermite
mltplyMPIHubbardCore.c:      }/*if (X->Large.mode != M_CORR)*/
mltplyMPIHubbardCore.c:    ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPIHubbardCore.c:    ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPIHubbardCore.c:    if (org_isite1 + 1 > X->Def.Nsite && org_isite2 + 1 > X->Def.Nsite
mltplyMPIHubbardCore.c:     && org_isite3 + 1 > X->Def.Nsite && org_isite4 + 1 > X->Def.Nsite) {
mltplyMPIHubbardCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbardCore.c:      }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbardCore.c:      }/*if (! (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC))*/
mltplyMPIHubbardCore.c:      org_rankbit = X->Def.OrgTpow[2 * X->Def.Nsite] * origin;
mltplyMPIHubbardCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbardCore.c:      }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbardCore.c:      }/*if (! (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC))*/
mltplyMPIHubbardCore.c:  unsigned long int i_max = X->Check.idim_max;
mltplyMPIHubbardCore.c:  isite1 = X->Def.Tpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbardCore.c:  if (org_isite1 + 1 > X->Def.Nsite) {
mltplyMPIHubbardCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyMPIHubbardCore.c:      }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbardCore.c:      }/*if (! (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC))*/
mltplyMPIHubbardCore.c:  }/*if (org_isite1 + 1 > X->Def.Nsite)*/
mltplyMPIHubbardCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyMPIHubbardCore.c:      }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbardCore.c:      }/*if (! (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC))*/
mltplyMPIHubbardCore.c:  }/*if (org_isite1 + 1 <= X->Def.Nsite)*/
mltplyMPIHubbardCore.c:  if (org_isite1 + 1 > X->Def.Nsite && org_isite2 + 1 > X->Def.Nsite) {
mltplyMPIHubbardCore.c:  else if (org_isite1 + 1 > X->Def.Nsite || org_isite2 + 1 > X->Def.Nsite) {
mltplyMPIHubbardCore.c:  unsigned long int i_max = X->Check.idim_max;
mltplyMPIHubbardCore.c:    if (org_isite1 + 1 > X->Def.Nsite && org_isite3 + 1 > X->Def.Nsite) {
mltplyMPIHubbardCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyMPIHubbardCore.c:      }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbardCore.c:      }/*if (! (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC))*/
mltplyMPIHubbardCore.c:    }/*if (org_isite1 + 1 > X->Def.Nsite && org_isite3 + 1 > X->Def.Nsite)*/
mltplyMPIHubbardCore.c:    else if (org_isite1 + 1 > X->Def.Nsite || org_isite3 + 1 > X->Def.Nsite) {
mltplyMPIHubbardCore.c:      if (org_isite1 > org_isite3) tmp_ispin1 = X->Def.Tpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:      else                         tmp_ispin1 = X->Def.Tpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbardCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbardCore.c:      }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbardCore.c:      }/*if (! (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC))*/
mltplyMPIHubbardCore.c:    }/*if (org_isite1 + 1 > X->Def.Nsite || org_isite3 + 1 > X->Def.Nsite)*/
mltplyMPIHubbardCore.c:  unsigned long int i_max = X->Check.idim_max;
mltplyMPIHubbardCore.c:  isite1 = X->Def.Tpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbardCore.c:  isite2 = X->Def.Tpow[2 * org_isite2 + org_ispin2];
mltplyMPIHubbardCore.c:  isite3 = X->Def.Tpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:  isite4 = X->Def.Tpow[2 * org_isite4 + org_ispin4];
mltplyMPIHubbardCore.c:    tmp_isite1 = X->Def.OrgTpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbardCore.c:    tmp_isite2 = X->Def.OrgTpow[2 * org_isite2 + org_ispin2];
mltplyMPIHubbardCore.c:    tmp_isite3 = X->Def.OrgTpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:    tmp_isite4 = X->Def.OrgTpow[2 * org_isite4 + org_ispin4];
mltplyMPIHubbardCore.c:      tmp_isite4 = X->Def.OrgTpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbardCore.c:      tmp_isite3 = X->Def.OrgTpow[2 * org_isite2 + org_ispin2];
mltplyMPIHubbardCore.c:      tmp_isite2 = X->Def.OrgTpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:      tmp_isite1 = X->Def.OrgTpow[2 * org_isite4 + org_ispin4];
mltplyMPIHubbardCore.c:      if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) tmp_V = 0;     
mltplyMPIHubbardCore.c:      if (X->Large.mode != M_CORR) {  //for hermite
mltplyMPIHubbardCore.c:      }/*if (X->Large.mode != M_CORR)*/
mltplyMPIHubbardCore.c:      if (X->Large.mode != M_CORR) //for hermite: CisAkuCjtAis=-CisAisCjtAku
mltplyMPIHubbardCore.c:    ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPIHubbardCore.c:    ierr = MPI_Sendrecv(list_1, X->Check.idim_max + 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPIHubbardCore.c:    ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPIHubbardCore.c:    if (org_isite1 + 1 > X->Def.Nsite && org_isite2 + 1 > X->Def.Nsite
mltplyMPIHubbardCore.c:     && org_isite3 + 1 > X->Def.Nsite && org_isite4 + 1 > X->Def.Nsite)
mltplyMPIHubbardCore.c:        if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbardCore.c:              X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff) == TRUE)
mltplyMPIHubbardCore.c:        }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbardCore.c:              X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff) == TRUE)
mltplyMPIHubbardCore.c:        }/*if (! (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC))*/
mltplyMPIHubbardCore.c:    }//org_isite1+1 > X->Def.Nsite && org_isite2+1 > X->Def.Nsite
mltplyMPIHubbardCore.c:            // && org_isite3+1 > X->Def.Nsite && org_isite4+1 > X->Def.Nsite
mltplyMPIHubbardCore.c:      org_rankbit = X->Def.OrgTpow[2 * X->Def.Nsite] * origin;
mltplyMPIHubbardCore.c:        if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbardCore.c:              if (GetOffComp(list_2_1, list_2_2, tmp_off, X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff) == TRUE)
mltplyMPIHubbardCore.c:        }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbardCore.c:                X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff) == TRUE)
mltplyMPIHubbardCore.c:        }/*if (! (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC))*/
mltplyMPIHubbardCore.c:  unsigned long int i_max = X->Check.idim_max;
mltplyMPIHubbardCore.c:  isite1 = X->Def.Tpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbardCore.c:  isite2 = X->Def.Tpow[2 * org_isite2 + org_ispin2];
mltplyMPIHubbardCore.c:  isite3 = X->Def.Tpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:    tmp_isite1 = X->Def.OrgTpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbardCore.c:    tmp_isite2 = X->Def.OrgTpow[2 * org_isite2 + org_ispin2];
mltplyMPIHubbardCore.c:    tmp_isite3 = X->Def.OrgTpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:    tmp_isite4 = X->Def.OrgTpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:      tmp_isite4 = X->Def.OrgTpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbardCore.c:      tmp_isite3 = X->Def.OrgTpow[2 * org_isite2 + org_ispin2];
mltplyMPIHubbardCore.c:      tmp_isite2 = X->Def.OrgTpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:      tmp_isite1 = X->Def.OrgTpow[2 * org_isite3 + org_ispin3];
mltplyMPIHubbardCore.c:      if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) tmp_V = 0;
mltplyMPIHubbardCore.c:      if (X->Large.mode != M_CORR) {
mltplyMPIHubbardCore.c:      }/*if (X->Large.mode != M_CORR)*/
mltplyMPIHubbardCore.c:    ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPIHubbardCore.c:    ierr = MPI_Sendrecv(list_1, X->Check.idim_max + 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPIHubbardCore.c:    ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPIHubbardCore.c:      if (org_isite1 + 1 > X->Def.Nsite && org_isite2 + 1 > X->Def.Nsite) {
mltplyMPIHubbardCore.c:        if (org_isite3 + 1 > X->Def.Nsite) {
mltplyMPIHubbardCore.c:          if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbardCore.c:                X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPIHubbardCore.c:              GetOffComp(list_2_1, list_2_2, list_1buf[j], X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPIHubbardCore.c:        }/*if (org_isite3 + 1 > X->Def.Nsite)*/
mltplyMPIHubbardCore.c:        else { //org_isite3 <= X->Def.Nsite
mltplyMPIHubbardCore.c:          if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbardCore.c:                  X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPIHubbardCore.c:          }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbardCore.c:                  X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPIHubbardCore.c:        }/*if (org_isite3 + 1 <= X->Def.Nsite)*/
mltplyMPIHubbardCore.c:      }/*if (org_isite1 + 1 > X->Def.Nsite && org_isite2 + 1 > X->Def.Nsite)*/
mltplyMPIHubbardCore.c:        org_rankbit = X->Def.OrgTpow[2 * X->Def.Nsite] * origin;
mltplyMPIHubbardCore.c:        if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPIHubbardCore.c:                X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPIHubbardCore.c:        }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbardCore.c:                X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPIHubbardCore.c:        }/*if (! (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC))*/
mltplyMPIHubbardCore.c:  unsigned long int i_max = X->Check.idim_max;
mltplyMPIHubbardCore.c:  isite1 = X->Def.Tpow[2 * org_isite1 + org_ispin1];
mltplyMPIHubbardCore.c:  if (org_isite1 + 1 > X->Def.Nsite) {
mltplyMPIHubbardCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyMPIHubbardCore.c:  }/*if (org_isite1 + 1 > X->Def.Nsite)*/
mltplyMPIHubbardCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyMPIHubbardCore.c:      }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyMPIHubbardCore.c:  }/*if (org_isite1 + 1 <= X->Def.Nsite)*/
mltplyMPISpin.c:    (int)X->Def.InterAll_OffDiagonal[i_int][0], (int)X->Def.InterAll_OffDiagonal[i_int][1],
mltplyMPISpin.c:    (int)X->Def.InterAll_OffDiagonal[i_int][3], (int)X->Def.InterAll_OffDiagonal[i_int][4],
mltplyMPISpin.c:    (int)X->Def.InterAll_OffDiagonal[i_int][5], (int)X->Def.InterAll_OffDiagonal[i_int][7],
mltplyMPISpin.c:    X->Def.ParaInterAll_OffDiagonal[i_int], X, tmp_v0, tmp_v1);
mltplyMPISpin.c:  X->Large.prdct += dam_pr;
mltplyMPISpin.c:  mask1 = (int)X->Def.Tpow[org_isite1];
mltplyMPISpin.c:  mask2 = (int)X->Def.Tpow[org_isite3];
mltplyMPISpin.c:    if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) {
mltplyMPISpin.c:  ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPISpin.c:  ierr = MPI_Sendrecv(list_1, X->Check.idim_max + 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPISpin.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpin.c:  if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpin.c:        X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPISpin.c:  }/*if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC)*/
mltplyMPISpin.c:        X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPISpin.c:  }/*if (! (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC))*/
mltplyMPISpin.c:  mask1 = (int)X->Def.Tpow[org_isite1];
mltplyMPISpin.c:  mask2 = (int)X->Def.Tpow[org_isite3];
mltplyMPISpin.c:  ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPISpin.c:  ierr = MPI_Sendrecv(list_1, X->Check.idim_max + 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPISpin.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpin.c:      X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPISpin.c:    (int)X->Def.InterAll_OffDiagonal[i_int][0], (int)X->Def.InterAll_OffDiagonal[i_int][1], 
mltplyMPISpin.c:    (int)X->Def.InterAll_OffDiagonal[i_int][3], (int)X->Def.InterAll_OffDiagonal[i_int][4],
mltplyMPISpin.c:    (int)X->Def.InterAll_OffDiagonal[i_int][5], (int)X->Def.InterAll_OffDiagonal[i_int][7],
mltplyMPISpin.c:    X->Def.ParaInterAll_OffDiagonal[i_int], X, tmp_v0, tmp_v1);
mltplyMPISpin.c:  X->Large.prdct += dam_pr;
mltplyMPISpin.c:  mask2 = (int)X->Def.Tpow[org_isite3];
mltplyMPISpin.c:    if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) {
mltplyMPISpin.c:  ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPISpin.c:  ierr = MPI_Sendrecv(list_1, X->Check.idim_max + 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPISpin.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpin.c:  mask1 = X->Def.Tpow[org_isite1];
mltplyMPISpin.c:  if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpin.c:          X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPISpin.c:  else if (X->Large.mode == M_TOTALS) {
mltplyMPISpin.c:          X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPISpin.c:  }/*if (X->Large.mode == M_TOTALS)*/
mltplyMPISpin.c:          X->Large.irght, X->Large.ilft, X->Large.ihfbit, &ioff);
mltplyMPISpin.c:  if (X->Def.InterAll_OffDiagonal[i_int][1] == X->Def.InterAll_OffDiagonal[i_int][3] &&
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][5] != X->Def.InterAll_OffDiagonal[i_int][7]) {
mltplyMPISpin.c:  else if (X->Def.InterAll_OffDiagonal[i_int][1] != X->Def.InterAll_OffDiagonal[i_int][3] &&
mltplyMPISpin.c:           X->Def.InterAll_OffDiagonal[i_int][5] == X->Def.InterAll_OffDiagonal[i_int][7]) {
mltplyMPISpin.c:  if (X->Def.InterAll_OffDiagonal[i_int][1] == X->Def.InterAll_OffDiagonal[i_int][3] &&
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][5] != X->Def.InterAll_OffDiagonal[i_int][7]) {
mltplyMPISpin.c:  else if (X->Def.InterAll_OffDiagonal[i_int][1] != X->Def.InterAll_OffDiagonal[i_int][3] &&
mltplyMPISpin.c:           X->Def.InterAll_OffDiagonal[i_int][5] == X->Def.InterAll_OffDiagonal[i_int][7]) {
mltplyMPISpin.c:  if (X->Def.InterAll_OffDiagonal[i_int][1] == X->Def.InterAll_OffDiagonal[i_int][3] &&
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][5] != X->Def.InterAll_OffDiagonal[i_int][7]) {
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][0], X->Def.InterAll_OffDiagonal[i_int][1],
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][4], X->Def.InterAll_OffDiagonal[i_int][5],
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][7], X->Def.ParaInterAll_OffDiagonal[i_int], X, tmp_v0, tmp_v1);
mltplyMPISpin.c:  else if (X->Def.InterAll_OffDiagonal[i_int][1] != X->Def.InterAll_OffDiagonal[i_int][3] &&
mltplyMPISpin.c:           X->Def.InterAll_OffDiagonal[i_int][5] == X->Def.InterAll_OffDiagonal[i_int][7]) {
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][0], X->Def.InterAll_OffDiagonal[i_int][1],
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][3], X->Def.InterAll_OffDiagonal[i_int][4],
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][5], X->Def.ParaInterAll_OffDiagonal[i_int], X, tmp_v0, tmp_v1);
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][0], X->Def.InterAll_OffDiagonal[i_int][1], 
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][3], X->Def.InterAll_OffDiagonal[i_int][4],
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][5], X->Def.InterAll_OffDiagonal[i_int][7],
mltplyMPISpin.c:      X->Def.ParaInterAll_OffDiagonal[i_int], X, tmp_v0, tmp_v1);
mltplyMPISpin.c:  X->Large.prdct += dam_pr;
mltplyMPISpin.c:  if (X->Def.InterAll_OffDiagonal[i_int][1] == X->Def.InterAll_OffDiagonal[i_int][3] &&
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][5] != X->Def.InterAll_OffDiagonal[i_int][7]) {
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][0], X->Def.InterAll_OffDiagonal[i_int][1],
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][4], X->Def.InterAll_OffDiagonal[i_int][5],
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][7], X->Def.ParaInterAll_OffDiagonal[i_int], X, tmp_v0, tmp_v1);
mltplyMPISpin.c:  else if (X->Def.InterAll_OffDiagonal[i_int][1] != X->Def.InterAll_OffDiagonal[i_int][3] &&
mltplyMPISpin.c:           X->Def.InterAll_OffDiagonal[i_int][5] == X->Def.InterAll_OffDiagonal[i_int][7]) {
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][0], X->Def.InterAll_OffDiagonal[i_int][1], 
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][3], X->Def.InterAll_OffDiagonal[i_int][4],
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][5], X->Def.ParaInterAll_OffDiagonal[i_int], X, tmp_v0, tmp_v1);
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][0], X->Def.InterAll_OffDiagonal[i_int][1], 
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][3], X->Def.InterAll_OffDiagonal[i_int][4],
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][5], X->Def.InterAll_OffDiagonal[i_int][7],
mltplyMPISpin.c:      X->Def.ParaInterAll_OffDiagonal[i_int], X, tmp_v0, tmp_v1);
mltplyMPISpin.c:  X->Large.prdct += dam_pr;
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][0], X->Def.InterAll_OffDiagonal[i_int][1], 
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][3], X->Def.InterAll_OffDiagonal[i_int][4],
mltplyMPISpin.c:      X->Def.InterAll_OffDiagonal[i_int][5], X->Def.InterAll_OffDiagonal[i_int][7],
mltplyMPISpin.c:      X->Def.ParaInterAll_OffDiagonal[i_int], X, tmp_v0, tmp_v1);
mltplyMPISpin.c:    X->Large.prdct += dam_pr;
mltplyMPISpin.c:    X->Def.InterAll_OffDiagonal[i_int][0], X->Def.InterAll_OffDiagonal[i_int][1],
mltplyMPISpin.c:    X->Def.InterAll_OffDiagonal[i_int][3], X->Def.InterAll_OffDiagonal[i_int][4],
mltplyMPISpin.c:    X->Def.InterAll_OffDiagonal[i_int][5], X->Def.InterAll_OffDiagonal[i_int][7],
mltplyMPISpin.c:    X->Def.ParaInterAll_OffDiagonal[i_int], X, tmp_v0, tmp_v1);
mltplyMPISpin.c:  X->Large.prdct += dam_pr;
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][0],  X->Def.InterAll_OffDiagonal[i_int][1], 
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][3],  X->Def.InterAll_OffDiagonal[i_int][4], 
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][5],  X->Def.InterAll_OffDiagonal[i_int][7],
mltplyMPISpinCore.c:    X->Def.ParaInterAll_OffDiagonal[i_int],X, tmp_v0, tmp_v1);
mltplyMPISpinCore.c:  X->Large.prdct += dam_pr;
mltplyMPISpinCore.c:  mask1 = (int)X->Def.Tpow[org_isite1];
mltplyMPISpinCore.c:  mask2 = (int)X->Def.Tpow[org_isite3];
mltplyMPISpinCore.c:    if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][0], X->Def.InterAll_OffDiagonal[i_int][1],
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][4], X->Def.InterAll_OffDiagonal[i_int][5],
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][7], X->Def.ParaInterAll_OffDiagonal[i_int], X, tmp_v0, tmp_v1);
mltplyMPISpinCore.c:  X->Large.prdct += dam_pr;
mltplyMPISpinCore.c:  mask1 = (int)X->Def.Tpow[org_isite1];
mltplyMPISpinCore.c:  mask2 = (int)X->Def.Tpow[org_isite3];
mltplyMPISpinCore.c:    if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) Jint = 0;
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:  if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][0], X->Def.InterAll_OffDiagonal[i_int][1],
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][3], X->Def.InterAll_OffDiagonal[i_int][4], 
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][5], X->Def.ParaInterAll_OffDiagonal[i_int], X, tmp_v0, tmp_v1);
mltplyMPISpinCore.c:  X->Large.prdct += dam_pr;
mltplyMPISpinCore.c:  mask1 = (int)X->Def.Tpow[org_isite1];
mltplyMPISpinCore.c:  mask2 = (int)X->Def.Tpow[org_isite3];
mltplyMPISpinCore.c:      if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:  mask1 = (int)X->Def.Tpow[org_isite1];
mltplyMPISpinCore.c:  mask2 = (int)X->Def.Tpow[org_isite3];
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++) */
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:  mask1 = (int)X->Def.Tpow[org_isite1];
mltplyMPISpinCore.c:  mask2 = (int)X->Def.Tpow[org_isite3];
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][0], X->Def.InterAll_OffDiagonal[i_int][1],
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][3], X->Def.InterAll_OffDiagonal[i_int][4],
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][5], X->Def.InterAll_OffDiagonal[i_int][7],
mltplyMPISpinCore.c:    X->Def.ParaInterAll_OffDiagonal[i_int], X, tmp_v0, tmp_v1);
mltplyMPISpinCore.c:  X->Large.prdct += dam_pr;
mltplyMPISpinCore.c:  mask2 = (int)X->Def.Tpow[org_isite3];
mltplyMPISpinCore.c:    if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:  mask1 = X->Def.Tpow[org_isite1];
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][0], X->Def.InterAll_OffDiagonal[i_int][1],
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][4], X->Def.InterAll_OffDiagonal[i_int][5],
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][7], X->Def.ParaInterAll_OffDiagonal[i_int], X, tmp_v0, tmp_v1);
mltplyMPISpinCore.c:  X->Large.prdct += dam_pr;
mltplyMPISpinCore.c:  mask2 = (int)X->Def.Tpow[org_isite3];
mltplyMPISpinCore.c:    if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:  mask1 = X->Def.Tpow[org_isite1];
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][0], X->Def.InterAll_OffDiagonal[i_int][1],
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][3], X->Def.InterAll_OffDiagonal[i_int][4],
mltplyMPISpinCore.c:    X->Def.InterAll_OffDiagonal[i_int][5], X->Def.ParaInterAll_OffDiagonal[i_int], X, tmp_v0, tmp_v1);
mltplyMPISpinCore.c:  X->Large.prdct += dam_pr;
mltplyMPISpinCore.c:  mask2 = (int)X->Def.Tpow[org_isite3];
mltplyMPISpinCore.c:  mask1 = (int)X->Def.Tpow[org_isite1];
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      for (j = 0; j < X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 0; j < X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:    else if (X->Large.mode == M_CORR) {
mltplyMPISpinCore.c:      for (j = 0; j < X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 0; j < X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:      for (j = 0; j < X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 0; j < X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:    &off, X->Def.SiteToBit, X->Def.Tpow) == TRUE) {
mltplyMPISpinCore.c:    if (BitCheckGeneral(off, org_isite1 + 1, org_ispin1, X->Def.SiteToBit, X->Def.Tpow) == TRUE) {
mltplyMPISpinCore.c:    if (BitCheckGeneral((unsigned long int) myrank, org_isite1 + 1, org_ispin1, X->Def.SiteToBit, X->Def.Tpow) ==
mltplyMPISpinCore.c:        X->Def.SiteToBit, X->Def.Tpow) == TRUE) {
mltplyMPISpinCore.c:      if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) tmp_V = 0.0;
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:                      v1buf,  X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:  if (BitCheckGeneral((unsigned long int) myrank, org_isite3 + 1, org_ispin3, X->Def.SiteToBit, X->Def.Tpow) == TRUE
mltplyMPISpinCore.c:      &off, X->Def.SiteToBit, X->Def.Tpow) == TRUE) {
mltplyMPISpinCore.c:                                   X->Def.SiteToBit, X->Def.Tpow) == TRUE) {
mltplyMPISpinCore.c:    if (BitCheckGeneral(off, org_isite3 + 1, org_ispin3, X->Def.SiteToBit, X->Def.Tpow) == TRUE) {
mltplyMPISpinCore.c:      if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) tmp_V = 0.0;
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:                      v1buf,  X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:    &tmp_off, X->Def.SiteToBit, X->Def.Tpow) == TRUE) {
mltplyMPISpinCore.c:      &off, X->Def.SiteToBit, X->Def.Tpow) == TRUE) {
mltplyMPISpinCore.c:      X->Def.SiteToBit, X->Def.Tpow) == TRUE) {
mltplyMPISpinCore.c:      if (GetOffCompGeneralSpin(tmp_off, org_isite1 + 1, org_ispin2, org_ispin1, &off, X->Def.SiteToBit,
mltplyMPISpinCore.c:                                      X->Def.Tpow) == TRUE) {
mltplyMPISpinCore.c:        if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) tmp_V = 0.0;
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:                      v1buf,  X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:  num1 = BitCheckGeneral((unsigned long int) myrank, org_isite1 + 1, org_ispin1, X->Def.SiteToBit, X->Def.Tpow);
mltplyMPISpinCore.c:    num1 = BitCheckGeneral((unsigned long int) myrank, org_isite3 + 1, org_ispin3, X->Def.SiteToBit, X->Def.Tpow);
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:    &off, X->Def.SiteToBit, X->Def.Tpow) == TRUE) {
mltplyMPISpinCore.c:    X->Def.SiteToBit, X->Def.Tpow) == TRUE) {
mltplyMPISpinCore.c:    if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) tmp_V = 0.0;
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:                      v1buf,  X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:    org_isite1 + 1, org_ispin1, X->Def.SiteToBit, X->Def.Tpow);
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:    org_isite1 + 1, org_ispin1, X->Def.SiteToBit, X->Def.Tpow);
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:                            &off, X->Def.SiteToBit, X->Def.Tpow) == TRUE) {
mltplyMPISpinCore.c:                                 X->Def.SiteToBit, X->Def.Tpow) == TRUE) {
mltplyMPISpinCore.c:    if (X->Large.mode == M_CORR || X->Large.mode ==M_CALCSPEC) tmp_V = 0.0;
mltplyMPISpinCore.c:  if (X->Large.mode == M_MLTPLY || X->Large.mode ==M_CALCSPEC) {
mltplyMPISpinCore.c:      ConvertToList1GeneralSpin(list_1buf_org[j], X->Large.ihfbit, &tmp_off);
mltplyMPISpinCore.c:    X->Def.SiteToBit, X->Def.Tpow) == TRUE)
mltplyMPISpinCore.c:    X->Def.SiteToBit, X->Def.Tpow) == TRUE)
mltplyMPISpinCore.c:    if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) tmp_V = 0.0;
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:                      v1buf,  X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:        num1 = BitCheckGeneral(j - 1, isite, IniSpin, X->Def.SiteToBit, X->Def.Tpow);
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:        num1 = BitCheckGeneral(j - 1, isite, IniSpin, X->Def.SiteToBit, X->Def.Tpow);
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:    org_isite3+1, org_ispin3, X->Def.SiteToBit, X->Def.Tpow);
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:          X->Def.SiteToBit, X->Def.Tpow) == TRUE)
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:          X->Def.SiteToBit, X->Def.Tpow) == TRUE) 
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:    X->Def.SiteToBit, X->Def.Tpow) == TRUE)
mltplyMPISpinCore.c:    X->Def.SiteToBit, X->Def.Tpow) == TRUE)
mltplyMPISpinCore.c:    if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) tmp_V = 0.0;
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:                      v1buf,  X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:          X->Def.SiteToBit, X->Def.Tpow) == TRUE)
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:          X->Def.SiteToBit, X->Def.Tpow) == TRUE) 
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:  num1 = BitCheckGeneral((unsigned long int)myrank, org_isite3+1, org_ispin3, X->Def.SiteToBit, X->Def.Tpow);
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:        num1 = BitCheckGeneral(j - 1, org_isite1 + 1, org_ispin1, X->Def.SiteToBit, X->Def.Tpow);
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:        num1 = BitCheckGeneral(j - 1, org_isite1 + 1, org_ispin1, X->Def.SiteToBit, X->Def.Tpow);
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:  if (GetOffCompGeneralSpin((unsigned long int)myrank, org_isite1 + 1, org_ispin1, org_ispin2, &tmp_off, X->Def.SiteToBit, X->Def.Tpow) == TRUE)
mltplyMPISpinCore.c:    if (GetOffCompGeneralSpin(tmp_off, org_isite3 + 1, org_ispin3, org_ispin4, &off, X->Def.SiteToBit, X->Def.Tpow) == TRUE)
mltplyMPISpinCore.c:    if(GetOffCompGeneralSpin((unsigned long int)myrank, org_isite3 + 1, org_ispin4, org_ispin3, &tmp_off, X->Def.SiteToBit, X->Def.Tpow) == TRUE)
mltplyMPISpinCore.c: if (GetOffCompGeneralSpin(tmp_off, org_isite1 + 1, org_ispin2, org_ispin1, &off, X->Def.SiteToBit, X->Def.Tpow) == TRUE)
mltplyMPISpinCore.c:     if(X->Large.mode == M_CORR|| X->Large.mode == M_CALCSPEC){
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(list_1, X->Check.idim_max + 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:        ConvertToList1GeneralSpin(list_1buf[j], X->Check.sdim, &off);
mltplyMPISpinCore.c:        ConvertToList1GeneralSpin(list_1buf[j], X->Check.sdim, &off);
mltplyMPISpinCore.c:    num1 = BitCheckGeneral((unsigned long int) myrank, org_isite1 + 1, org_ispin1, X->Def.SiteToBit, X->Def.Tpow);
mltplyMPISpinCore.c:    num1 = BitCheckGeneral((unsigned long int) myrank, org_isite1 + 1, org_ispin1, X->Def.SiteToBit, X->Def.Tpow);
mltplyMPISpinCore.c:      num1 = BitCheckGeneral((unsigned long int) myrank, org_isite3 + 1, org_ispin3, X->Def.SiteToBit,
mltplyMPISpinCore.c:        X->Def.Tpow);
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:  num1 = BitCheckGeneral((unsigned long int) myrank, org_isite3 + 1, org_ispin3, X->Def.SiteToBit, X->Def.Tpow);
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:        num1 = BitCheckGeneral(list_1[j], org_isite1 + 1, org_ispin1, X->Def.SiteToBit, X->Def.Tpow);
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:        num1 = BitCheckGeneral(list_1[j], org_isite1 + 1, org_ispin1, X->Def.SiteToBit, X->Def.Tpow);
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:    X->Def.SiteToBit, X->Def.Tpow) == TRUE)
mltplyMPISpinCore.c:    org_isite3 + 1, org_ispin4, org_ispin3, &off, X->Def.SiteToBit, X->Def.Tpow) == TRUE)
mltplyMPISpinCore.c:    if (X->Large.mode == M_CORR || X->Large.mode == M_CALCSPEC) tmp_V = 0.0;
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(list_1, X->Check.idim_max + 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:          X->Def.SiteToBit, X->Def.Tpow) == TRUE) 
mltplyMPISpinCore.c:          ConvertToList1GeneralSpin(tmp_off, X->Check.sdim, &off);
mltplyMPISpinCore.c:          X->Def.SiteToBit, X->Def.Tpow) == TRUE) 
mltplyMPISpinCore.c:          ConvertToList1GeneralSpin(tmp_off, X->Check.sdim, &off);
mltplyMPISpinCore.c:  mask1 = (int)X->Def.Tpow[org_isite1];
mltplyMPISpinCore.c:    if(X->Large.mode == M_CORR|| X->Large.mode ==M_CALCSPEC){
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(&X->Check.idim_max, 1, MPI_UNSIGNED_LONG, origin, 0,
mltplyMPISpinCore.c:  ierr = MPI_Sendrecv(tmp_v1, X->Check.idim_max + 1, MPI_DOUBLE_COMPLEX, origin, 0,
mltplyMPISpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:      for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:      }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:  mask1 = (int)X->Def.Tpow[org_isite1];
mltplyMPISpinCore.c:  if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) {
mltplyMPISpinCore.c:      GetOffComp(list_2_1_target, list_2_2_target, list_1buf_org[j], X->Large.irght, X->Large.ilft, X->Large.ihfbit, &tmp_off);
mltplyMPISpinCore.c:  mask1 = (int)X->Def.Tpow[org_isite1];
mltplyMPISpinCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyMPISpinCore.c:        for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:        }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:        for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:        }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:  mask1 = (int)X->Def.Tpow[org_isite1];
mltplyMPISpinCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplyMPISpinCore.c:        for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:        }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplyMPISpinCore.c:        for (j = 1; j <= X->Check.idim_max; j++) {
mltplyMPISpinCore.c:        }/*for (j = 1; j <= X->Check.idim_max; j++)*/
mltplySpin.c:  if (X->Def.iFlgGeneralSpin == FALSE)
mltplySpin.c:  for (i = 0; i < X->Def.NInterAll_OffDiagonal; i+=2) {
mltplySpin.c:    if (X->Def.InterAll_OffDiagonal[i][0] + 1 > X->Def.Nsite &&
mltplySpin.c:        X->Def.InterAll_OffDiagonal[i][4] + 1 > X->Def.Nsite) {
mltplySpin.c:    else if (X->Def.InterAll_OffDiagonal[i][4] + 1 > X->Def.Nsite) {
mltplySpin.c:    else if (X->Def.InterAll_OffDiagonal[i][0] + 1 > X->Def.Nsite) {
mltplySpin.c:        isite1 = X->Def.InterAll_OffDiagonal[idx][0] + 1;
mltplySpin.c:        isite2 = X->Def.InterAll_OffDiagonal[idx][4] + 1;
mltplySpin.c:        sigma1 = X->Def.InterAll_OffDiagonal[idx][1];
mltplySpin.c:        sigma2 = X->Def.InterAll_OffDiagonal[idx][3];
mltplySpin.c:        sigma3 = X->Def.InterAll_OffDiagonal[idx][5];
mltplySpin.c:        sigma4 = X->Def.InterAll_OffDiagonal[idx][7];
mltplySpin.c:        tmp_V = X->Def.ParaInterAll_OffDiagonal[idx];
mltplySpin.c:        X->Large.prdct += dam_pr;
mltplySpin.c:  }/*for (i = 0; i < X->Def.NInterAll_OffDiagonal; i+=2)*/
mltplySpin.c:  for (i = 0; i < X->Def.NExchangeCoupling; i++) {
mltplySpin.c:    if (X->Def.ExchangeCoupling[i][0] + 1 > X->Def.Nsite &&
mltplySpin.c:        X->Def.ExchangeCoupling[i][1] + 1 > X->Def.Nsite) {
mltplySpin.c:        X->Def.ExchangeCoupling[i][0], sigma1, sigma2, 
mltplySpin.c:        X->Def.ExchangeCoupling[i][1], sigma2, sigma1, 
mltplySpin.c:        X->Def.ParaExchangeCoupling[i], X, tmp_v0, tmp_v1);
mltplySpin.c:    else if (X->Def.ExchangeCoupling[i][1] + 1 > X->Def.Nsite) {
mltplySpin.c:        X->Def.ExchangeCoupling[i][0], sigma1, sigma2, 
mltplySpin.c:        X->Def.ExchangeCoupling[i][1], sigma2, sigma1,
mltplySpin.c:        X->Def.ParaExchangeCoupling[i], X, tmp_v0, tmp_v1);
mltplySpin.c:    else if (X->Def.ExchangeCoupling[i][0] + 1 > X->Def.Nsite) {
mltplySpin.c:        X->Def.ExchangeCoupling[i][1], sigma2, sigma1, 
mltplySpin.c:        X->Def.ExchangeCoupling[i][0], sigma1, sigma2, 
mltplySpin.c:        conj(X->Def.ParaExchangeCoupling[i]), X, tmp_v0, tmp_v1);
mltplySpin.c:    X->Large.prdct += dam_pr;
mltplySpin.c:  }/*for (i = 0; i < X->Def.NExchangeCoupling; i += 2)*/
mltplySpin.c:  i_max = X->Check.idim_max;
mltplySpin.c:  ihfbit =X->Check.sdim;
mltplySpin.c:  for (i = 0; i < X->Def.NInterAll_OffDiagonal; i += 2) {
mltplySpin.c:    if (X->Def.InterAll_OffDiagonal[i][0] + 1 > X->Def.Nsite &&
mltplySpin.c:        X->Def.InterAll_OffDiagonal[i][4] + 1 > X->Def.Nsite) {
mltplySpin.c:    else if (X->Def.InterAll_OffDiagonal[i][4] + 1 > X->Def.Nsite) {
mltplySpin.c:    else if (X->Def.InterAll_OffDiagonal[i][0] + 1 > X->Def.Nsite) {
mltplySpin.c:        isite1 = X->Def.InterAll_OffDiagonal[idx][0] + 1;
mltplySpin.c:        isite2 = X->Def.InterAll_OffDiagonal[idx][4] + 1;
mltplySpin.c:        sigma1 = X->Def.InterAll_OffDiagonal[idx][1];
mltplySpin.c:        sigma2 = X->Def.InterAll_OffDiagonal[idx][3];
mltplySpin.c:        sigma3 = X->Def.InterAll_OffDiagonal[idx][5];
mltplySpin.c:        sigma4 = X->Def.InterAll_OffDiagonal[idx][7];
mltplySpin.c:        tmp_V = X->Def.ParaInterAll_OffDiagonal[idx];
mltplySpin.c:          tmp_sgn = GetOffCompGeneralSpin(list_1[j], isite2, sigma4, sigma3, &tmp_off, X->Def.SiteToBit, X->Def.Tpow);
mltplySpin.c:            tmp_sgn = GetOffCompGeneralSpin(tmp_off, isite1, sigma2, sigma1, &tmp_off2, X->Def.SiteToBit, X->Def.Tpow);
mltplySpin.c:              if (X->Large.mode == M_MLTPLY) { // for multply
mltplySpin.c:        X->Large.prdct += dam_pr;
mltplySpin.c:  }/*for (i = 0; i < X->Def.NInterAll_OffDiagonal; i += 2)*/
mltplySpin.c:  if (X->Def.iFlgGeneralSpin == FALSE) 
mltplySpin.c:  if(X->Boost.flgBoost == 1)
mltplySpin.c:  i_max = X->Check.idim_max;
mltplySpin.c:  for (i = 0; i < X->Def.EDNTransfer; i+=2 ) {
mltplySpin.c:    if(X->Def.EDGeneralTransfer[i][0]+1 > X->Def.Nsite){
mltplySpin.c:      if(X->Def.EDGeneralTransfer[i][1]==X->Def.EDGeneralTransfer[i][3]){
mltplySpin.c:          X->Def.EDGeneralTransfer[i][0], X->Def.EDGeneralTransfer[i][1], 
mltplySpin.c:          X->Def.EDGeneralTransfer[i][3], -X->Def.EDParaGeneralTransfer[i], 
mltplySpin.c:    }/*if(X->Def.EDGeneralTransfer[i][0]+1 > X->Def.Nsite)*/
mltplySpin.c:        isite1 = X->Def.EDGeneralTransfer[idx][0] + 1;
mltplySpin.c:        isite2 = X->Def.EDGeneralTransfer[idx][2] + 1;
mltplySpin.c:        sigma1 = X->Def.EDGeneralTransfer[idx][1];
mltplySpin.c:        sigma2 = X->Def.EDGeneralTransfer[idx][3];
mltplySpin.c:        tmp_trans = -X->Def.EDParaGeneralTransfer[idx];
mltplySpin.c:          is1_spin = X->Def.Tpow[isite1 - 1];
mltplySpin.c:    X->Large.prdct += dam_pr;
mltplySpin.c:  }/*for (i = 0; i < X->Def.EDNTransfer; i+=2 )*/
mltplySpin.c:  for (i = 0; i < X->Def.NInterAll_OffDiagonal; i += 2) {
mltplySpin.c:    if (X->Def.InterAll_OffDiagonal[i][0] + 1 > X->Def.Nsite &&
mltplySpin.c:        X->Def.InterAll_OffDiagonal[i][4] + 1 > X->Def.Nsite) {
mltplySpin.c:    else if (X->Def.InterAll_OffDiagonal[i][4] + 1 > X->Def.Nsite) {
mltplySpin.c:    else if (X->Def.InterAll_OffDiagonal[i][0] + 1 > X->Def.Nsite) {
mltplySpin.c:        isite1 = X->Def.InterAll_OffDiagonal[idx][0] + 1;
mltplySpin.c:        isite2 = X->Def.InterAll_OffDiagonal[idx][4] + 1;
mltplySpin.c:        sigma1 = X->Def.InterAll_OffDiagonal[idx][1];
mltplySpin.c:        sigma2 = X->Def.InterAll_OffDiagonal[idx][3];
mltplySpin.c:        sigma3 = X->Def.InterAll_OffDiagonal[idx][5];
mltplySpin.c:        sigma4 = X->Def.InterAll_OffDiagonal[idx][7];
mltplySpin.c:        tmp_V = X->Def.ParaInterAll_OffDiagonal[idx];
mltplySpin.c:        X->Large.prdct += dam_pr;
mltplySpin.c:  }/*for (i = 0; i < X->Def.NInterAll_OffDiagonal; i += 2)*/
mltplySpin.c:  for (i = 0; i < X->Def.NExchangeCoupling; i++) {
mltplySpin.c:    if (X->Def.ExchangeCoupling[i][0] + 1 > X->Def.Nsite &&
mltplySpin.c:        X->Def.ExchangeCoupling[i][1] + 1 > X->Def.Nsite){
mltplySpin.c:        X->Def.ExchangeCoupling[i][0], sigma1, sigma2, 
mltplySpin.c:        X->Def.ExchangeCoupling[i][1], sigma2, sigma1, 
mltplySpin.c:        X->Def.ParaExchangeCoupling[i], X, tmp_v0, tmp_v1);
mltplySpin.c:    else if (X->Def.ExchangeCoupling[i][1] + 1 > X->Def.Nsite) {
mltplySpin.c:        X->Def.ExchangeCoupling[i][0], sigma1, sigma2,
mltplySpin.c:        X->Def.ExchangeCoupling[i][1], sigma2, sigma1,
mltplySpin.c:        X->Def.ParaExchangeCoupling[i], X, tmp_v0, tmp_v1);
mltplySpin.c:    else if (X->Def.ExchangeCoupling[i][0] + 1 > X->Def.Nsite) {
mltplySpin.c:        X->Def.ExchangeCoupling[i][1], sigma2, sigma1,
mltplySpin.c:        X->Def.ExchangeCoupling[i][0], sigma1, sigma2,
mltplySpin.c:        conj(X->Def.ParaExchangeCoupling[i]), X, tmp_v0, tmp_v1);
mltplySpin.c:    X->Large.prdct += dam_pr;
mltplySpin.c:  }/* for (i = 0; i < X->Def.NExchangeCoupling; i ++) */
mltplySpin.c:  for (i = 0; i < X->Def.NPairLiftCoupling; i++) {
mltplySpin.c:    if (X->Def.PairLiftCoupling[i][0] + 1 > X->Def.Nsite &&
mltplySpin.c:        X->Def.PairLiftCoupling[i][1] + 1 > X->Def.Nsite) {
mltplySpin.c:        X->Def.PairLiftCoupling[i][0], sigma1, sigma2, 
mltplySpin.c:        X->Def.PairLiftCoupling[i][1], sigma1, sigma2,
mltplySpin.c:        X->Def.ParaPairLiftCoupling[i], X, tmp_v0, tmp_v1);
mltplySpin.c:    else if (X->Def.PairLiftCoupling[i][1] + 1 > X->Def.Nsite) {
mltplySpin.c:        X->Def.PairLiftCoupling[i][0], sigma1, sigma2, 
mltplySpin.c:        X->Def.PairLiftCoupling[i][1], sigma1, sigma2, 
mltplySpin.c:        X->Def.ParaPairLiftCoupling[i], X, tmp_v0, tmp_v1);
mltplySpin.c:    else if (X->Def.PairLiftCoupling[i][0] + 1 > X->Def.Nsite) {
mltplySpin.c:        X->Def.PairLiftCoupling[i][1], sigma1, sigma2,
mltplySpin.c:        X->Def.PairLiftCoupling[i][0], sigma1, sigma2,
mltplySpin.c:        conj(X->Def.ParaPairLiftCoupling[i]), X, tmp_v0, tmp_v1);
mltplySpin.c:    X->Large.prdct += dam_pr;
mltplySpin.c:  }/*for (i = 0; i < X->Def.NPairLiftCoupling; i += 2)*/
mltplySpin.c:  i_max = X->Check.idim_max;
mltplySpin.c:  for (i = 0; i < X->Def.EDNTransfer; i += 2) {
mltplySpin.c:    isite1 = X->Def.EDGeneralTransfer[i][0] + 1;
mltplySpin.c:    isite2 = X->Def.EDGeneralTransfer[i][2] + 1;
mltplySpin.c:    sigma1 = X->Def.EDGeneralTransfer[i][1];
mltplySpin.c:    sigma2 = X->Def.EDGeneralTransfer[i][3];
mltplySpin.c:    tmp_trans = -X->Def.EDParaGeneralTransfer[idx];
mltplySpin.c:        if (isite1 > X->Def.Nsite) {
mltplySpin.c:          X->Large.prdct += dam_pr;
mltplySpin.c:        }/*if (isite1 > X->Def.Nsite)*/
mltplySpin.c:            isite1 = X->Def.EDGeneralTransfer[idx][0] + 1;
mltplySpin.c:            isite2 = X->Def.EDGeneralTransfer[idx][2] + 1;
mltplySpin.c:            sigma1 = X->Def.EDGeneralTransfer[idx][1];
mltplySpin.c:            sigma2 = X->Def.EDGeneralTransfer[idx][3];
mltplySpin.c:            tmp_trans = -X->Def.EDParaGeneralTransfer[idx];
mltplySpin.c:                j - 1, isite1, sigma2, sigma1, &off, X->Def.SiteToBit, X->Def.Tpow);
mltplySpin.c:            X->Large.prdct += dam_pr;
mltplySpin.c:  }/*for (i = 0; i < X->Def.EDNTransfer; i += 2)*/
mltplySpin.c:  for (i = 0; i< X->Def.NInterAll_OffDiagonal; i += 2) {
mltplySpin.c:    if (X->Def.InterAll_OffDiagonal[i][0] + 1 > X->Def.Nsite &&
mltplySpin.c:        X->Def.InterAll_OffDiagonal[i][4] + 1 > X->Def.Nsite) {
mltplySpin.c:    else if (X->Def.InterAll_OffDiagonal[i][4] + 1 > X->Def.Nsite) {
mltplySpin.c:    else if (X->Def.InterAll_OffDiagonal[i][0] + 1 > X->Def.Nsite) {
mltplySpin.c:        isite1 = X->Def.InterAll_OffDiagonal[idx][0] + 1;
mltplySpin.c:        isite2 = X->Def.InterAll_OffDiagonal[idx][4] + 1;
mltplySpin.c:        sigma1 = X->Def.InterAll_OffDiagonal[idx][1];
mltplySpin.c:        sigma2 = X->Def.InterAll_OffDiagonal[idx][3];
mltplySpin.c:        sigma3 = X->Def.InterAll_OffDiagonal[idx][5];
mltplySpin.c:        sigma4 = X->Def.InterAll_OffDiagonal[idx][7];
mltplySpin.c:        tmp_V = X->Def.ParaInterAll_OffDiagonal[idx];
mltplySpin.c:                j - 1, isite2, sigma4, sigma3, &off, X->Def.SiteToBit, X->Def.Tpow);
mltplySpin.c:                tmp_sgn = BitCheckGeneral(off, isite1, sigma1, X->Def.SiteToBit, X->Def.Tpow);
mltplySpin.c:                  if (X->Large.mode == M_MLTPLY) { // for multply
mltplySpin.c:            tmp_sgn = BitCheckGeneral(j - 1, isite2, sigma3, X->Def.SiteToBit, X->Def.Tpow);
mltplySpin.c:                j - 1, isite1, sigma2, sigma1, &off, X->Def.SiteToBit, X->Def.Tpow);
mltplySpin.c:                if (X->Large.mode == M_MLTPLY) { // for multply
mltplySpin.c:              j - 1, isite2, sigma4, sigma3, &tmp_off, X->Def.SiteToBit, X->Def.Tpow);
mltplySpin.c:                tmp_off, isite1, sigma2, sigma1, &off, X->Def.SiteToBit, X->Def.Tpow);
mltplySpin.c:                if (X->Large.mode == M_MLTPLY) { // for multply
mltplySpin.c:        X->Large.prdct += dam_pr;
mltplySpin.c:  }/*for (i = 0; i< X->Def.NInterAll_OffDiagonal; i += 2)*/
mltplySpin.c:  i_max = X->Check.idim_max;
mltplySpin.c:  X->Large.prdct += dam_pr;  
mltplySpin.c:  long unsigned int i_max = X->Large.i_max;
mltplySpin.c:  long unsigned int i_max = X->Large.i_max;
mltplySpin.c:  long unsigned int i_max = X->Large.i_max;
mltplySpin.c:  i_max = X->Large.i_max;
mltplySpin.c:  org_sigma2 = X->Large.is2_spin;
mltplySpin.c:  org_sigma4 = X->Large.is4_spin;
mltplySpin.c:  tmp_V = X->Large.tmp_V;
mltplySpin.c:  isA_up = X->Large.is1_up;
mltplySpin.c:  isB_up = X->Large.is2_up;
mltplySpin.c:  i_max = X->Large.i_max;
mltplySpin.c:  org_isite1 = X->Large.isite1;
mltplySpin.c:  org_isite2 = X->Large.isite2;
mltplySpin.c:  org_sigma1 = X->Large.is1_spin;
mltplySpin.c:  org_sigma2 = X->Large.is2_spin;
mltplySpin.c:  org_sigma3 = X->Large.is3_spin;
mltplySpin.c:  org_sigma4 = X->Large.is4_spin;
mltplySpin.c:  tmp_V = X->Large.tmp_V;
mltplySpin.c:  isA_up = X->Def.Tpow[org_isite1 - 1];
mltplySpin.c:  isB_up = X->Def.Tpow[org_isite2 - 1];
mltplySpinCore.c:  int isite1 = X->Def.ExchangeCoupling[iExchange][0] + 1;
mltplySpinCore.c:  int isite2 = X->Def.ExchangeCoupling[iExchange][1] + 1;
mltplySpinCore.c:  X->Large.tmp_J = X->Def.ParaExchangeCoupling[iExchange];
mltplySpinCore.c:  X->Large.is1_up = X->Def.Tpow[isite1 - 1];
mltplySpinCore.c:  X->Large.is2_up = X->Def.Tpow[isite2 - 1];
mltplySpinCore.c:  X->Large.isA_spin = X->Large.is1_up + X->Large.is2_up;
mltplySpinCore.c:  int isite1 = X->Def.PairLiftCoupling[iPairLift][0] + 1;
mltplySpinCore.c:  int isite2 = X->Def.PairLiftCoupling[iPairLift][1] + 1;
mltplySpinCore.c:  X->Large.tmp_J = X->Def.ParaPairLiftCoupling[iPairLift];
mltplySpinCore.c:  X->Large.is1_up = X->Def.Tpow[isite1 - 1];
mltplySpinCore.c:  X->Large.is2_up = X->Def.Tpow[isite2 - 1];
mltplySpinCore.c:  X->Large.isA_spin = X->Large.is1_up + X->Large.is2_up;
mltplySpinCore.c:  X->Large.tmp_V = tmp_V;
mltplySpinCore.c:  X->Large.isite1 = isite1;
mltplySpinCore.c:  X->Large.isite2 = isite2;
mltplySpinCore.c:  X->Large.is1_up = X->Def.Tpow[isite1 - 1];
mltplySpinCore.c:  X->Large.is2_up = X->Def.Tpow[isite2 - 1];
mltplySpinCore.c:  X->Large.is1_spin = sigma1;
mltplySpinCore.c:  X->Large.is2_spin = sigma2;
mltplySpinCore.c:  X->Large.is3_spin = sigma3;
mltplySpinCore.c:  X->Large.is4_spin = sigma4;
mltplySpinCore.c:    GetOffComp(list_2_1_, list_2_2_, off, X->Large.irght, X->Large.ilft, X->Large.ihfbit, tmp_off);
mltplySpinCore.c:  long unsigned int irght = X->Large.irght;
mltplySpinCore.c:  long unsigned int ilft = X->Large.ilft;
mltplySpinCore.c:  long unsigned int ihfbit = X->Large.ihfbit;
mltplySpinCore.c:  long unsigned int is_up = X->Large.isA_spin;
mltplySpinCore.c:  long unsigned int irght = X->Large.irght;
mltplySpinCore.c:  long unsigned int ilft = X->Large.ilft;
mltplySpinCore.c:  long unsigned int ihfbit = X->Large.ihfbit;
mltplySpinCore.c:  double complex tmp_J = X->Large.tmp_J;
mltplySpinCore.c:  int mode = X->Large.mode;
mltplySpinCore.c:  long unsigned int is_up = X->Large.isA_spin;
mltplySpinCore.c:  double complex tmp_J = X->Large.tmp_J;
mltplySpinCore.c:  int mode = X->Large.mode;
mltplySpinCore.c:  long unsigned int is_up = X->Large.isA_spin;
mltplySpinCore.c:  double complex tmp_J = X->Large.tmp_J;
mltplySpinCore.c:  int mode = X->Large.mode;
mltplySpinCore.c:  if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplySpinCore.c:    if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplySpinCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplySpinCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
mltplySpinCore.c:      if (X->Large.mode == M_MLTPLY || X->Large.mode == M_CALCSPEC) { // for multply
output.c:  i_max = X->Check.idim_max;
output.c:  if (X->Def.iCalcType == FullDiag) {
output.c:    switch (X->Def.iCalcModel) {
output.c:        sprintf(sdt, cFileNamePhys_FullDiag, X->Def.CDataFileHead, X->Def.Nup, X->Def.Ndown);
output.c:        sprintf(sdt, cFileNamePhys_FullDiag_GC, X->Def.CDataFileHead);
output.c:      fprintf(fp, " %10lf %10lf %10lf %10lf %10lf\n", X->Phys.all_energy[i], X->Phys.all_num_up[i]+X->Phys.all_num_down[i], X->Phys.all_sz[i],
output.c:              X->Phys.all_s2[i], X->Phys.all_doublon[i]);
output.c:  long int imax = X->Check.idim_max;
output.c:  sprintf(sdt,cFileNamePhys_FullDiag_Ham, X->Def.CDataFileHead);
output_list.c:  i_max=X->Check.idim_max;
output_list.c:  switch(X->Def.iCalcModel){
output_list.c:    sprintf(sdt, cFileNameListModel, X->Def.Nsite,X->Def.Nup,X->Def.Ndown);
output_list.c:    sprintf(sdt, "ListForKondo_Ns%d_Ncond%d", X->Def.Nsite,X->Def.Ne);
phys.c:  i_max = X->Check.idim_max;
phys.c:    X->Phys.eigen_num = i;
phys.c:    if (X->Def.iCalcType == FullDiag) {
phys.c:    if (X->Def.iCalcModel == Spin || X->Def.iCalcModel == SpinGC) {
phys.c:      tmp_N = X->Def.NsiteMPI;
phys.c:      tmp_N = X->Phys.num_up + X->Phys.num_down;
phys.c:    if (X->Def.iCalcType == FullDiag)
phys.c:      fprintf(stdoutMPI, "i=%5ld Energy=%10lf N=%10lf Sz=%10lf S2=%10lf Doublon=%10lf \n", i, X->Phys.energy, tmp_N,
phys.c:              X->Phys.Sz, X->Phys.s2, X->Phys.doublon);
phys.c:    else if (X->Def.iCalcType == CG)
phys.c:      fprintf(stdoutMPI, "i=%5ld Energy=%10lf N=%10lf Sz=%10lf Doublon=%10lf \n", i, X->Phys.energy, tmp_N,
phys.c:              X->Phys.Sz, X->Phys.doublon);
phys.c:    X->Phys.all_energy[i] = X->Phys.energy;
phys.c:    X->Phys.all_doublon[i] = X->Phys.doublon;
phys.c:    X->Phys.all_sz[i] = X->Phys.Sz;
phys.c:    X->Phys.all_s2[i] = X->Phys.s2;
phys.c:    X->Phys.all_num_up[i] = X->Phys.num_up;
phys.c:    X->Phys.all_num_down[i] = X->Phys.num_down;
readdef.c:  X->iCalcType=0;
readdef.c:  X->iFlgFiniteTemperature=0;
readdef.c:  X->iCalcModel=0;
readdef.c:  X->iOutputMode=0;
readdef.c:  X->iCalcEigenVec=0;
readdef.c:  X->iInitialVecType=0;
readdef.c:  X->iOutputEigenVec=0;
readdef.c:  X->iInputEigenVec=0;
readdef.c:  X->iOutputHam=0;
readdef.c:  X->iInputHam=0;
readdef.c:  X->iFlgCalcSpec=0;
readdef.c:  X->iReStart=0;
readdef.c:  X->iFlgMPI=0;
readdef.c:  X->iNGPU=2;
readdef.c:  X->iNGPU=0;
readdef.c:      X->iCalcType=itmp;
readdef.c:      X->iFlgFiniteTemperature = itmp;
readdef.c:      X->iCalcModel=itmp;
readdef.c:      X->iOutputMode=itmp;
readdef.c:      X->iCalcEigenVec=itmp;
readdef.c:      X->iInitialVecType=itmp;
readdef.c:      X->iOutputEigenVec=itmp;
readdef.c:      X->iInputEigenVec=itmp;
readdef.c:      X->iOutputHam=itmp;
readdef.c:      X->iInputHam=itmp;
readdef.c:      X->iFlgCalcSpec=itmp;
readdef.c:      X->iReStart=itmp;
readdef.c:        X->iNGPU=itmp;
readdef.c:  if(ValidateValue(X->iCalcModel, 0, NUM_CALCMODEL-1)){
readdef.c:  if(ValidateValue(X->iCalcType, 0, NUM_CALCTYPE-1)){
readdef.c:  if(ValidateValue(X->iOutputMode, 0, NUM_OUTPUTMODE-1)){
readdef.c:  if(ValidateValue(X->iCalcEigenVec, -1, NUM_CALCEIGENVEC-1)){
readdef.c:  if(ValidateValue(X->iInitialVecType, 0, NUM_SETINITAILVEC-1)){
readdef.c:  if(ValidateValue(X->iOutputHam, 0, NUM_OUTPUTHAM-1)){
readdef.c:  if(ValidateValue(X->iInputHam, 0, NUM_INPUTHAM-1)){
readdef.c:  if(X->iInputHam == 1 && X->iOutputHam==1){
readdef.c:  if(ValidateValue(X->iReStart, 0, NUM_RESTART-1)){
readdef.c:    if(X->iNGPU < 0){
readdef.c:  if(X->iCalcType==2 && ValidateValue(X->iFlgFiniteTemperature, 0, 1)){
readdef.c:  if(X->iCalcType !=2 && X->iOutputHam ==TRUE) {
readdef.c:  X->nvec=0;
readdef.c:  X->iFlgSpecOmegaMax=FALSE;
readdef.c:  X->iFlgSpecOmegaMin=FALSE;
readdef.c:  X->iFlgSpecOmegaOrg=FALSE;
readdef.c:  X->iNOmega=1000;
readdef.c:  X->NCond=0;
readdef.c:  X->iFlgSzConserved=FALSE;
readdef.c:  X->dcOmegaOrg=0;
readdef.c:  X->Param.ExpecInterval=1;
readdef.c:  X->READ=0;
readdef.c:  X->WRITE=0;
readdef.c:            sscanf(ctmp2, "%s %s\n", ctmp, X->CDataFileHead); //6
readdef.c:            sscanf(ctmp2, "%s %s\n", ctmp, X->CParaFileHead); //7
readdef.c:            X->read_hacker = 1;
readdef.c:                X->Nsite = (int) dtmp;
readdef.c:                X->Nup = (int) dtmp;
readdef.c:                X->Ndown = (int) dtmp;
readdef.c:                X->Total2Sz = X->Nup - X->Ndown;
readdef.c:                X->Total2Sz = (int) dtmp;
readdef.c:                X->iFlgSzConserved = TRUE;
readdef.c:                X->NCond = (int) dtmp;
readdef.c:                X->Lanczos_max = (int) dtmp;
readdef.c:                X->initial_iv = (int) dtmp;
readdef.c:                X->nvec = (int) dtmp;
readdef.c:                X->k_exct = (int) dtmp;
readdef.c:                X->LanczosEps = (int) dtmp;
readdef.c:                X->LanczosTarget = (int) dtmp;
readdef.c:                X->Param.TimeSlice=dtmp;
readdef.c:                X->Param.ExpandCoef=(int)dtmp;
readdef.c:                X->Param.OutputInterval=(int)dtmp;
readdef.c:                X->Param.ExpecInterval = (int) dtmp;
readdef.c:                X->Param.Tinit=dtmp;
readdef.c:                X->read_hacker = (int) dtmp;
readdef.c:                X->dcOmegaMax=dtmp+dtmp2*I;
readdef.c:                X->iFlgSpecOmegaMax=TRUE;
readdef.c:                X->dcOmegaMin =dtmp+dtmp2*I;
readdef.c:                X->iFlgSpecOmegaMin=TRUE;
readdef.c:                X->dcOmegaOrg +=dtmp*I;
readdef.c:                X->iFlgSpecOmegaOrg=TRUE;
readdef.c:                X->dcOmegaOrg +=dtmp+dtmp2*I;
readdef.c:                X->iFlgSpecOmegaOrg=TRUE;
readdef.c:                X->iNOmega=(int)dtmp;
readdef.c:                X->irand=(int)dtmp;
readdef.c:        X->iFlgGeneralSpin = FALSE;
readdef.c:            sscanf(ctmp2, "%s %d\n", ctmp, &(X->NLocSpn));
readdef.c:            sscanf(ctmp2, "%s %d\n", ctmp, &(X->NTransfer));
readdef.c:            sscanf(ctmp2, "%s %d\n", ctmp, &(X->NCoulombIntra));
readdef.c:            sscanf(ctmp2, "%s %d\n", ctmp, &(X->NCoulombInter));
readdef.c:            sscanf(ctmp2, "%s %d\n", ctmp, &(X->NHundCoupling));
readdef.c:            sscanf(ctmp2, "%s %d\n", ctmp, &(X->NPairHopping));
readdef.c:            X->NPairHopping*=2;
readdef.c:            sscanf(ctmp2, "%s %d\n", ctmp, &(X->NExchangeCoupling));
readdef.c:            sscanf(ctmp2, "%s %d\n", ctmp, &(X->NIsingCoupling));
readdef.c:            sscanf(ctmp2, "%s %d\n", ctmp, &(X->NPairLiftCoupling));
readdef.c:            sscanf(ctmp2, "%s %d\n", ctmp, &(X->NInterAll));
readdef.c:            sscanf(ctmp2, "%s %d\n", ctmp, &(X->NCisAjt));
readdef.c:            sscanf(ctmp2, "%s %d\n", ctmp, &(X->NCisAjtCkuAlvDC));
readdef.c:        sscanf(ctmp2,"%s %d\n", ctmp, &(X->NLaser));
readdef.c:        if(X->iCalcType != TimeEvolution) break;
readdef.c:        sscanf(ctmp2,"%s %d\n", ctmp, &(X->NTETimeSteps));
readdef.c:        if(X->NTETimeSteps>0) {
readdef.c:      X->NTETransferMax=iTETransMax;
readdef.c:        if(X->iCalcType != TimeEvolution) break;
readdef.c:        sscanf(ctmp2,"%s %d\n", ctmp, &(X->NTETimeSteps));
readdef.c:        if(X->NTETimeSteps>0) {
readdef.c:        X->NTEInterAllMax=iTEInterAllMax;
readdef.c:      sscanf(ctmp2,"%s %d\n", ctmp, &(X->NSingleExcitationOperator));
readdef.c:      sscanf(ctmp2,"%s %d\n", ctmp, &(X->NPairExcitationOperator));
readdef.c:  switch(X->iCalcModel){
readdef.c:      if(X->iCalcModel==Spin){
readdef.c:        if(X->iFlgSzConserved==TRUE){
readdef.c:          if(X->iCalcModel==SpinlessFermion){
readdef.c:            X->Ne=X->NCond;  
readdef.c:            X->Nup=X->NCond;
readdef.c:            X->Ndown=0;
readdef.c:          X->Nup=X->NLocSpn+X->NCond+X->Total2Sz;
readdef.c:          X->Ndown=X->NLocSpn+X->NCond-X->Total2Sz;
readdef.c:          X->Nup/=2;
readdef.c:          X->Ndown/=2;
readdef.c:          if(X->iCalcModel == Hubbard){
readdef.c:            X->Ne=X->NCond;
readdef.c:            if(X->Ne <1){
readdef.c:            X->iCalcModel=HubbardNConserved;
readdef.c:          else if(X->iCalcModel ==SpinlessFermion){
readdef.c:            X->Ne=X->NCond;  
readdef.c:            X->Nup=X->NCond;
readdef.c:            X->Ndown=0;
readdef.c:    else if(iReadNCond == FALSE && X->iFlgSzConserved==TRUE){
readdef.c:      if(X->iCalcModel != Spin){
readdef.c:      X->Nup=X->NLocSpn+X->Total2Sz;
readdef.c:      X->Ndown=X->NLocSpn-X->Total2Sz;
readdef.c:      X->Nup /= 2;
readdef.c:      X->Ndown /= 2;
readdef.c:      if(X->Nup==0 && X->Ndown==0){
readdef.c:        if(X->iCalcModel == Spin){
readdef.c:    if(X->iCalcModel == Spin){
readdef.c:      X->Ne=X->Nup;
readdef.c:      if(X->Ne==0) {
readdef.c:        X->Ne = X->Nup + X->Ndown;
readdef.c:      if(X->NLocSpn>X->Ne){
readdef.c:        fprintf(stdoutMPI, "NLocalSpin=%d, Ne=%d\n", X->NLocSpn, X->Ne);
readdef.c:    if(iReadNCond == TRUE || X->iFlgSzConserved ==TRUE){
readdef.c:    if(X->Nsite<=0) {// Nsite must be positve
readdef.c:    if(X->Lanczos_max<=0) {// Lanczos_max must be positive
readdef.c:    if(X->LanczosEps<=0) {// Lanczos_eps must be positive
readdef.c:    if(X->Param.ExpecInterval<=0){// Interval to calculate expected values must be positive
readdef.c:    if(X->nvec==0){
readdef.c:      X->nvec=X->Lanczos_max;
readdef.c:    if(X->nvec < X->k_exct){
readdef.c:        X->nvec=X->k_exct;
readdef.c:    if (X->LanczosTarget < X->k_exct) X->LanczosTarget = X->k_exct;
readdef.c:    if(ValidateValue(X->k_exct, 1, X->nvec)) {
readdef.c:      fprintf(stdoutMPI, cErrLanczosExct, defname, X->nvec);
readdef.c:    if(ValidateValue(X->LanczosTarget, X->k_exct, )){
readdef.c:      fprintf(stdoutMPI, cErrLanczosTarget, defname, X->LanczosTarget, X->k_exct, X->Lanczos_max);
readdef.c:  X->fidx = 0;
readdef.c:  X->NeMPI=X->Ne;
readdef.c:  X->NupMPI=X->Nup;
readdef.c:  X->NdownMPI=X->Ndown;
readdef.c:  X->NupOrg=X->Nup;
readdef.c:  X->NdownOrg=X->Ndown;
readdef.c:        if(idx==X->Nsite){
readdef.c:        X->LocSpn[xitmp[0]] = xitmp[1];
readdef.c:        X->SiteToBit[xitmp[0]]=(X->LocSpn[xitmp[0]]+1);//2S+1
readdef.c:        if(CheckSite(xitmp[0], X->Nsite) !=0){
readdef.c:      if(X->NTransfer>0){
readdef.c:            if(idx==X->NTransfer){
readdef.c:            if(CheckPairSite(isite1, isite2,X->Nsite) !=0){
readdef.c:            if(X->iCalcModel==Spin){
readdef.c:            else if(X->iCalcModel==Kondo){
readdef.c:              if(X->LocSpn[isite1]!=ITINERANT || X->LocSpn[isite2] !=ITINERANT){
readdef.c:            else if(X->iCalcModel==SpinlessFermion || X->iCalcModel==SpinlessFermionGC){
readdef.c:              if(isite1 ==X->GeneralTransfer[i][0] && isite2 == X->GeneralTransfer[i][2]
readdef.c:                 && isigma1 == X->GeneralTransfer[i][1] && isigma2 == X->GeneralTransfer[i][3])
readdef.c:                  X->ParaGeneralTransfer[i] += dvalue_re+dvalue_im*I;
readdef.c:              X->GeneralTransfer[icnt_trans][0]=isite1;
readdef.c:              X->GeneralTransfer[icnt_trans][1]=isigma1;
readdef.c:              X->GeneralTransfer[icnt_trans][2]=isite2;
readdef.c:              X->GeneralTransfer[icnt_trans][3]=isigma2;
readdef.c:              X->ParaGeneralTransfer[icnt_trans] = dvalue_re+dvalue_im*I;
readdef.c:      X->NTransfer = icnt_trans;
readdef.c:      if(X->NCoulombIntra>0){
readdef.c:          if(idx==X->NCoulombIntra){
readdef.c:                 &(X->CoulombIntra[idx][0]),
readdef.c:                 &(X->ParaCoulombIntra[idx])
readdef.c:          if(CheckSite(X->CoulombIntra[idx][0], X->Nsite) !=0){
readdef.c:      if(X->NCoulombInter>0){
readdef.c:          if(idx==X->NCoulombInter){
readdef.c:                 &(X->CoulombInter[idx][0]),
readdef.c:                 &(X->CoulombInter[idx][1]),
readdef.c:                 &(X->ParaCoulombInter[idx])
readdef.c:          if(CheckPairSite(X->CoulombInter[idx][0], X->CoulombInter[idx][1],X->Nsite) !=0){
readdef.c:      if(X->NHundCoupling>0){
readdef.c:            if(idx==X->NHundCoupling){
readdef.c:                   &(X->HundCoupling[idx][0]),
readdef.c:                   &(X->HundCoupling[idx][1]),
readdef.c:                   &(X->ParaHundCoupling[idx])
readdef.c:            if(CheckPairSite(X->HundCoupling[idx][0], X->HundCoupling[idx][1],X->Nsite) !=0){
readdef.c:      if(X->iCalcModel == Spin || X->iCalcModel == SpinGC){
readdef.c:      if(X->NPairHopping>0){
readdef.c:          if(idx==X->NPairHopping/2){
readdef.c:                 &(X->PairHopping[2*idx][0]),
readdef.c:                 &(X->PairHopping[2*idx][1]),
readdef.c:                 &(X->ParaPairHopping[2*idx])
readdef.c:          if(CheckPairSite(X->PairHopping[2*idx][0], X->PairHopping[2*idx][1],X->Nsite) !=0){
readdef.c:          X->PairHopping[2*idx+1][0]=X->PairHopping[2*idx][1];
readdef.c:          X->PairHopping[2*idx+1][1]=X->PairHopping[2*idx][0];
readdef.c:          X->ParaPairHopping[2*idx+1]=X->ParaPairHopping[2*idx];
readdef.c:      if(X->NExchangeCoupling>0){
readdef.c:          if(idx==X->NExchangeCoupling){
readdef.c:                 &(X->ExchangeCoupling[idx][0]),
readdef.c:                 &(X->ExchangeCoupling[idx][1]),
readdef.c:                 &(X->ParaExchangeCoupling[idx])
readdef.c:          if(CheckPairSite(X->ExchangeCoupling[idx][0], X->ExchangeCoupling[idx][1],X->Nsite) !=0){
readdef.c:      if(X->NIsingCoupling>0){
readdef.c:          if(idx==X->NIsingCoupling){
readdef.c:          if(CheckPairSite(isite1,isite2,X->Nsite) !=0){
readdef.c:          X->HundCoupling[X->NHundCoupling+idx][0]=isite1;
readdef.c:          X->HundCoupling[X->NHundCoupling+idx][1]=isite2;
readdef.c:          X->ParaHundCoupling[X->NHundCoupling+idx]= -dvalue_re/2.0;
readdef.c:          X->CoulombInter[X->NCoulombInter+idx][0]=isite1;
readdef.c:          X->CoulombInter[X->NCoulombInter+idx][1]=isite2;
readdef.c:          X->ParaCoulombInter[X->NCoulombInter+idx]=-dvalue_re/4.0;
readdef.c:      if(X->NPairLiftCoupling>0){
readdef.c:        if(X->iCalcModel != SpinGC){
readdef.c:            if(idx==X->NPairLiftCoupling){
readdef.c:                   &(X->PairLiftCoupling[idx][0]),
readdef.c:                   &(X->PairLiftCoupling[idx][1]),
readdef.c:                   &(X->ParaPairLiftCoupling[idx])
readdef.c:            if(CheckPairSite(X->PairLiftCoupling[idx][0], X->PairLiftCoupling[idx][1],X->Nsite) !=0){
readdef.c:      X->NInterAll_Diagonal=0;
readdef.c:      X->NInterAll_OffDiagonal=0;
readdef.c:      if(X->NInterAll>0) {
readdef.c:          if (idx == X->NInterAll) {
readdef.c:          if (CheckInterAllCondition(X->iCalcModel, X->Nsite, X->iFlgGeneralSpin, X->LocSpn,
readdef.c:                                X->InterAll,
readdef.c:                                X->ParaInterAll,
readdef.c:      X->NInterAll = icnt_interall;
readdef.c:      X->NInterAll_Diagonal=icnt_diagonal;
readdef.c:      X->NInterAll_OffDiagonal = X->NInterAll-X->NInterAll_Diagonal;
readdef.c:                  X->InterAll_OffDiagonal, X->ParaInterAll_OffDiagonal,
readdef.c:                  X->InterAll_Diagonal, X->ParaInterAll_Diagonal, NInterAllSet);
readdef.c:                X->InterAll, X->ParaInterAll, X->NInterAll,
readdef.c:                X->InterAll_Diagonal, X->ParaInterAll_Diagonal,
readdef.c:                X->InterAll_OffDiagonal, X->ParaInterAll_OffDiagonal,
readdef.c:                X->EDChemi, X->EDSpinChemi, X->EDParaChemi, &X->EDNChemi,
readdef.c:                X->iCalcModel
readdef.c:                X->InterAll, X->ParaInterAll,
readdef.c:                X->InterAll_OffDiagonal, X->ParaInterAll_OffDiagonal,
readdef.c:                X->NInterAll_OffDiagonal, X->iCalcModel
readdef.c:      if(X->NCisAjt>0){
readdef.c:          if(idx==X->NCisAjt){
readdef.c:          if(X->iCalcModel == Spin){
readdef.c:              X->NCisAjt--;
readdef.c:          X->CisAjt[ idx ][0] = isite1;
readdef.c:          X->CisAjt[ idx ][1] = isigma1;
readdef.c:          X->CisAjt[ idx ][2] = isite2;
readdef.c:          X->CisAjt[ idx ][3] = isigma2;	  
readdef.c:          if(CheckPairSite(isite1, isite2,X->Nsite) !=0){
readdef.c:      if(X->NCisAjtCkuAlvDC>0){
readdef.c:          if(idx==X->NCisAjtCkuAlvDC){
readdef.c:          if(X->iCalcModel == Spin || X->iCalcModel == SpinGC){
readdef.c:              //X->NCisAjtCkuAlvDC--;
readdef.c:          X->CisAjtCkuAlvDC[idx][0] = isite1;
readdef.c:          X->CisAjtCkuAlvDC[idx][1] = isigma1;
readdef.c:          X->CisAjtCkuAlvDC[idx][2] = isite2;
readdef.c:          X->CisAjtCkuAlvDC[idx][3] = isigma2;
readdef.c:          X->CisAjtCkuAlvDC[idx][4] = isite3;
readdef.c:          X->CisAjtCkuAlvDC[idx][5] = isigma3;
readdef.c:          X->CisAjtCkuAlvDC[idx][6] = isite4;
readdef.c:          X->CisAjtCkuAlvDC[idx][7] = isigma4;
readdef.c:          if(CheckQuadSite(isite1, isite2, isite3, isite4,X->Nsite) !=0){
readdef.c:        if(X->NLaser>0){
readdef.c:            sscanf(ctmp2, "%s %lf\n", &(ctmp), &(X->ParaLaser[idx]));
readdef.c:            //printf("[%d]:%f\n",idx,X->ParaLaser[idx]);
readdef.c:          if(idx!=X->NLaser){
readdef.c:        if(X->NTETimeSteps>0){
readdef.c:            sscanf(ctmp2, "%lf %d\n", &(X->TETime[idx]), &(X->NTETransfer[idx]));
readdef.c:            for(i=0; i<X->NTETransfer[idx]; ++i ){
readdef.c:              X->TETransfer[idx][i][0]= isite1;
readdef.c:              X->TETransfer[idx][i][1]= isigma1;
readdef.c:              X->TETransfer[idx][i][2]= isite2;
readdef.c:              X->TETransfer[idx][i][3] = isigma2;
readdef.c:              X->ParaTETransfer[idx][i]=dvalue_re+dvalue_im*I;
readdef.c:            if(CheckTETransferHermite(X, X->NTETransfer[idx], idx)!=0){
readdef.c:          if(idx!=X->NTETimeSteps){
readdef.c:        if(X->NTETimeSteps>0){
readdef.c:            sscanf(ctmp2, "%lf %d\n", &(X->TETime[idx]), &(X->NTEInterAll[idx]));
readdef.c:            for (i = 0; i < X->NTEInterAll[idx]; ++i) {
readdef.c:              if (CheckInterAllCondition(X->iCalcModel, X->Nsite, X->iFlgGeneralSpin, X->LocSpn,
readdef.c:                                    X->TEInterAll[idx],
readdef.c:                                    X->ParaTEInterAll[idx],
readdef.c:            X->NTEInterAll[idx] = icnt_interall;
readdef.c:            X->NTEInterAllDiagonal[idx] = icnt_diagonal;
readdef.c:            X->NTEInterAllOffDiagonal[idx] = icnt_interall - icnt_diagonal;
readdef.c:            if (GetDiagonalInterAll(X->TEInterAll[idx], X->ParaTEInterAll[idx], X->NTEInterAll[idx], X->TEInterAllDiagonal[idx], X->ParaTEInterAllDiagonal[idx],
readdef.c:                    X->TEInterAllOffDiagonal[idx], X->ParaTEInterAllOffDiagonal[idx], X->TEChemi[idx], X->SpinTEChemi[idx], X->ParaTEChemi[idx], &X->NTEChemi[idx], X->iCalcModel) != 0)
readdef.c:                    X->TEInterAll[idx], X->ParaTEInterAll[idx],
readdef.c:                    X->TEInterAllOffDiagonal[idx], X->ParaTEInterAllOffDiagonal[idx],
readdef.c:                    X->NTEInterAllOffDiagonal[idx], X->iCalcModel
readdef.c:          if(idx!=X->NTETimeSteps){
readdef.c:      if(X->NSingleExcitationOperator>0) {
readdef.c:        if(X->iCalcModel == Spin || X->iCalcModel == SpinGC) {
readdef.c:          if (CheckSite(isite1, X->Nsite) != 0) {
readdef.c:          X->SingleExcitationOperator[idx][0] = isite1;
readdef.c:          X->SingleExcitationOperator[idx][1] = isigma1;
readdef.c:          X->SingleExcitationOperator[idx][2] = itype;
readdef.c:          X->ParaSingleExcitationOperator[idx] = dvalue_re + I * dvalue_im;
readdef.c:        if (idx != X->NSingleExcitationOperator) {
readdef.c:      if(X->NPairExcitationOperator>0) {
readdef.c:          if (CheckPairSite(isite1, isite2, X->Nsite) != 0) {
readdef.c:            X->PairExcitationOperator[idx][0] = isite1;
readdef.c:            X->PairExcitationOperator[idx][1] = isigma1;
readdef.c:            X->PairExcitationOperator[idx][2] = isite2;
readdef.c:            X->PairExcitationOperator[idx][3] = isigma2;
readdef.c:            X->PairExcitationOperator[idx][4] = itype;
readdef.c:            X->ParaPairExcitationOperator[idx] = dvalue_re + I * dvalue_im;
readdef.c:            X->PairExcitationOperator[idx][0] = isite2;
readdef.c:            X->PairExcitationOperator[idx][1] = isigma2;
readdef.c:            X->PairExcitationOperator[idx][2] = isite1;
readdef.c:            X->PairExcitationOperator[idx][3] = isigma1;
readdef.c:            X->PairExcitationOperator[idx][4] = itype;
readdef.c:            X->ParaPairExcitationOperator[idx] = -(dvalue_re + I * dvalue_im);
readdef.c:        if (idx != X->NPairExcitationOperator) {
readdef.c:      if(X->iFlgGeneralSpin==TRUE){
readdef.c:  for(i=0; i<X->NTransfer; i++){
readdef.c:    isite1=X->GeneralTransfer[i][0];
readdef.c:    isigma1=X->GeneralTransfer[i][1];
readdef.c:    isite2=X->GeneralTransfer[i][2];
readdef.c:    isigma2=X->GeneralTransfer[i][3];
readdef.c:   //         isite1, isigma1, isite2, isigma2, creal(X->ParaGeneralTransfer[i]), cimag((X->ParaGeneralTransfer[i])));
readdef.c:    for(j=0; j<X->NTransfer; j++){
readdef.c:      itmpsite1=X->GeneralTransfer[j][0];
readdef.c:      itmpsigma1=X->GeneralTransfer[j][1];
readdef.c:      itmpsite2=X->GeneralTransfer[j][2];
readdef.c:      itmpsigma2=X->GeneralTransfer[j][3];
readdef.c:          ddiff_trans = X->ParaGeneralTransfer[i]-conj(X->ParaGeneralTransfer[j]);
readdef.c:            dcerrTrans=X->ParaGeneralTransfer[j];
readdef.c:            fprintf(stdoutMPI, cErrNonHermiteTrans, isite1, isigma1, isite2, isigma2, creal(X->ParaGeneralTransfer[i]), cimag(X->ParaGeneralTransfer[i]));
readdef.c:                if(2*icntHermite >= X->NTransfer){
readdef.c:                    X->EDGeneralTransfer[2*icntHermite][itmpIdx]=X->GeneralTransfer[i][itmpIdx];
readdef.c:                    X->EDGeneralTransfer[2*icntHermite+1][itmpIdx]=X->GeneralTransfer[j][itmpIdx];
readdef.c:                  X->EDParaGeneralTransfer[2*icntHermite]=X->ParaGeneralTransfer[i];
readdef.c:                  X->EDParaGeneralTransfer[2*icntHermite+1]=X->ParaGeneralTransfer[j];
readdef.c:                  X->EDChemi[icntchemi]     = X->GeneralTransfer[i][0];      
readdef.c:                  X->EDSpinChemi[icntchemi] = X->GeneralTransfer[i][1];      
readdef.c:                  X->EDParaChemi[icntchemi] = creal(X->ParaGeneralTransfer[i]);
readdef.c:      fprintf(stdoutMPI, cErrNonHermiteTrans, isite1, isigma1, isite2, isigma2, creal(X->ParaGeneralTransfer[i]), cimag(X->ParaGeneralTransfer[i]));
readdef.c:  X->EDNTransfer=2*icntHermite;
readdef.c:  X->EDNChemi=icntchemi;
readdef.c:    for(i=0; i<X->EDNTransfer; i++){
readdef.c:    X->GeneralTransfer[i][itmpIdx]=X->EDGeneralTransfer[i][itmpIdx];
readdef.c:    X->ParaGeneralTransfer[i]=X->EDParaGeneralTransfer[i];
readdef.c:  eps_Lanczos     = pow(10,-X->LanczosEps);
readdef.c:  switch(X->iCalcModel){
readdef.c:    for(i=0; i<X->Nsite; i++){
readdef.c:      if(X->LocSpn[i]!=ITINERANT){
readdef.c:    for(i=0; i<X->Nsite; i++){
readdef.c:      if(X->LocSpn[i]>LOCSPIN){
readdef.c:        X->iFlgGeneralSpin=TRUE;
readdef.c:      else if(X->LocSpn[i]<ITINERANT){
readdef.c:    for(i=0; i<X->Nsite; i++){
readdef.c:      if(X->LocSpn[i]>LOCSPIN){
readdef.c:        X->iFlgGeneralSpin=TRUE;
readdef.c:      else if(X->LocSpn[i]<LOCSPIN){
readdef.c:  X->NHundCoupling += X->NIsingCoupling;
readdef.c:  X->NCoulombInter += X->NIsingCoupling;
readdef.c:  X->NTransfer=0;
readdef.c:  X->NCoulombIntra=0;
readdef.c:  X->NCoulombInter=0;
readdef.c:  X->NIsingCoupling=0;
readdef.c:  X->NPairLiftCoupling=0;
readdef.c:  X->NInterAll=0;
readdef.c:  X->NCisAjt=0;
readdef.c:  X->NCisAjtCkuAlvDC=0;
readdef.c:  X->NSingleExcitationOperator=0;
readdef.c:  X->NPairExcitationOperator=0;
readdef.c:  X->NTETimeSteps=0;
readdef.c:  X->NLaser=0;
readdef.c:  X->NTEInterAll=0;
readdef.c:  X->NTETransfer=0;
readdef.c:  if(X->iFlgGeneralSpin==TRUE){
readdef.c:    for(i=0; i<X->NTransfer; i++){
readdef.c:      isite1 =X->GeneralTransfer[i][0];
readdef.c:      isigma1=X->GeneralTransfer[i][1];
readdef.c:      isite2 =X->GeneralTransfer[i][2];
readdef.c:      isigma2=X->GeneralTransfer[i][3];
readdef.c:      if(isigma1 > X->LocSpn[isite1] || isigma2 >X->LocSpn[isite2]){
readdef.c:  if(X->iFlgSzConserved==TRUE && X->iFlgGeneralSpin==FALSE){
readdef.c:    int tmp_Nup=X->NLocSpn+X->NCond+X->Total2Sz;
readdef.c:    int tmp_Ndown=X->NLocSpn+X->NCond-X->Total2Sz;
readdef.c:      printf("Nup=%d, Ndown=%d\n",X->Nup,X->Ndown);
readdef.c:      tmp_TETransfer[i][j]=X->TETransfer[idx][i][j];
readdef.c:      X->TETransfer[idx][i][j]=0;
readdef.c:    tmp_paraTETransfer[i] = X->ParaTETransfer[idx][i];
readdef.c:    X->ParaTETransfer[idx][i]=0.0;
readdef.c:                    X->TETransfer[idx][2*icntHermite][itmpIdx]=tmp_TETransfer[i][itmpIdx];
readdef.c:                    X->TETransfer[idx][2*icntHermite+1][itmpIdx]=tmp_TETransfer[j][itmpIdx];
readdef.c:                  X->ParaTETransfer[idx][2*icntHermite]=tmp_paraTETransfer[i];
readdef.c:                  X->ParaTETransfer[idx][2*icntHermite+1]=tmp_paraTETransfer[j];
readdef.c:                  X->TETransferDiagonal[idx][icntchemi][0] = tmp_TETransfer[i][0];
readdef.c:                  X->TETransferDiagonal[idx][icntchemi][1] = tmp_TETransfer[i][1];
readdef.c:                  X->ParaTETransferDiagonal[idx][icntchemi] = creal(tmp_paraTETransfer[i]);
readdef.c:  X->NTETransfer[idx]=2*icntHermite;
readdef.c:  X->NTETransferDiagonal[idx]=icntchemi;
readdef.c:  X->NTransfer=0;
readdef.c:  X->NCoulombIntra=0;
readdef.c:  X->NCoulombInter=0;
readdef.c:  X->NIsingCoupling=0;
readdef.c:  X->NPairLiftCoupling=0;
readdef.c:  X->NInterAll=0;
readdef.c:  X->NCisAjt=0;
readdef.c:  X->NCisAjtCkuAlvDC=0;
readdef.c:  X->NSingleExcitationOperator=0;
readdef.c:  X->NPairExcitationOperator=0;
readdef.c:  X->NTETimeSteps=0;
readdef.c:  X->NLaser=0;
readdef.c:  X->NTEInterAll=0;
readdef.c:  X->NTETransfer=0;
readdef.c:  X->NTest = 0;
readdef.c:       sscanf(ctmp2, "%s %s\n", ctmp, X->CDataFileHead); //6
readdef.c:       sscanf(ctmp2, "%s %s\n", ctmp, X->CParaFileHead); //7
readdef.c:                X->NTest = (int) dtmp;
sz.c:  if(X->Def.iFlgGeneralSpin==TRUE){
sz.c:    li_malloc1(list_2_1_Sz, X->Check.sdim+2);
sz.c:    li_malloc1(list_2_2_Sz,(X->Def.Tpow[X->Def.Nsite-1]*X->Def.SiteToBit[X->Def.Nsite-1]/X->Check.sdim)+2);
sz.c:    for(j=0; j<X->Check.sdim+2;j++){
sz.c:    for(j=0; j< (X->Def.Tpow[X->Def.Nsite-1]*X->Def.SiteToBit[X->Def.Nsite-1]/X->Check.sdim)+2; j++){
sz.c:  lui_malloc1(list_jb,X->Large.SizeOflistjb);
sz.c:  for(i=0; i<X->Large.SizeOflistjb; i++){
sz.c:  if(X->Check.idim_max!=0){
sz.c:  switch(X->Def.iCalcModel){
sz.c:    N2=2*X->Def.Nsite;
sz.c:    N2  = 2*X->Def.Nsite;
sz.c:    N  =  X->Def.Nsite;
sz.c:      fprintf(stdoutMPI, cStateLocSpin,j,X->Def.LocSpn[j]);
sz.c:    N=X->Def.Nsite;
sz.c:    if(X->Def.iFlgGeneralSpin==FALSE){
sz.c:	      idim *= X->Def.SiteToBit[j];
sz.c:  li_malloc2(comb, X->Def.Nsite+1,X->Def.Nsite+1);
sz.c:  i_max=X->Check.idim_max;
sz.c:  switch(X->Def.iCalcModel){
sz.c:    if(X->Def.iFlgGeneralSpin==FALSE){
sz.c:      if(GetSplitBitByModel(X->Def.Nsite, X->Def.iCalcModel, &irght, &ilft, &ihfbit)!=0){
sz.c:      X->Large.irght=irght;
sz.c:      X->Large.ilft=ilft;
sz.c:      X->Large.ihfbit=ihfbit;
sz.c:      ihfbit=X->Check.sdim;
sz.c:  if(X->Def.READ==1){
sz.c:    sprintf(sdt, cFileNameSzTimeKeep, X->Def.CDataFileHead);
sz.c:    switch(X->Def.iCalcModel){
sz.c:      icnt = X->Def.Tpow[2*X->Def.Nsite-1]*2+0;/*Tpow[2*X->Def.Nsit]=1*/
sz.c:      if(X->Def.iFlgGeneralSpin==FALSE){
sz.c:        icnt = X->Def.Tpow[X->Def.Nsite-1]*2+0;/*Tpow[X->Def.Nsit]=1*/
sz.c:        icnt = X->Def.Tpow[X->Def.Nsite-1]*X->Def.SiteToBit[X->Def.Nsite-1];
sz.c:      for(j=X->Def.Nsite/2; j< X->Def.Nsite ;j++){ // counting # of localized spins
sz.c:        if(X->Def.LocSpn[j] != ITINERANT){ // //ITINERANT ==0 -> itinerant
sz.c:      for(ib=0;ib<X->Check.sdim;ib++){
sz.c:        for(j=(X->Def.Nsite+1)/2; j< X->Def.Nsite ;j++){
sz.c:          div_up    = i & X->Def.Tpow[2*j];
sz.c:          div_up    = div_up/X->Def.Tpow[2*j];
sz.c:          div_down  = i & X->Def.Tpow[2*j+1];
sz.c:          div_down  = div_down/X->Def.Tpow[2*j+1];
sz.c:          if(X->Def.LocSpn[j] != ITINERANT){
sz.c:            if(X->Def.Nsite%2==1 && j==(X->Def.Nsite/2)){
sz.c:          if(X->Def.Nsite%2==1 && X->Def.LocSpn[X->Def.Nsite/2] != ITINERANT){
sz.c:            jb +=X->Def.Tpow[X->Def.Nsite-1-(X->Def.NLocSpn-num_loc)];
sz.c:            jb +=X->Def.Tpow[X->Def.Nsite-(X->Def.NLocSpn-num_loc)];
sz.c:      for(ib=0;ib<X->Check.sdim;ib++){
sz.c:      hacker = X->Def.read_hacker;
sz.c:        for(ib=0;ib<X->Check.sdim;ib++){ // sdim = 2^(N/2)
sz.c:            div=i & X->Def.Tpow[j];
sz.c:            div=div/X->Def.Tpow[j];
sz.c:            div=i & X->Def.Tpow[j];
sz.c:            div=div/X->Def.Tpow[j];
sz.c:          tmp_res  = X->Def.Nsite%2; // even Ns-> 0, odd Ns -> 1
sz.c:          all_up   = (X->Def.Nsite+tmp_res)/2;
sz.c:          all_down = (X->Def.Nsite-tmp_res)/2;
sz.c:          tmp_1 = Binomial(all_up,X->Def.Nup-num_up,comb,all_up);
sz.c:          tmp_2 = Binomial(all_down,X->Def.Ndown-num_down,comb,all_down);
sz.c:        for(ib=0;ib<X->Check.sdim;ib++){
sz.c:        for(ib=0;ib<X->Check.sdim;ib++){
sz.c:            div=i & X->Def.Tpow[j];
sz.c:            div=div/X->Def.Tpow[j];
sz.c:            div=i & X->Def.Tpow[j];
sz.c:            div=div/X->Def.Tpow[j];
sz.c:          tmp_res  = X->Def.Nsite%2; // even Ns-> 0, odd Ns -> 1
sz.c:          all_up   = (X->Def.Nsite+tmp_res)/2;
sz.c:          all_down = (X->Def.Nsite-tmp_res)/2;
sz.c:          tmp_1 = Binomial(all_up,X->Def.Nup-num_up,comb,all_up);
sz.c:          tmp_2 = Binomial(all_down,X->Def.Ndown-num_down,comb,all_down);
sz.c:        for(ib=0;ib<X->Check.sdim;ib++){
sz.c:      hacker = X->Def.read_hacker;
sz.c:        iAllup=X->Def.Ne;
sz.c:        if(X->Def.Ne > X->Def.Nsite){
sz.c:          iMinup = X->Def.Ne-X->Def.Nsite;
sz.c:          iAllup = X->Def.Nsite;
sz.c:        for(ib=0;ib<X->Check.sdim;ib++){
sz.c:            div=i & X->Def.Tpow[j];
sz.c:            div=div/X->Def.Tpow[j];
sz.c:            div=i & X->Def.Tpow[j];
sz.c:            div=div/X->Def.Tpow[j];
sz.c:          tmp_res  = X->Def.Nsite%2; // even Ns-> 0, odd Ns -> 1
sz.c:          all_up   = (X->Def.Nsite+tmp_res)/2;
sz.c:          all_down = (X->Def.Nsite-tmp_res)/2;
sz.c:            tmp_2 = Binomial(all_down, X->Def.Ne-iSpnup-num_down,comb,all_down);
sz.c:        for(ib=0;ib<X->Check.sdim;ib++){
sz.c:        iAllup=X->Def.Ne;
sz.c:        if(X->Def.Ne > X->Def.Nsite){
sz.c:          iMinup = X->Def.Ne-X->Def.Nsite;
sz.c:          iAllup = X->Def.Nsite;
sz.c:        for(ib=0;ib<X->Check.sdim;ib++){
sz.c:            div=i & X->Def.Tpow[j];
sz.c:            div=div/X->Def.Tpow[j];
sz.c:            div=i & X->Def.Tpow[j];
sz.c:            div=div/X->Def.Tpow[j];
sz.c:          tmp_res  = X->Def.Nsite%2; // even Ns-> 0, odd Ns -> 1
sz.c:          all_up   = (X->Def.Nsite+tmp_res)/2;
sz.c:          all_down = (X->Def.Nsite-tmp_res)/2;
sz.c:            tmp_2 = Binomial(all_down, X->Def.Ne-iSpnup-num_down,comb,all_down);
sz.c:        for(ib=0;ib<X->Check.sdim;ib++){
sz.c:      N_all_up   = X->Def.Nup;
sz.c:      N_all_down = X->Def.Ndown;
sz.c:      for(j=X->Def.Nsite/2; j< X->Def.Nsite ;j++){// counting localized # of spins
sz.c:        if(X->Def.LocSpn[j] != ITINERANT){
sz.c:      for(ib=0;ib<X->Check.sdim;ib++){ //sdim = 2^(N/2)
sz.c:        for(j=X->Def.Nsite/2; j< X->Def.Nsite ;j++){
sz.c:          div_up    = i & X->Def.Tpow[2*j];
sz.c:          div_up    = div_up/X->Def.Tpow[2*j];
sz.c:          div_down  = i & X->Def.Tpow[2*j+1];
sz.c:          div_down  = div_down/X->Def.Tpow[2*j+1];
sz.c:          if(X->Def.LocSpn[j] == ITINERANT){
sz.c:            if(X->Def.Nsite%2==1 && j==(X->Def.Nsite/2)){ // odd site
sz.c:          tmp_res  = X->Def.Nsite%2; // even Ns-> 0, odd Ns -> 1
sz.c:          all_loc =  X->Def.NLocSpn-num_loc; // # of local spins
sz.c:          all_up   = (X->Def.Nsite+tmp_res)/2-all_loc;
sz.c:          all_down = (X->Def.Nsite-tmp_res)/2-all_loc;
sz.c:          if(X->Def.Nsite%2==1 && X->Def.LocSpn[X->Def.Nsite/2] != ITINERANT){
sz.c:            all_up   = (X->Def.Nsite)/2-all_loc;
sz.c:            all_down = (X->Def.Nsite)/2-all_loc;
sz.c:            if( X->Def.Nsite%2==1 && X->Def.LocSpn[X->Def.Nsite/2] != ITINERANT){
sz.c:                tmp_2 = Binomial(all_up, X->Def.Nup-num_up-num_loc_up, comb, all_up);
sz.c:                tmp_3 = Binomial(all_down, X->Def.Ndown-num_down-(all_loc-num_loc_up), comb, all_down);
sz.c:                tmp_2 = Binomial(all_up, X->Def.Nup-num_up-num_loc_up, comb, all_up);
sz.c:                tmp_3 = Binomial(all_down, X->Def.Ndown-num_down-(all_loc-num_loc_up), comb, all_down);
sz.c:              tmp_2 = Binomial(all_up, X->Def.Nup-num_up-num_loc_up, comb, all_up);
sz.c:              tmp_3 = Binomial(all_down, X->Def.Ndown-num_down-(all_loc-num_loc_up), comb, all_down);
sz.c:      hacker = X->Def.read_hacker;
sz.c:        for(ib=0;ib<X->Check.sdim;ib++){
sz.c:        for(ib=0;ib<X->Check.sdim;ib++){
sz.c:      if(X->Def.iFlgGeneralSpin==FALSE){
sz.c:        hacker = X->Def.read_hacker;
sz.c:        //printf(" rank=%d:Ne=%ld ihfbit=%ld sdim=%ld\n", myrank,X->Def.Ne,ihfbit,X->Check.sdim);
sz.c:          while(tmp_pow < X->Def.Tpow[X->Def.Ne]){
sz.c:          //printf("DEBUG: %ld %ld %ld %ld\n",tmp_i,X->Check.sdim,X->Def.Tpow[X->Def.Ne],X->Def.Nsite);
sz.c:          if(X->Def.Nsite%2==0){
sz.c:            max_tmp_i = X->Check.sdim*X->Check.sdim;
sz.c:            max_tmp_i = X->Check.sdim*X->Check.sdim*2-1;
sz.c:          for(ib=0;ib<X->Check.sdim;ib++){
sz.c:              div_up = i & X->Def.Tpow[j];
sz.c:              div_up = div_up/X->Def.Tpow[j];
sz.c:            all_up   = (X->Def.Nsite+1)/2;
sz.c:            tmp_1 = Binomial(all_up,X->Def.Ne-num_up,comb,all_up);
sz.c:          for(ib=0;ib<X->Check.sdim;ib++){
sz.c:          //printf(" rank=%d ib=%ld:Ne=%d icnt=%ld :idim_max=%ld N=%d\n", myrank,ib,X->Def.Ne,icnt,X->Check.idim_max,N);
sz.c:          for(ib=0;ib<X->Check.sdim;ib++){
sz.c:              div_up = i & X->Def.Tpow[j];
sz.c:              div_up = div_up/X->Def.Tpow[j];
sz.c:            all_up   = (X->Def.Nsite+1)/2;
sz.c:            tmp_1 = Binomial(all_up,X->Def.Ne-num_up,comb,all_up);
sz.c:          for(ib=0;ib<X->Check.sdim;ib++){
sz.c:        for(j=0; j<X->Def.Nsite; j++){
sz.c:          itmpSize *= X->Def.SiteToBit[j];
sz.c:        for(j=0; j<X->Def.Nsite; j++){
sz.c:          Max2Sz += X->Def.LocSpn[j];
sz.c:            i2Sz += GetLocal2Sz(j,ib, X->Def.SiteToBit, X->Def.Tpow);
sz.c:        long unsigned int ilftdim=(X->Def.Tpow[X->Def.Nsite-1]*X->Def.SiteToBit[X->Def.Nsite-1])/ihfbit;
sz.c:            i2Sz += GetLocal2Sz(j,ib, X->Def.SiteToBit, X->Def.Tpow);
sz.c:          if((X->Def.Total2Sz- i2Sz +(int)Max2Sz)>=0 && (X->Def.Total2Sz- i2Sz) <= (int)Max2Sz){
sz.c:            jb += HilbertNumToSz[X->Def.Total2Sz- i2Sz +Max2Sz];
sz.c:  if(X->Def.iFlgCalcSpec == CALCSPEC_NOT){
sz.c:    if(X->Def.iCalcModel==HubbardNConserved){
sz.c:      X->Def.iCalcModel=Hubbard;
sz.c:  if(i_max!=X->Check.idim_max){
sz.c:    fprintf(stderr, cErrSz_ShowDim, i_max, X->Check.idim_max);
sz.c:  i_free2(comb, X->Def.Nsite+1,X->Def.Nsite+1);
sz.c:    if(X->Def.iFlgGeneralSpin==TRUE){
sz.c:  for(j=0;j< X->Def.Nsite ;j++){
sz.c:    div_up    = i & X->Def.Tpow[2*j];
sz.c:    div_up    = div_up/X->Def.Tpow[2*j];
sz.c:    div_down  = i & X->Def.Tpow[2*j+1];
sz.c:    div_down  = div_down/X->Def.Tpow[2*j+1];
sz.c:  if(X->Def.iCalcModel==Hubbard){
sz.c:    for(ia=0;ia<X->Check.sdim;ia++){
sz.c:      for(j=0;j<X->Def.Nsite;j++){
sz.c:        div_up    = i & X->Def.Tpow[2*j];
sz.c:        div_up    = div_up/X->Def.Tpow[2*j];
sz.c:        div_down  = i & X->Def.Tpow[2*j+1];
sz.c:        div_down  = div_down/X->Def.Tpow[2*j+1];
sz.c:      if(num_up == X->Def.Nup && num_down == X->Def.Ndown){
sz.c:  else if(X->Def.iCalcModel==HubbardNConserved){
sz.c:    for(ia=0;ia<X->Check.sdim;ia++){
sz.c:      for(j=0;j<X->Def.Nsite;j++){
sz.c:        div_up    = i & X->Def.Tpow[2*j];
sz.c:        div_up    = div_up/X->Def.Tpow[2*j];
sz.c:        div_down  = i & X->Def.Tpow[2*j+1];
sz.c:        div_down  = div_down/X->Def.Tpow[2*j+1];
sz.c:      if( (num_up+num_down) == X->Def.Ne){
sz.c:  for(j=0;j< X->Def.Nsite ;j++){
sz.c:    div_up    = i & X->Def.Tpow[2*j];
sz.c:    div_up    = div_up/X->Def.Tpow[2*j];
sz.c:    div_down  = i & X->Def.Tpow[2*j+1];
sz.c:    div_down  = div_down/X->Def.Tpow[2*j+1];
sz.c:  if(X->Def.iCalcModel==Hubbard){
sz.c:    if(tmp_num_up <= X->Def.Nup && tmp_num_down <= X->Def.Ndown){ //do not exceed Nup and Ndown
sz.c:      ia = X->Def.Tpow[X->Def.Nup+X->Def.Ndown-tmp_num_up-tmp_num_down]-1;
sz.c:      if(ia < X->Check.sdim){
sz.c:        for(j=0;j<X->Def.Nsite;j++){
sz.c:          div_up    = ia & X->Def.Tpow[2*j];
sz.c:          div_up    = div_up/X->Def.Tpow[2*j];
sz.c:          div_down  = ia & X->Def.Tpow[2*j+1];
sz.c:          div_down  = div_down/X->Def.Tpow[2*j+1];
sz.c:        if(num_up == X->Def.Nup && num_down == X->Def.Ndown){
sz.c:          while(ia < X->Check.sdim){
sz.c:            for(j=0;j<X->Def.Nsite;j++){
sz.c:              div_up    = ia & X->Def.Tpow[2*j];
sz.c:              div_up    = div_up/X->Def.Tpow[2*j];
sz.c:              div_down  = ia & X->Def.Tpow[2*j+1];
sz.c:              div_down  = div_down/X->Def.Tpow[2*j+1];
sz.c:            if(num_up == X->Def.Nup && num_down == X->Def.Ndown){
sz.c:  else if(X->Def.iCalcModel==HubbardNConserved){
sz.c:    if(tmp_num_up+tmp_num_down <= X->Def.Ne){ //do not exceed Ne
sz.c:      ia = X->Def.Tpow[X->Def.Ne-tmp_num_up-tmp_num_down]-1;
sz.c:      if(ia < X->Check.sdim){
sz.c:          while(ia < X->Check.sdim){
sz.c:  for(j=X->Def.Nsite/2; j< X->Def.Nsite ;j++){
sz.c:    div_up    = i & X->Def.Tpow[2*j];
sz.c:    div_up    = div_up/X->Def.Tpow[2*j];
sz.c:    div_down  = i & X->Def.Tpow[2*j+1];
sz.c:    div_down  = div_down/X->Def.Tpow[2*j+1];
sz.c:    if(X->Def.LocSpn[j] == ITINERANT){
sz.c:      if(X->Def.Nsite%2==1 && j==(X->Def.Nsite/2)){
sz.c:    for(ia=0;ia<X->Check.sdim;ia++){
sz.c:      for(j=0;j<(X->Def.Nsite+1)/2;j++){
sz.c:        div_up    = i & X->Def.Tpow[2*j];
sz.c:        div_up    = div_up/X->Def.Tpow[2*j];
sz.c:        div_down  = i & X->Def.Tpow[2*j+1];
sz.c:        div_down  = div_down/X->Def.Tpow[2*j+1];
sz.c:        if(X->Def.LocSpn[j] ==  ITINERANT){
sz.c:          if(X->Def.Nsite%2==1 && j==(X->Def.Nsite/2)){
sz.c:      if(icheck_loc == 1 && X->Def.LocSpn[X->Def.Nsite/2] != ITINERANT && X->Def.Nsite%2==1){
sz.c:        div_up    = ia & X->Def.Tpow[X->Def.Nsite-1];
sz.c:        div_up    = div_up/X->Def.Tpow[X->Def.Nsite-1];
sz.c:        div_down  = (ib*ihfbit) & X->Def.Tpow[X->Def.Nsite];
sz.c:        div_down  = div_down/X->Def.Tpow[X->Def.Nsite];
sz.c:      if(num_up == X->Def.Nup && num_down == X->Def.Ndown && icheck_loc==1){
sz.c:  for(j=X->Def.Nsite/2; j< X->Def.Nsite ;j++){
sz.c:    div_up    = i & X->Def.Tpow[2*j];
sz.c:    div_up    = div_up/X->Def.Tpow[2*j];
sz.c:    div_down  = i & X->Def.Tpow[2*j+1];
sz.c:    div_down  = div_down/X->Def.Tpow[2*j+1];
sz.c:    if(X->Def.LocSpn[j] == ITINERANT){
sz.c:      if(X->Def.Nsite%2==1 && j==(X->Def.Nsite/2)){
sz.c:    //for(ia=0;ia<X->Check.sdim;ia++){
sz.c:    ia = X->Def.Tpow[X->Def.Nup+X->Def.Ndown-tmp_num_up-tmp_num_down]-1;
sz.c:    //if(ia < X->Check.sdim && ia!=0){
sz.c:    while(ia < X->Check.sdim && ia!=0){
sz.c:    // for(ia=0;ia<X->Check.sdim;ia++){
sz.c:        for(j=0;j<(X->Def.Nsite+1)/2;j++){
sz.c:          div_up    = i & X->Def.Tpow[2*j];
sz.c:          div_up    = div_up/X->Def.Tpow[2*j];
sz.c:          div_down  = i & X->Def.Tpow[2*j+1];
sz.c:          div_down  = div_down/X->Def.Tpow[2*j+1];
sz.c:          if(X->Def.LocSpn[j] ==  ITINERANT){
sz.c:            if(X->Def.Nsite%2==1 && j==(X->Def.Nsite/2)){
sz.c:        if(icheck_loc == 1 && X->Def.LocSpn[X->Def.Nsite/2] != ITINERANT && X->Def.Nsite%2==1){
sz.c:          div_up    = ia & X->Def.Tpow[X->Def.Nsite-1];
sz.c:          div_up    = div_up/X->Def.Tpow[X->Def.Nsite-1];
sz.c:          div_down  = (ib*ihfbit) & X->Def.Tpow[X->Def.Nsite];
sz.c:          div_down  = div_down/X->Def.Tpow[X->Def.Nsite];
sz.c:        if(num_up == X->Def.Nup && num_down == X->Def.Ndown && icheck_loc==1){
sz.c:  for(j=X->Def.Nsite/2; j< X->Def.Nsite ;j++){
sz.c:    div_up    = i & X->Def.Tpow[2*j];
sz.c:    div_up    = div_up/X->Def.Tpow[2*j];
sz.c:    div_down  = i & X->Def.Tpow[2*j+1];
sz.c:    div_down  = div_down/X->Def.Tpow[2*j+1];
sz.c:    if(X->Def.LocSpn[j] !=  ITINERANT){
sz.c:      if(X->Def.Nsite%2==1 && j==(X->Def.Nsite/2)){
sz.c:    for(ia=0;ia<X->Check.sdim;ia++){
sz.c:      for(j=0;j<(X->Def.Nsite+1)/2;j++){
sz.c:        div_up    = i & X->Def.Tpow[2*j];
sz.c:        div_up    = div_up/X->Def.Tpow[2*j];
sz.c:        div_down  = i & X->Def.Tpow[2*j+1];
sz.c:        div_down  = div_down/X->Def.Tpow[2*j+1];	
sz.c:        if(X->Def.LocSpn[j] !=  ITINERANT){
sz.c:          if(X->Def.Nsite%2==1 && j==(X->Def.Nsite/2)){
sz.c:      if(icheck_loc == 1 && X->Def.LocSpn[X->Def.Nsite/2] != ITINERANT && X->Def.Nsite%2==1){
sz.c:        div_up    = ia & X->Def.Tpow[X->Def.Nsite-1];
sz.c:        div_up    = div_up/X->Def.Tpow[X->Def.Nsite-1];
sz.c:        div_down  = (ib*ihfbit) & X->Def.Tpow[X->Def.Nsite];
sz.c:        div_down  = div_down/X->Def.Tpow[X->Def.Nsite];
sz.c:    div=i & X->Def.Tpow[j];
sz.c:    div=div/X->Def.Tpow[j];
sz.c:      div=i & X->Def.Tpow[j];
sz.c:      div=div/X->Def.Tpow[j];
sz.c:    if(num_up == X->Def.Ne){
sz.c:    div=i & X->Def.Tpow[j];
sz.c:    div=div/X->Def.Tpow[j];
sz.c:  if(tmp_num_up<=X->Def.Ne && (X->Def.Ne-tmp_num_up)<= X->Def.Nsite-1){ // do not exceed Ne
sz.c:    ia = X->Def.Tpow[X->Def.Ne-tmp_num_up]-1;
sz.c:    if(tmp_2Sz == X->Def.Total2Sz){
sz.c:  switch(X->Def.iCalcModel){
sz.c:    sprintf(sdt,cFileNameListModel, X->Def.Nsite, X->Def.Nup, X->Def.Ndown);
sz.c:    sprintf(sdt,"ListForKondo_Ns%d_Ncond%d.dat",X->Def.Nsite,X->Def.Ne);
time.c:  if(X->Def.iFlgCalcSpec == CALCSPEC_NOT){
time.c:    if(X->Def.iCalcType==TPQCalc) {
time.c:    else if(X->Def.iCalcType==Lanczos){
time.c:    else if(X->Def.iCalcType==FullDiag){
time.c:    if(X->Def.iCalcType==Lanczos){
time.c:    else if(X->Def.iCalcType==FullDiag){
time.c:  switch(X->Def.iCalcModel){
vec12.c:  nvec = X->Def.nvec;
vec12.c:  if(X->Def.iCalcType==Lanczos && X->Def.iFlgCalcSpec == 0)
vec12.c:    if (nvec < X->Def.LanczosTarget) nvec = X->Def.LanczosTarget;
xsetmem.c:  X->Def.CDataFileHead = (char*)malloc(D_FileNameMax*sizeof(char));
xsetmem.c:  X->Def.CParaFileHead = (char*)malloc(D_FileNameMax*sizeof(char));
xsetmem.c:  lui_malloc1(X->Def.Tpow, 2*X->Def.Nsite+2);
xsetmem.c:  lui_malloc1(X->Def.OrgTpow, 2*X->Def.Nsite+2);
xsetmem.c:  for(i=0; i<2*X->Def.Nsite+2; i++){
xsetmem.c:    X->Def.Tpow[i]=0;
xsetmem.c:    X->Def.OrgTpow[i]=0;
xsetmem.c:  li_malloc1(X->Def.SiteToBit, X->Def.Nsite+1);
xsetmem.c:  for(i=0; i<X->Def.Nsite+1; i++){
xsetmem.c:    X->Def.SiteToBit[i]=0;
xsetmem.c:  i_malloc1(X->Def.LocSpn, X->Def.Nsite);
xsetmem.c:  d_malloc1(X->Phys.spin_real_cor, X->Def.Nsite*X->Def.Nsite);
xsetmem.c:  d_malloc1(X->Phys.charge_real_cor, X->Def.Nsite*X->Def.Nsite);
xsetmem.c:  d_malloc1(X->Phys.loc_spin_z, X->Def.Nsite*X->Def.Nsite);
xsetmem.c:  i_malloc1(X->Def.EDChemi, X->Def.EDNChemi+X->Def.NInterAll+X->Def.NTransfer);
xsetmem.c:  i_malloc1(X->Def.EDSpinChemi, X->Def.EDNChemi+X->Def.NInterAll+X->Def.NTransfer);
xsetmem.c:  d_malloc1(X->Def.EDParaChemi, X->Def.EDNChemi+X->Def.NInterAll+X->Def.NTransfer);
xsetmem.c:  i_malloc2(X->Def.GeneralTransfer, X->Def.NTransfer, 4);
xsetmem.c:  c_malloc1(X->Def.ParaGeneralTransfer, X->Def.NTransfer);
xsetmem.c:  if(X->Def.iCalcType == TimeEvolution){
xsetmem.c:    i_malloc2(X->Def.EDGeneralTransfer, X->Def.NTransfer+X->Def.NTETransferMax, 4);
xsetmem.c:    c_malloc1(X->Def.EDParaGeneralTransfer, X->Def.NTransfer+X->Def.NTETransferMax);
xsetmem.c:    i_malloc2(X->Def.EDGeneralTransfer, X->Def.NTransfer, 4);
xsetmem.c:    c_malloc1(X->Def.EDParaGeneralTransfer, X->Def.NTransfer);
xsetmem.c:  i_malloc2(X->Def.CoulombIntra, X->Def.NCoulombIntra, 1);
xsetmem.c:  d_malloc1(X->Def.ParaCoulombIntra, X->Def.NCoulombIntra);
xsetmem.c:  i_malloc2(X->Def.CoulombInter, X->Def.NCoulombInter+X->Def.NIsingCoupling, 2);
xsetmem.c:  d_malloc1(X->Def.ParaCoulombInter, X->Def.NCoulombInter+X->Def.NIsingCoupling);
xsetmem.c:  i_malloc2(X->Def.HundCoupling, X->Def.NHundCoupling+X->Def.NIsingCoupling, 2);
xsetmem.c:  d_malloc1(X->Def.ParaHundCoupling, X->Def.NHundCoupling+X->Def.NIsingCoupling);
xsetmem.c:  i_malloc2(X->Def.PairHopping, X->Def.NPairHopping, 2);
xsetmem.c:  d_malloc1(X->Def.ParaPairHopping, X->Def.NPairHopping); 
xsetmem.c:  i_malloc2(X->Def.ExchangeCoupling, X->Def.NExchangeCoupling, 2);
xsetmem.c:  d_malloc1(X->Def.ParaExchangeCoupling, X->Def.NExchangeCoupling);
xsetmem.c:  i_malloc2(X->Def.PairLiftCoupling, X->Def.NPairLiftCoupling, 2);
xsetmem.c:  d_malloc1(X->Def.ParaPairLiftCoupling, X->Def.NPairLiftCoupling);
xsetmem.c:  i_malloc2(X->Def.InterAll, X->Def.NInterAll, 8);
xsetmem.c:  c_malloc1(X->Def.ParaInterAll, X->Def.NInterAll);
xsetmem.c:  i_malloc2(X->Def.CisAjt, X->Def.NCisAjt, 4);
xsetmem.c:  i_malloc2(X->Def.CisAjtCkuAlvDC, X->Def.NCisAjtCkuAlvDC, 8);
xsetmem.c:  i_malloc2(X->Def.SingleExcitationOperator, X->Def.NSingleExcitationOperator, 3);
xsetmem.c:  c_malloc1(X->Def.ParaSingleExcitationOperator, X->Def.NSingleExcitationOperator);
xsetmem.c:  i_malloc2(X->Def.PairExcitationOperator, X->Def.NPairExcitationOperator, 5);
xsetmem.c:  c_malloc1(X->Def.ParaPairExcitationOperator, X->Def.NPairExcitationOperator);
xsetmem.c:  d_malloc1(X->Def.ParaLaser, X->Def.NLaser);
xsetmem.c:  NInterAllSet= (X->Def.iCalcType==TimeEvolution) ? X->Def.NInterAll+X->Def.NTEInterAllMax: X->Def.NInterAll;
xsetmem.c:  i_malloc2(X->Def.InterAll_OffDiagonal, NInterAllSet, 8);
xsetmem.c:  c_malloc1(X->Def.ParaInterAll_OffDiagonal, NInterAllSet);
xsetmem.c:  i_malloc2(X->Def.InterAll_Diagonal, NInterAllSet, 4);
xsetmem.c:  d_malloc1(X->Def.ParaInterAll_Diagonal, NInterAllSet);
xsetmem.c:  if (X->Def.iCalcType == TimeEvolution){
xsetmem.c:    d_malloc1(X->Def.TETime, X->Def.NTETimeSteps);
xsetmem.c:    ui_malloc1(X->Def.NTETransfer, X->Def.NTETimeSteps);
xsetmem.c:    ui_malloc1(X->Def.NTETransferDiagonal, X->Def.NTETimeSteps);
xsetmem.c:    i_malloc3(X->Def.TETransfer, X->Def.NTETimeSteps, X->Def.NTETransferMax, 4);
xsetmem.c:    i_malloc3(X->Def.TETransferDiagonal, X->Def.NTETimeSteps, X->Def.NTETransferMax, 2);
xsetmem.c:    c_malloc2(X->Def.ParaTETransfer, X->Def.NTETimeSteps, X->Def.NTETransferMax);
xsetmem.c:    d_malloc2(X->Def.ParaTETransferDiagonal, X->Def.NTETimeSteps,X->Def.NTETransferMax);
xsetmem.c:    ui_malloc1(X->Def.NTEInterAll, X->Def.NTETimeSteps);
xsetmem.c:    ui_malloc1(X->Def.NTEInterAllDiagonal, X->Def.NTETimeSteps);
xsetmem.c:    i_malloc3(X->Def.TEInterAll, X->Def.NTETimeSteps, X->Def.NTEInterAllMax, 8);
xsetmem.c:    i_malloc3(X->Def.TEInterAllDiagonal, X->Def.NTETimeSteps, X->Def.NTEInterAllMax, 4);
xsetmem.c:    c_malloc2(X->Def.ParaTEInterAll, X->Def.NTETimeSteps, X->Def.NTEInterAllMax);
xsetmem.c:    d_malloc2(X->Def.ParaTEInterAllDiagonal, X->Def.NTETimeSteps,X->Def.NTEInterAllMax);
xsetmem.c:    ui_malloc1(X->Def.NTEInterAllOffDiagonal, X->Def.NTETimeSteps);
xsetmem.c:    i_malloc3(X->Def.TEInterAllOffDiagonal, X->Def.NTETimeSteps, X->Def.NTEInterAllMax, 8);
xsetmem.c:    c_malloc2(X->Def.ParaTEInterAllOffDiagonal, X->Def.NTETimeSteps,X->Def.NTEInterAllMax);
xsetmem.c:    ui_malloc1(X->Def.NTEChemi, X->Def.NTETimeSteps);
xsetmem.c:    i_malloc2(X->Def.TEChemi,  X->Def.NTETimeSteps, X->Def.NTEInterAllMax);
xsetmem.c:    i_malloc2(X->Def.SpinTEChemi,  X->Def.NTETimeSteps, X->Def.NTEInterAllMax);
xsetmem.c:    d_malloc2(X->Def.ParaTEChemi, X->Def.NTETimeSteps, X->Def.NTEInterAllMax);
xsetmem.c:    for(i = 0; i <  X->Def.NTETimeSteps; i++){
xsetmem.c:      X->Def.TETime[i]=0;
xsetmem.c:      X->Def.NTETransfer[i]=0;
xsetmem.c:      X->Def.NTETransferDiagonal[i]=0;
xsetmem.c:      X->Def.NTEChemi[i]=0;
xsetmem.c:      X->Def.NTEInterAll[i] = 0;
xsetmem.c:      X->Def.NTEInterAllDiagonal[i] = 0;
xsetmem.c:      X->Def.NTEInterAllOffDiagonal[i] = 0;
xsetmem.c:      for(j = 0; j < X->Def.NTETransferMax; j++) {
xsetmem.c:        X->Def.ParaTETransfer[i][j]=0;
xsetmem.c:        X->Def.ParaTETransferDiagonal[i][j]=0;
xsetmem.c:          X->Def.TETransfer[i][j][k]=0;
xsetmem.c:          X->Def.TETransferDiagonal[i][j][k]=0;
xsetmem.c:      for(j = 0; j < X->Def.NTEInterAllMax; j++){
xsetmem.c:        X->Def.ParaTEInterAll[i][j]=0;
xsetmem.c:        X->Def.ParaTEInterAllDiagonal[i][j]=0;
xsetmem.c:        X->Def.ParaTEInterAllOffDiagonal[i][j]=0;
xsetmem.c:        X->Def.TEChemi[i][j]=0;
xsetmem.c:        X->Def.SpinTEChemi[i][j]=0;
xsetmem.c:        X->Def.ParaTEChemi[i][j]=0;
xsetmem.c:          X->Def.TEInterAllDiagonal[i][j][k]=0;
xsetmem.c:          X->Def.TEInterAll[i][j][k]=0;
xsetmem.c:          X->Def.TEInterAllOffDiagonal[i][j][k]=0;
xsetmem.c:  idim_maxMPI = MaxMPI_li(X->Check.idim_max);
xsetmem.c:    lui_malloc1(list_1, X->Check.idim_max + 1);
xsetmem.c:    for (j = 0; j < X->Check.idim_max + 1; j++) {
xsetmem.c:    lui_malloc1(list_2_1, X->Large.SizeOflist_2_1);
xsetmem.c:    lui_malloc1(list_2_2, X->Large.SizeOflist_2_2);
xsetmem.c:    for (j = 0; j < X->Check.idim_max + 1; j++) {
xsetmem.c:    for (j = 0; j < X->Large.SizeOflist_2_1; j++) {
xsetmem.c:    for (j = 0; j < X->Large.SizeOflist_2_2; j++) {
xsetmem.c:  d_malloc1(list_Diagonal, X->Check.idim_max + 1);
xsetmem.c:  c_malloc1(v0, X->Check.idim_max + 1);
xsetmem.c:  c_malloc1(v1, X->Check.idim_max + 1);
xsetmem.c:  for (j = 0; j < X->Check.idim_max + 1; j++) {
xsetmem.c:    if (X->Def.iCalcType == TimeEvolution) {
xsetmem.c:      c_malloc1(v2, X->Check.idim_max + 1);
xsetmem.c:    for (j = 0; j < X->Check.idim_max + 1; j++) {
xsetmem.c:  if (X->Def.iCalcType == TPQCalc) {c_malloc1(vg, 1); vg[0]=0;}
xsetmem.c:    c_malloc1(vg, X->Check.idim_max+1);
xsetmem.c:    for(j =0; j<X->Check.idim_max+1; j++) {
xsetmem.c:  d_malloc1(alpha, X->Def.Lanczos_max+1);
xsetmem.c:  d_malloc1(beta, X->Def.Lanczos_max+1);
xsetmem.c:    if (X->Def.iCalcType == TPQCalc || X->Def.iFlgCalcSpec != CALCSPEC_NOT) {
xsetmem.c:      c_malloc2(vec, X->Def.Lanczos_max + 1, X->Def.Lanczos_max + 1);
xsetmem.c:    } else if (X->Def.iCalcType == Lanczos || X->Def.iCalcType == CG) {
xsetmem.c:      if (X->Def.LanczosTarget > X->Def.nvec) {
xsetmem.c:        c_malloc2(vec, X->Def.LanczosTarget + 1, X->Def.Lanczos_max + 1);
xsetmem.c:        c_malloc2(vec, X->Def.nvec + 1, X->Def.Lanczos_max + 1);
xsetmem.c:    if (X->Def.iCalcType == FullDiag) {
xsetmem.c:      d_malloc1(X->Phys.all_num_down, X->Check.idim_max + 1);
xsetmem.c:      d_malloc1(X->Phys.all_num_up, X->Check.idim_max + 1);
xsetmem.c:      d_malloc1(X->Phys.all_energy, X->Check.idim_max + 1);
xsetmem.c:      d_malloc1(X->Phys.all_doublon, X->Check.idim_max + 1);
xsetmem.c:      d_malloc1(X->Phys.all_sz, X->Check.idim_max + 1);
xsetmem.c:      d_malloc1(X->Phys.all_s2, X->Check.idim_max + 1);
xsetmem.c:      c_malloc2(Ham, X->Check.idim_max + 1, X->Check.idim_max + 1);
xsetmem.c:      c_malloc2(L_vec, X->Check.idim_max + 1, X->Check.idim_max + 1);
xsetmem.c:      if (X->Phys.all_num_down == NULL
xsetmem.c:          || X->Phys.all_num_up == NULL
xsetmem.c:          || X->Phys.all_energy == NULL
xsetmem.c:          || X->Phys.all_doublon == NULL
xsetmem.c:          || X->Phys.all_s2 == NULL
xsetmem.c:      for (j = 0; j < X->Check.idim_max + 1; j++) {
xsetmem.c:    } else if (X->Def.iCalcType == CG) {
xsetmem.c:      d_malloc1(X->Phys.all_num_down, X->Def.k_exct);
xsetmem.c:      d_malloc1(X->Phys.all_num_up, X->Def.k_exct);
xsetmem.c:      d_malloc1(X->Phys.all_energy, X->Def.k_exct);
xsetmem.c:      d_malloc1(X->Phys.all_doublon, X->Def.k_exct);
xsetmem.c:      d_malloc1(X->Phys.all_sz, X->Def.k_exct);
xsetmem.c:      d_malloc1(X->Phys.all_s2, X->Def.k_exct);
xsetmem.c://    idim_maxMPI = MaxMPI_li(X->Check.idim_max);
xsetmem.c:    switch (X->Def.iCalcModel) {
xsetmem.c:        if (X->Def.iFlgGeneralSpin == FALSE) {
xsetmem.c:          if (X->Def.iCalcModel == Spin && X->Def.Nsite % 2 == 1) {
xsetmem.c:            X->Large.SizeOflist_2_1 = X->Check.sdim * 2 + 2;
xsetmem.c:            X->Large.SizeOflist_2_1 = X->Check.sdim + 2;
xsetmem.c:          X->Large.SizeOflist_2_2 = X->Check.sdim + 2;
xsetmem.c:          X->Large.SizeOflistjb = X->Check.sdim + 2;
xsetmem.c:          X->Large.SizeOflist_2_1 = X->Check.sdim + 2;
xsetmem.c:          X->Large.SizeOflist_2_2 =
xsetmem.c:                  X->Def.Tpow[X->Def.Nsite - 1] * X->Def.SiteToBit[X->Def.Nsite - 1] / X->Check.sdim + 2;
xsetmem.c:          X->Large.SizeOflistjb =
xsetmem.c:                  X->Def.Tpow[X->Def.Nsite - 1] * X->Def.SiteToBit[X->Def.Nsite - 1] / X->Check.sdim + 2;
